{"version":3,"file":"index.umd.js","sources":["../src/utils/validation.ts","../src/utils/precision.ts","../src/core/config.ts","../src/core/constants.ts","../src/core/errors.ts","../src/operations/arithmetic.ts","../src/operations/bitwise.ts","../src/operations/power.ts","../src/storage/Heap.ts","../src/structures/Ackermann.ts","../src/structures/NumberTree.ts","../src/structures/BigArray.ts","../src/structures/PowerTower.ts","../src/utils/formatting.ts","../src/operations/comparison.ts","../src/operations/conversion.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Validation utilities for Hypernum library\r\n * Provides type checking and validation functions for large number operations\r\n */\r\n\r\n// Custom error types for validation\r\nexport class ValidationError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'ValidationError';\r\n    }\r\n  }\r\n  \r\n  export class OverflowError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'OverflowError';\r\n    }\r\n  }\r\n  \r\n  // Type guards\r\n  export const isBigInt = (value: unknown): value is bigint => {\r\n    return typeof value === 'bigint';\r\n  };\r\n  \r\n  export const isValidNumberString = (value: string): boolean => {\r\n    return /^-?\\d+$/.test(value);\r\n  };\r\n  \r\n  export const isValidNumber = (value: unknown): value is number => {\r\n    return typeof value === 'number' && !isNaN(value) && isFinite(value);\r\n  };\r\n  \r\n  // Type conversions with validation\r\n  export const toBigInt = (value: unknown): bigint => {\r\n    if (isBigInt(value)) {\r\n      return value;\r\n    }\r\n    \r\n    if (typeof value === 'string') {\r\n      if (!isValidNumberString(value)) {\r\n        throw new ValidationError(`Invalid number string: ${value}`);\r\n      }\r\n      return BigInt(value);\r\n    }\r\n    \r\n    if (isValidNumber(value)) {\r\n      if (!Number.isInteger(value)) {\r\n        throw new ValidationError('Cannot convert non-integer number to BigInt');\r\n      }\r\n      return BigInt(value);\r\n    }\r\n    \r\n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`);\r\n  };\r\n  \r\n  // Range validation\r\n  export const validateRange = (value: bigint, min?: bigint, max?: bigint): void => {\r\n    if (min !== undefined && value < min) {\r\n      throw new ValidationError(`Value ${value} is below minimum ${min}`);\r\n    }\r\n    if (max !== undefined && value > max) {\r\n      throw new ValidationError(`Value ${value} exceeds maximum ${max}`);\r\n    }\r\n  };\r\n  \r\n  // Operation safety checks\r\n  export const checkAdditionOverflow = (a: bigint, b: bigint): void => {\r\n    // Check if addition would overflow\r\n    if (b > 0 && a > BigInt(Number.MAX_SAFE_INTEGER) - b) {\r\n      throw new OverflowError('Addition would overflow');\r\n    }\r\n    if (b < 0 && a < BigInt(Number.MIN_SAFE_INTEGER) - b) {\r\n      throw new OverflowError('Addition would underflow');\r\n    }\r\n  };\r\n  \r\n  export const checkMultiplicationOverflow = (a: bigint, b: bigint): void => {\r\n    // Check if multiplication would overflow\r\n    if (a !== BigInt(0) && b !== BigInt(0)) {\r\n      const maxValue = BigInt(Number.MAX_SAFE_INTEGER);\r\n      const minValue = BigInt(Number.MIN_SAFE_INTEGER);\r\n      \r\n      if (a > maxValue / b || a < minValue / b) {\r\n        throw new OverflowError('Multiplication would overflow');\r\n      }\r\n    }\r\n  };\r\n  \r\n  export const checkPowerOverflow = (base: bigint, exponent: bigint): void => {\r\n    // Basic overflow checks for exponentiation\r\n    if (exponent < BigInt(0)) {\r\n      throw new ValidationError('Negative exponents not supported for integers');\r\n    }\r\n    \r\n    if (base === BigInt(0) && exponent === BigInt(0)) {\r\n      throw new ValidationError('Zero raised to zero is undefined');\r\n    }\r\n    \r\n    if (exponent > BigInt(1000)) {\r\n      throw new OverflowError('Exponent too large, computation would overflow');\r\n    }\r\n  };\r\n  \r\n  // Array and data structure validation\r\n  export const validateArrayLength = (length: number): void => {\r\n    if (!Number.isInteger(length) || length < 0) {\r\n      throw new ValidationError('Array length must be a non-negative integer');\r\n    }\r\n    if (length > Number.MAX_SAFE_INTEGER) {\r\n      throw new ValidationError('Array length exceeds maximum safe integer');\r\n    }\r\n  };\r\n  \r\n  export const validateArrayIndex = (index: number, length: number): void => {\r\n    if (!Number.isInteger(index)) {\r\n      throw new ValidationError('Array index must be an integer');\r\n    }\r\n    if (index < 0 || index >= length) {\r\n      throw new ValidationError('Array index out of bounds');\r\n    }\r\n  };\r\n  \r\n  // Tree validation\r\n  export const validateTreeNode = (value: unknown): void => {\r\n    try {\r\n      toBigInt(value);\r\n    } catch (error) {\r\n      throw new ValidationError('Invalid tree node value');\r\n    }\r\n  };\r\n  \r\n  // Heap validation\r\n  export const validateHeapProperty = <T>(\r\n    value: T,\r\n    parent: T | undefined,\r\n    comparator: (a: T, b: T) => -1 | 0 | 1,\r\n    isMinHeap: boolean\r\n  ): void => {\r\n    if (!parent) return;\r\n    \r\n    const comparison = comparator(value, parent);\r\n    if (isMinHeap && comparison < 0) {\r\n      throw new ValidationError('Min heap property violated');\r\n    }\r\n    if (!isMinHeap && comparison > 0) {\r\n      throw new ValidationError('Max heap property violated');\r\n    }\r\n  };\r\n  \r\n  // Ackermann function validation\r\n  export const validateAckermannInput = (m: number, n: number): void => {\r\n    if (!Number.isInteger(m) || !Number.isInteger(n)) {\r\n      throw new ValidationError('Ackermann inputs must be integers');\r\n    }\r\n    if (m < 0 || n < 0) {\r\n      throw new ValidationError('Ackermann inputs must be non-negative');\r\n    }\r\n    if (m > 4) {\r\n      throw new ValidationError('First Ackermann parameter too large for computation');\r\n    }\r\n  };\r\n  \r\n  // General numeric validation utilities\r\n  export const isInRange = (value: bigint, min: bigint, max: bigint): boolean => {\r\n    return value >= min && value <= max;\r\n  };\r\n  \r\n  export const isPowerOfTwo = (value: bigint): boolean => {\r\n    return value > BigInt(0) && (value & (value - BigInt(1))) === BigInt(0);\r\n  };\r\n  \r\n  export const validatePositive = (value: bigint): void => {\r\n    if (value <= BigInt(0)) {\r\n      throw new ValidationError('Value must be positive');\r\n    }\r\n  };\r\n  \r\n  export const validateNonNegative = (value: bigint): void => {\r\n    if (value < BigInt(0)) {\r\n      throw new ValidationError('Value must be non-negative');\r\n    }\r\n  };","/**\r\n * Precision utilities for Hypernum library\r\n * Provides functions for handling decimal precision and rounding operations\r\n */\r\n\r\nimport { ValidationError } from './validation';\r\n\r\n/**\r\n * Rounding modes for decimal operations\r\n */\r\nexport enum RoundingMode {\r\n  FLOOR = 'FLOOR',           // Round towards negative infinity\r\n  CEIL = 'CEIL',             // Round towards positive infinity\r\n  DOWN = 'DOWN',             // Round towards zero\r\n  UP = 'UP',                 // Round away from zero\r\n  HALF_EVEN = 'HALF_EVEN',   // Round to nearest even number when tied (Banker's rounding)\r\n  HALF_UP = 'HALF_UP',       // Round up when tied\r\n  HALF_DOWN = 'HALF_DOWN',   // Round down when tied\r\n}\r\n\r\n/**\r\n * Scale a bigint by a power of 10\r\n */\r\nexport const scaleByPowerOfTen = (value: bigint, power: number): bigint => {\r\n  if (power === 0) return value;\r\n  if (power > 0) {\r\n    return value * (BigInt(10) ** BigInt(power));\r\n  }\r\n  return value / (BigInt(10) ** BigInt(-power));\r\n};\r\n\r\n/**\r\n * Round a number according to specified mode and precision\r\n */\r\nexport const round = (\r\n  value: bigint,\r\n  precision: number = 0,\r\n  mode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  if (precision === 0) {\r\n    return value;\r\n  }\r\n\r\n  const scale = BigInt(10) ** BigInt(precision);\r\n  const scaled = value / scale;\r\n  const remainder = value % scale;\r\n\r\n  switch (mode) {\r\n    case RoundingMode.FLOOR:\r\n      return scaled * scale;\r\n\r\n    case RoundingMode.CEIL:\r\n      return remainder > 0n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.DOWN:\r\n      return value >= 0n ? scaled * scale : (scaled - 1n) * scale;\r\n\r\n    case RoundingMode.UP:\r\n      return value >= 0n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_UP:\r\n      return remainder >= scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_DOWN:\r\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_EVEN:\r\n      if (remainder === scale / 2n) {\r\n        return scaled % 2n === 0n ? scaled * scale : (scaled + 1n) * scale;\r\n      }\r\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    default:\r\n      throw new ValidationError('Invalid rounding mode');\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate precision required to represent a number without loss\r\n */\r\nexport const calculateRequiredPrecision = (value: bigint): number => {\r\n  if (value === 0n) return 0;\r\n  \r\n  const str = value.toString();\r\n  const nonZeroIndex = str.split('').reverse().findIndex(char => char !== '0');\r\n  return nonZeroIndex === -1 ? 0 : nonZeroIndex;\r\n};\r\n\r\n/**\r\n * Normalize two numbers to the same precision\r\n */\r\nexport const normalizePrecision = (\r\n  a: bigint,\r\n  b: bigint,\r\n  precisionA: number,\r\n  precisionB: number\r\n): [bigint, bigint] => {\r\n  const targetPrecision = Math.max(precisionA, precisionB);\r\n  \r\n  const scaledA = scaleByPowerOfTen(a, targetPrecision - precisionA);\r\n  const scaledB = scaleByPowerOfTen(b, targetPrecision - precisionB);\r\n  \r\n  return [scaledA, scaledB];\r\n};\r\n\r\n/**\r\n * Scale a division operation to achieve desired precision\r\n */\r\nexport const scaledDivision = (\r\n  numerator: bigint,\r\n  denominator: bigint,\r\n  precision: number,\r\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (denominator === 0n) {\r\n    throw new ValidationError('Division by zero');\r\n  }\r\n\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  // Scale up numerator to handle desired precision\r\n  const scaledNumerator = scaleByPowerOfTen(numerator, precision);\r\n  const quotient = scaledNumerator / denominator;\r\n  \r\n  return round(quotient, 0, roundingMode);\r\n};\r\n\r\n/**\r\n * Calculate the number of significant digits\r\n */\r\nexport const significantDigits = (value: bigint): number => {\r\n  const nonZeroPattern = /[1-9]/;\r\n  const str = value.toString();\r\n  const firstSignificant = str.search(nonZeroPattern);\r\n  if (firstSignificant === -1) return 0;\r\n  \r\n  const lastSignificant = str.split('').reverse().findIndex(char => char !== '0');\r\n  return str.length - firstSignificant - (lastSignificant === -1 ? 0 : lastSignificant);\r\n};\r\n\r\n/**\r\n * Truncate to specified number of significant digits\r\n */\r\nexport const truncateToSignificantDigits = (\r\n  value: bigint,\r\n  digits: number,\r\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (digits <= 0) {\r\n    throw new ValidationError('Number of significant digits must be positive');\r\n  }\r\n\r\n  const currentDigits = significantDigits(value);\r\n  \r\n  if (currentDigits <= digits) {\r\n    return value;\r\n  }\r\n\r\n  const scale = currentDigits - digits;\r\n  return round(value, scale, roundingMode);\r\n};\r\n\r\n/**\r\n * Check if two numbers are equal within a specified precision\r\n */\r\nexport const equalWithinPrecision = (\r\n  a: bigint,\r\n  b: bigint,\r\n  precision: number\r\n): boolean => {\r\n  const diff = a - b;\r\n  const tolerance = BigInt(10) ** BigInt(precision);\r\n  return diff.toString().length <= tolerance.toString().length;\r\n};\r\n\r\n/**\r\n * Get the fractional part of a number at a given precision\r\n */\r\nexport const getFractionalPart = (\r\n  value: bigint,\r\n  precision: number\r\n): bigint => {\r\n  if (precision <= 0) return 0n;\r\n  \r\n  const scale = BigInt(10) ** BigInt(precision);\r\n  return value % scale;\r\n};\r\n\r\n/**\r\n * Format a number with exact precision (no rounding)\r\n */\r\nexport const toExactPrecision = (value: bigint, precision: number): string => {\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  let str = value.toString();\r\n  const isNegative = str.startsWith('-');\r\n  if (isNegative) {\r\n    str = str.slice(1);\r\n  }\r\n\r\n  while (str.length <= precision) {\r\n    str = '0' + str;\r\n  }\r\n\r\n  const integerPart = str.slice(0, -precision) || '0';\r\n  const fractionalPart = str.slice(-precision);\r\n\r\n  return `${isNegative ? '-' : ''}${integerPart}.${fractionalPart}`;\r\n};","/**\r\n * Configuration type definitions for Hypernum library\r\n * Defines all configuration options and their default values\r\n */\r\n\r\nimport { RoundingMode } from '../utils/precision';\r\nimport { \r\n  FormatOptions,\r\n  DebugConfig,\r\n  CacheConfig,\r\n  MathConstantsConfig\r\n} from './common';\r\n\r\n/**\r\n * Basic configuration options for simple usage\r\n */\r\nexport interface BasicConfig {\r\n  /** Decimal precision for operations */\r\n  precision?: number;\r\n  /** Rounding mode for decimal operations */\r\n  roundingMode?: RoundingMode;\r\n  /** Whether to check for overflow */\r\n  checkOverflow?: boolean;\r\n  /** Maximum allowed computation steps */\r\n  maxSteps?: number;\r\n  /** Enable debug mode */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Configuration for arithmetic operations\r\n */\r\nexport interface ArithmeticConfig {\r\n  /** Default precision for decimal operations */\r\n  defaultPrecision: number;\r\n  /** Default rounding mode */\r\n  defaultRoundingMode: RoundingMode;\r\n  /** Whether to check for overflow by default */\r\n  checkOverflow: boolean;\r\n  /** Maximum steps for iterative calculations */\r\n  maxComputationSteps: number;\r\n  /** Configure automatic precision adjustment */\r\n  autoPrecision: {\r\n    enabled: boolean;\r\n    maxPrecision: number;\r\n    minPrecision: number;\r\n  };\r\n  /** Constants calculation configuration */\r\n  constants: MathConstantsConfig;\r\n}\r\n\r\n/**\r\n * Configuration for data structures\r\n */\r\nexport interface DataStructuresConfig {\r\n  /** Array configuration */\r\n  array: {\r\n    initialCapacity: number;\r\n    growthFactor: number;\r\n    maxSize: number;\r\n  };\r\n  /** Tree configuration */\r\n  tree: {\r\n    maxDepth: number;\r\n    autoBalance: boolean;\r\n    nodeLimit: number;\r\n  };\r\n  /** Heap configuration */\r\n  heap: {\r\n    initialCapacity: number;\r\n    growthPolicy: 'double' | 'linear' | 'fibonacci';\r\n    validatePropertyOnOperation: boolean;\r\n  };\r\n  /** Cache configuration */\r\n  cache: CacheConfig & {\r\n    enabled: boolean;\r\n    persistToDisk: boolean;\r\n    compressionEnabled: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration for number formatting\r\n */\r\nexport interface FormattingConfig extends FormatOptions {\r\n  /** Scientific notation configuration */\r\n  scientific: {\r\n    /** Minimum exponent to trigger scientific notation */\r\n    minExponent: number;\r\n    /** Maximum significant digits */\r\n    maxSignificantDigits: number;\r\n    /** Exponent separator character */\r\n    exponentSeparator: string;\r\n  };\r\n  /** Engineering notation configuration */\r\n  engineering: {\r\n    /** Use SI prefixes */\r\n    useSIPrefixes: boolean;\r\n    /** Custom unit definitions */\r\n    customUnits?: Map<number, string>;\r\n  };\r\n  /** Localization settings */\r\n  localization: {\r\n    /** Locale identifier */\r\n    locale: string;\r\n    /** Custom number formatting */\r\n    numberFormat?: Intl.NumberFormatOptions;\r\n    /** Use locale-specific grouping */\r\n    useLocaleGrouping: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration for performance monitoring\r\n */\r\nexport interface PerformanceConfig {\r\n  /** Enable performance tracking */\r\n  enableTracking: boolean;\r\n  /** Sampling rate for metrics (0-1) */\r\n  samplingRate: number;\r\n  /** Performance thresholds */\r\n  thresholds: {\r\n    /** Warning threshold in milliseconds */\r\n    warnThresholdMs: number;\r\n    /** Error threshold in milliseconds */\r\n    errorThresholdMs: number;\r\n    /** Maximum allowed memory usage in bytes */\r\n    maxMemoryBytes: number;\r\n  };\r\n  /** Metrics collection configuration */\r\n  metrics: {\r\n    /** Enable detailed operation timing */\r\n    timing: boolean;\r\n    /** Track memory usage */\r\n    memory: boolean;\r\n    /** Track cache performance */\r\n    cache: boolean;\r\n    /** Custom metrics to track */\r\n    custom?: Map<string, (operation: any) => number>;\r\n  };\r\n}\r\n\r\n/**\r\n * Feature flags for optional functionality\r\n */\r\nexport interface FeatureFlags {\r\n  /** Enable experimental features */\r\n  experimentalFeatures: boolean;\r\n  /** Use WebAssembly implementations when available */\r\n  useWasm: boolean;\r\n  /** Enable worker thread support */\r\n  workerThreads: boolean;\r\n  /** Enable SharedArrayBuffer support */\r\n  sharedArrayBuffer: boolean;\r\n  /** Enable BigInt64Array support */\r\n  bigIntTypedArrays: boolean;\r\n}\r\n\r\n/**\r\n * Full configuration interface with all options\r\n */\r\nexport interface FullConfig {\r\n  /** Arithmetic operation configuration */\r\n  arithmetic: ArithmeticConfig;\r\n  /** Data structure configuration */\r\n  dataStructures: DataStructuresConfig;\r\n  /** Formatting configuration */\r\n  formatting: FormattingConfig;\r\n  /** Performance configuration */\r\n  performance: PerformanceConfig;\r\n  /** Debug configuration */\r\n  debug: DebugConfig;\r\n  /** Feature flags */\r\n  features: FeatureFlags;\r\n}\r\n\r\n/**\r\n * Combined configuration type that can be either basic or full\r\n */\r\nexport type HypernumConfig = BasicConfig | FullConfig;\r\n\r\n/**\r\n * Default configuration values for basic config\r\n */\r\nexport const DEFAULT_BASIC_CONFIG: Required<BasicConfig> = {\r\n  precision: 0,\r\n  roundingMode: RoundingMode.HALF_EVEN,\r\n  checkOverflow: true,\r\n  maxSteps: 1000,\r\n  debug: false\r\n};\r\n\r\n/**\r\n * Full default configuration values\r\n */\r\nexport const DEFAULT_FULL_CONFIG: FullConfig = {\r\n  arithmetic: {\r\n    defaultPrecision: 0,\r\n    defaultRoundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true,\r\n    maxComputationSteps: 1000,\r\n    autoPrecision: {\r\n      enabled: true,\r\n      maxPrecision: 100,\r\n      minPrecision: 0\r\n    },\r\n    constants: {\r\n      precision: 50,\r\n      cache: true,\r\n      algorithm: 'series'\r\n    }\r\n  },\r\n  dataStructures: {\r\n    array: {\r\n      initialCapacity: 16,\r\n      growthFactor: 2,\r\n      maxSize: 1_000_000\r\n    },\r\n    tree: {\r\n      maxDepth: 1000,\r\n      autoBalance: true,\r\n      nodeLimit: 1_000_000\r\n    },\r\n    heap: {\r\n      initialCapacity: 16,\r\n      growthPolicy: 'double',\r\n      validatePropertyOnOperation: true\r\n    },\r\n    cache: {\r\n      enabled: true,\r\n      maxSize: 1000,\r\n      ttl: 3600000, // 1 hour\r\n      evictionPolicy: 'LRU',\r\n      persistToDisk: false,\r\n      compressionEnabled: false\r\n    }\r\n  },\r\n  formatting: {\r\n    notation: 'standard',\r\n    precision: 0,\r\n    grouping: true,\r\n    groupSize: 3,\r\n    decimalSeparator: '.',\r\n    groupSeparator: ',',\r\n    uppercase: false,\r\n    scientific: {\r\n      minExponent: 6,\r\n      maxSignificantDigits: 6,\r\n      exponentSeparator: 'e'\r\n    },\r\n    engineering: {\r\n      useSIPrefixes: true\r\n    },\r\n    localization: {\r\n      locale: 'en-US',\r\n      useLocaleGrouping: false\r\n    }\r\n  },\r\n  performance: {\r\n    enableTracking: false,\r\n    samplingRate: 0.1,\r\n    thresholds: {\r\n      warnThresholdMs: 100,\r\n      errorThresholdMs: 1000,\r\n      maxMemoryBytes: 1024 * 1024 * 1024 // 1GB\r\n    },\r\n    metrics: {\r\n      timing: true,\r\n      memory: true,\r\n      cache: true\r\n    }\r\n  },\r\n  debug: {\r\n    verbose: false,\r\n    trackPerformance: false,\r\n    logLevel: 'error'\r\n  },\r\n  features: {\r\n    experimentalFeatures: false,\r\n    useWasm: false,\r\n    workerThreads: false,\r\n    sharedArrayBuffer: false,\r\n    bigIntTypedArrays: true\r\n  }\r\n};\r\n\r\n/**\r\n * Type guard to check if config is a full configuration\r\n */\r\nexport function isFullConfig(config: HypernumConfig): config is FullConfig {\r\n  return 'arithmetic' in config && 'dataStructures' in config;\r\n}\r\n\r\n/**\r\n * Type guard to check if config is a basic configuration\r\n */\r\nexport function isBasicConfig(config: HypernumConfig): config is BasicConfig {\r\n  return !isFullConfig(config);\r\n}\r\n\r\n/**\r\n * Validates configuration values\r\n */\r\nexport function validateConfig(config: HypernumConfig): void {\r\n  if (isFullConfig(config)) {\r\n    validateFullConfig(config);\r\n  } else {\r\n    validateBasicConfig(config);\r\n  }\r\n}\r\n\r\n/**\r\n * Validates basic configuration values\r\n */\r\nfunction validateBasicConfig(config: BasicConfig): void {\r\n  if (config.precision !== undefined && config.precision < 0) {\r\n    throw new Error('Precision cannot be negative');\r\n  }\r\n  if (config.maxSteps !== undefined && config.maxSteps <= 0) {\r\n    throw new Error('Maximum steps must be positive');\r\n  }\r\n  if (config.debug !== undefined && typeof config.debug !== 'boolean') {\r\n    throw new Error('Debug flag must be a boolean');\r\n  }\r\n}\r\n\r\n/**\r\n * Validates full configuration values\r\n */\r\nfunction validateFullConfig(config: FullConfig): void {\r\n  if (config.arithmetic.defaultPrecision < 0) {\r\n    throw new Error('Default precision cannot be negative');\r\n  }\r\n  if (config.arithmetic.maxComputationSteps <= 0) {\r\n    throw new Error('Max computation steps must be positive');\r\n  }\r\n  if (config.dataStructures.array.initialCapacity <= 0) {\r\n    throw new Error('Initial capacity must be positive');\r\n  }\r\n  if (config.dataStructures.array.growthFactor <= 1) {\r\n    throw new Error('Growth factor must be greater than 1');\r\n  }\r\n  if (config.performance.samplingRate < 0 || config.performance.samplingRate > 1) {\r\n    throw new Error('Sampling rate must be between 0 and 1');\r\n  }\r\n}\r\n\r\n/**\r\n * Merges configuration with appropriate defaults\r\n */\r\nexport function mergeConfig(custom: Partial<HypernumConfig> = {}): HypernumConfig {\r\n  if (isFullConfig(custom  as FullConfig)) {\r\n    const fullConfig = custom as FullConfig;\r\n    return {\r\n      ...DEFAULT_FULL_CONFIG,\r\n      ...fullConfig,\r\n      arithmetic: { ...DEFAULT_FULL_CONFIG.arithmetic, ...fullConfig.arithmetic },\r\n      dataStructures: { ...DEFAULT_FULL_CONFIG.dataStructures, ...fullConfig.dataStructures },\r\n      formatting: { ...DEFAULT_FULL_CONFIG.formatting, ...fullConfig.formatting },\r\n      performance: { ...DEFAULT_FULL_CONFIG.performance, ...fullConfig.performance },\r\n      debug: { ...DEFAULT_FULL_CONFIG.debug, ...fullConfig.debug },\r\n      features: { ...DEFAULT_FULL_CONFIG.features, ...fullConfig.features }\r\n    };\r\n  }\r\n  \r\n  const basicConfig: BasicConfig = {\r\n    precision: (custom as Partial<BasicConfig>).precision ?? DEFAULT_BASIC_CONFIG.precision,\r\n    roundingMode: (custom as Partial<BasicConfig>).roundingMode ?? DEFAULT_BASIC_CONFIG.roundingMode,\r\n    checkOverflow: (custom as Partial<BasicConfig>).checkOverflow ?? DEFAULT_BASIC_CONFIG.checkOverflow,\r\n    maxSteps: (custom as Partial<BasicConfig>).maxSteps ?? DEFAULT_BASIC_CONFIG.maxSteps,\r\n    debug: (custom as Partial<BasicConfig>).debug ?? DEFAULT_BASIC_CONFIG.debug\r\n  };\r\n\r\n  return basicConfig;\r\n}","/**\r\n * Core constants for Hypernum library\r\n * Defines fundamental values and limits used across the library\r\n */\r\n\r\n// Numerical limits\r\nexport const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\r\nexport const MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\r\nexport const MAX_PRECISION = 100;\r\nexport const MAX_COMPUTATION_STEPS = 1000;\r\nexport const MAX_BITS = 1024;\r\n\r\n// Commonly used values\r\nexport const ZERO = BigInt(0);\r\nexport const ONE = BigInt(1);\r\nexport const TWO = BigInt(2);\r\nexport const TEN = BigInt(10);\r\nexport const NEGATIVE_ONE = BigInt(-1);\r\n\r\n// Power operation limits\r\nexport const MAX_POWER_BASE = BigInt(2) ** BigInt(53);\r\nexport const MAX_POWER_EXPONENT = BigInt(1000);\r\nexport const MAX_TETRATION_HEIGHT = BigInt(4);\r\nexport const MAX_FACTORIAL_INPUT = BigInt(1000);\r\n\r\n// Tree and heap configuration\r\nexport const DEFAULT_TREE_MAX_DEPTH = 1000;\r\nexport const DEFAULT_HEAP_INITIAL_CAPACITY = 16;\r\nexport const DEFAULT_ARRAY_GROWTH_FACTOR = 2;\r\nexport const MIN_ARRAY_CAPACITY = 16;\r\n\r\n// Formatting configuration\r\nexport const DEFAULT_DECIMAL_SEPARATOR = '.';\r\nexport const DEFAULT_GROUP_SEPARATOR = ',';\r\nexport const DEFAULT_GROUP_SIZE = 3;\r\nexport const MAX_GROUP_SIZE = 10;\r\n\r\n// Roman numeral limits\r\nexport const MIN_ROMAN_VALUE = 1;\r\nexport const MAX_ROMAN_VALUE = 3999;\r\n\r\n// Ackermann function limits\r\nexport const MAX_ACKERMANN_M = 4;\r\nexport const MAX_ACKERMANN_N = 1000;\r\n\r\n// Cache configuration\r\nexport const DEFAULT_CACHE_SIZE = 1000;\r\nexport const MAX_CACHE_SIZE = 10000;\r\n\r\n// Error messages\r\nexport const ERROR_MESSAGES = {\r\n  OVERFLOW: 'Operation would result in overflow',\r\n  UNDERFLOW: 'Operation would result in underflow',\r\n  NEGATIVE_ROOT: 'Cannot compute root of negative number',\r\n  NEGATIVE_EXPONENT: 'Negative exponents not supported for integers',\r\n  DIVISION_BY_ZERO: 'Division by zero',\r\n  INVALID_PRECISION: 'Precision must be non-negative and not exceed MAX_PRECISION',\r\n  INVALID_BASE: 'Base must be a positive integer',\r\n  INVALID_ROMAN: 'Invalid Roman numeral',\r\n  COMPUTATION_LIMIT: 'Computation exceeded maximum allowed steps',\r\n  NEGATIVE_INDEX: 'Array index cannot be negative',\r\n  TREE_DEPTH_EXCEEDED: 'Maximum tree depth exceeded',\r\n  INVALID_HEAP_PROPERTY: 'Heap property violation detected'\r\n} as const;\r\n\r\n// Feature flags for optional functionality\r\nexport const FEATURES = {\r\n  OVERFLOW_CHECKING: true,\r\n  AUTOMATIC_PRECISION: true,\r\n  MEMOIZATION: true,\r\n  TREE_BALANCING: true,\r\n  DEBUG_MODE: false\r\n} as const;\r\n\r\n// Default options for various operations\r\nexport const DEFAULT_OPTIONS = {\r\n  precision: 0,\r\n  roundingMode: 'HALF_EVEN',\r\n  checkOverflow: true,\r\n  maxSteps: MAX_COMPUTATION_STEPS,\r\n  grouping: true,\r\n  uppercase: false,\r\n  cache: true\r\n} as const;\r\n\r\n// Units for number formatting (powers of 1000)\r\nexport const NUMBER_UNITS = [\r\n  { value: 1n, symbol: '' },\r\n  { value: 1000n, symbol: 'K' },\r\n  { value: 1000000n, symbol: 'M' },\r\n  { value: 1000000000n, symbol: 'B' },\r\n  { value: 1000000000000n, symbol: 'T' },\r\n  { value: 1000000000000000n, symbol: 'Q' }\r\n] as const;\r\n\r\n// Performance monitoring thresholds\r\nexport const PERFORMANCE = {\r\n  WARN_THRESHOLD_MS: 100,\r\n  ERROR_THRESHOLD_MS: 1000,\r\n  MAX_ARRAY_SIZE: 1000000,\r\n  MAX_TREE_SIZE: 1000000\r\n} as const;","/**\r\n * Custom error types for Hypernum library\r\n * Provides specific error classes for different types of errors that can occur\r\n * during mathematical operations and data structure manipulations\r\n */\r\n\r\nimport { ERROR_MESSAGES } from './constants';\r\n\r\n/**\r\n * Base error class for Hypernum library\r\n * All other error classes inherit from this\r\n */\r\nexport class HypernumError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'HypernumError';\r\n    Object.setPrototypeOf(this, HypernumError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for validation failures\r\n */\r\nexport class ValidationError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for arithmetic overflow conditions\r\n */\r\nexport class OverflowError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.OVERFLOW) {\r\n    super(message);\r\n    this.name = 'OverflowError';\r\n    Object.setPrototypeOf(this, OverflowError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for arithmetic underflow conditions\r\n */\r\nexport class UnderflowError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.UNDERFLOW) {\r\n    super(message);\r\n    this.name = 'UnderflowError';\r\n    Object.setPrototypeOf(this, UnderflowError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for division by zero\r\n */\r\nexport class DivisionByZeroError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.DIVISION_BY_ZERO) {\r\n    super(message);\r\n    this.name = 'DivisionByZeroError';\r\n    Object.setPrototypeOf(this, DivisionByZeroError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for precision-related issues\r\n */\r\nexport class PrecisionError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_PRECISION) {\r\n    super(message);\r\n    this.name = 'PrecisionError';\r\n    Object.setPrototypeOf(this, PrecisionError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for computation limits exceeded\r\n */\r\nexport class ComputationLimitError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.COMPUTATION_LIMIT) {\r\n    super(message);\r\n    this.name = 'ComputationLimitError';\r\n    Object.setPrototypeOf(this, ComputationLimitError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid operations on data structures\r\n */\r\nexport class DataStructureError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'DataStructureError';\r\n    Object.setPrototypeOf(this, DataStructureError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for heap property violations\r\n */\r\nexport class HeapPropertyError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_HEAP_PROPERTY) {\r\n    super(message);\r\n    this.name = 'HeapPropertyError';\r\n    Object.setPrototypeOf(this, HeapPropertyError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for tree-related issues\r\n */\r\nexport class TreeError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.TREE_DEPTH_EXCEEDED) {\r\n    super(message);\r\n    this.name = 'TreeError';\r\n    Object.setPrototypeOf(this, TreeError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for array index out of bounds\r\n */\r\nexport class IndexError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.NEGATIVE_INDEX) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n    Object.setPrototypeOf(this, IndexError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid number format or conversion\r\n */\r\nexport class FormatError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'FormatError';\r\n    Object.setPrototypeOf(this, FormatError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid Roman numeral operations\r\n */\r\nexport class RomanNumeralError extends FormatError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_ROMAN) {\r\n    super(message);\r\n    this.name = 'RomanNumeralError';\r\n    Object.setPrototypeOf(this, RomanNumeralError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard to check if an error is a Hypernum error\r\n */\r\nexport function isHypernumError(error: unknown): error is HypernumError {\r\n  return error instanceof HypernumError;\r\n}\r\n\r\n/**\r\n * Helper function to wrap unknown errors into HypernumError\r\n */\r\nexport function wrapError(error: unknown): HypernumError {\r\n  if (isHypernumError(error)) {\r\n    return error;\r\n  }\r\n  if (error instanceof Error) {\r\n    return new HypernumError(error.message);\r\n  }\r\n  return new HypernumError('An unknown error occurred');\r\n}\r\n\r\n/**\r\n * Helper function to create an appropriate error from a message and optional type\r\n */\r\nexport function createError(message: string, type?: string): HypernumError {\r\n  switch (type) {\r\n    case 'validation':\r\n      return new ValidationError(message);\r\n    case 'overflow':\r\n      return new OverflowError(message);\r\n    case 'underflow':\r\n      return new UnderflowError(message);\r\n    case 'division':\r\n      return new DivisionByZeroError(message);\r\n    case 'precision':\r\n      return new PrecisionError(message);\r\n    case 'computation':\r\n      return new ComputationLimitError(message);\r\n    case 'heap':\r\n      return new HeapPropertyError(message);\r\n    case 'tree':\r\n      return new TreeError(message);\r\n    case 'index':\r\n      return new IndexError(message);\r\n    case 'format':\r\n      return new FormatError(message);\r\n    case 'roman':\r\n      return new RomanNumeralError(message);\r\n    default:\r\n      return new HypernumError(message);\r\n  }\r\n}","/**\r\n * Arithmetic operations module for Hypernum library\r\n * Provides high-precision arithmetic operations with BigInt support\r\n */\r\n\r\nimport {\r\n    validateNonNegative,\r\n    toBigInt,\r\n    checkAdditionOverflow,\r\n    checkMultiplicationOverflow,\r\n    checkPowerOverflow,\r\n    ValidationError,\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    round,\r\n    scaledDivision,\r\n    normalizePrecision,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for arithmetic operations\r\n   */\r\n  export interface ArithmeticOptions {\r\n    precision?: number;\r\n    roundingMode?: RoundingMode;\r\n    checkOverflow?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ArithmeticOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true\r\n  };\r\n  \r\n  /**\r\n   * Adds two numbers with optional precision and overflow checking\r\n   */\r\n  export function add(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkAdditionOverflow(bigA, bigB);\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA + bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA + scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Subtracts two numbers with optional precision and overflow checking\r\n   */\r\n  export function subtract(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkAdditionOverflow(bigA, -bigB);\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA - bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA - scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Multiplies two numbers with optional precision and overflow checking\r\n   */\r\n  export function multiply(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkMultiplicationOverflow(bigA, bigB);\r\n    }\r\n  \r\n    const result = bigA * bigB;\r\n    if (opts.precision === 0) {\r\n      return result;\r\n    }\r\n  \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Divides two numbers with specified precision and rounding\r\n   */\r\n  export function divide(\r\n    numerator: bigint | string | number,\r\n    denominator: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigNumerator = toBigInt(numerator);\r\n    const bigDenominator = toBigInt(denominator);\r\n  \r\n    if (bigDenominator === BigInt(0)) {\r\n      throw new ValidationError('Division by zero');\r\n    }\r\n  \r\n    return scaledDivision(\r\n      bigNumerator,\r\n      bigDenominator,\r\n      opts.precision,\r\n      opts.roundingMode\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Calculates remainder with optional precision\r\n   */\r\n  export function remainder(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (bigB === BigInt(0)) {\r\n      throw new ValidationError('Division by zero in remainder operation');\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA % bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA % scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Raises a number to a power with optional precision\r\n   */\r\n  export function power(\r\n    base: bigint | string | number,\r\n    exponent: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(base);\r\n    const bigExponent = toBigInt(exponent);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkPowerOverflow(bigBase, bigExponent);\r\n    }\r\n  \r\n    validateNonNegative(bigExponent);\r\n  \r\n    if (bigExponent === BigInt(0)) {\r\n      return BigInt(1);\r\n    }\r\n  \r\n    if (bigExponent === BigInt(1)) {\r\n      return bigBase;\r\n    }\r\n  \r\n    let result = bigBase;\r\n    let remaining = bigExponent - BigInt(1);\r\n  \r\n    while (remaining > BigInt(0)) {\r\n      if (opts.checkOverflow) {\r\n        checkMultiplicationOverflow(result, bigBase);\r\n      }\r\n      result *= bigBase;\r\n      remaining--;\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates the square root with specified precision\r\n   */\r\n  export function sqrt(\r\n    value: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    validateNonNegative(bigValue);\r\n  \r\n    if (bigValue === BigInt(0)) {\r\n      return BigInt(0);\r\n    }\r\n  \r\n    // Scale up for precision\r\n    const scaleFactor = BigInt(10) ** BigInt(opts.precision * 2);\r\n    const scaled = bigValue * scaleFactor;\r\n  \r\n    // Newton's method for square root\r\n    let x = scaled;\r\n    let y = (x + scaled / x) >> BigInt(1);\r\n  \r\n    while (y < x) {\r\n      x = y;\r\n      y = (x + scaled / x) >> BigInt(1);\r\n    }\r\n  \r\n    return round(x, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Calculates the absolute value\r\n   */\r\n  export function abs(value: bigint | string | number): bigint {\r\n    const bigValue = toBigInt(value);\r\n    return bigValue < BigInt(0) ? -bigValue : bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Returns the sign of a number (-1, 0, or 1)\r\n   */\r\n  export function sign(value: bigint | string | number): bigint {\r\n    const bigValue = toBigInt(value);\r\n    if (bigValue < BigInt(0)) return BigInt(-1);\r\n    if (bigValue > BigInt(0)) return BigInt(1);\r\n    return BigInt(0);\r\n  }\r\n  \r\n  /**\r\n   * Calculates the greatest common divisor of two numbers\r\n   */\r\n  export function gcd(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    let bigA = abs(toBigInt(a));\r\n    let bigB = abs(toBigInt(b));\r\n  \r\n    while (bigB !== BigInt(0)) {\r\n      const temp = bigB;\r\n      bigB = bigA % bigB;\r\n      bigA = temp;\r\n    }\r\n  \r\n    return bigA;\r\n  }\r\n  \r\n  /**\r\n   * Calculates the least common multiple of two numbers\r\n   */\r\n  export function lcm(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = abs(toBigInt(a));\r\n    const bigB = abs(toBigInt(b));\r\n    \r\n    if (bigA === BigInt(0) || bigB === BigInt(0)) {\r\n      return BigInt(0);\r\n    }\r\n  \r\n    return abs(bigA * bigB) / gcd(bigA, bigB);\r\n  }\r\n  \r\n  // /**\r\n  //  * Calculates factorial of a number\r\n  //  */\r\n  // export function factorial(value: bigint | string | number): bigint {\r\n  //   const bigValue = toBigInt(value);\r\n  //   validateNonNegative(bigValue);\r\n  \r\n  //   if (bigValue > BigInt(1000)) {\r\n  //     throw new OverflowError('Factorial input too large');\r\n  //   }\r\n  \r\n  //   if (bigValue <= BigInt(1)) {\r\n  //     return BigInt(1);\r\n  //   }\r\n  \r\n  //   let result = BigInt(1);\r\n  //   let current = BigInt(2);\r\n  \r\n  //   while (current <= bigValue) {\r\n  //     result *= current;\r\n  //     current++;\r\n  //   }\r\n  \r\n  //   return result;\r\n  // }\r\n  \r\n  export default {\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide,\r\n    remainder,\r\n    power,\r\n    sqrt,\r\n    abs,\r\n    sign,\r\n    gcd,\r\n    lcm, \r\n    // factorial\r\n  };","/**\r\n * Bitwise operations module for Hypernum library\r\n * Provides functions for bit-level manipulations of large numbers\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    validateNonNegative\r\n  } from '../utils/validation';\r\n  \r\n  /**\r\n   * Options for bitwise operations\r\n   */\r\n  export interface BitwiseOptions {\r\n    /** Maximum bits to consider in operations */\r\n    maxBits?: number;\r\n    /** Whether to throw on overflow */\r\n    strict?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<BitwiseOptions> = {\r\n    maxBits: 1024,\r\n    strict: true\r\n  };\r\n  \r\n  /**\r\n   * Validates shift amount is within reasonable bounds\r\n   */\r\n  function validateShift(shift: bigint, options: Required<BitwiseOptions>): void {\r\n    if (shift < 0n) {\r\n      throw new ValidationError('Shift amount cannot be negative');\r\n    }\r\n    if (options.strict && shift >= BigInt(options.maxBits)) {\r\n      throw new ValidationError(`Shift amount exceeds maximum of ${options.maxBits} bits`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise AND operation\r\n   */\r\n  export function and(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n\r\n    return bigA & bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise OR operation\r\n   */\r\n  export function or(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n    \r\n    return bigA | bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise XOR operation\r\n   */\r\n  export function xor(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n    \r\n    return bigA ^ bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise NOT operation\r\n   */\r\n  export function not(\r\n    value: bigint | string | number\r\n  ): bigint {\r\n    const bigValue = toBigInt(value);\r\n    \r\n    return ~bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Performs left shift operation\r\n   */\r\n  export function leftShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    return bigValue << bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Performs right shift operation\r\n   */\r\n  export function rightShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    return bigValue >> bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Performs unsigned right shift operation\r\n   * Note: BigInt doesn't have >>> operator, so we implement it manually\r\n   */\r\n  export function unsignedRightShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    \r\n    if (bigValue >= 0n) {\r\n      return bigValue >> bigShift;\r\n    }\r\n    \r\n    // Handle negative numbers by first converting to positive\r\n    const mask = (1n << BigInt(opts.maxBits)) - 1n;\r\n    return (bigValue & mask) >> bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Rotates bits left by specified amount\r\n   */\r\n  export function rotateLeft(\r\n    value: bigint | string | number,\r\n    rotation: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    let bigRotation = toBigInt(rotation);\r\n    \r\n    validateNonNegative(bigRotation);\r\n    \r\n    // Normalize rotation to be within maxBits\r\n    if (bigRotation >= BigInt(opts.maxBits)) {\r\n      bigRotation = bigRotation % BigInt(opts.maxBits);\r\n    }\r\n    \r\n    if (bigRotation === 0n) {\r\n      return bigValue;\r\n    }\r\n    \r\n    const leftPart = leftShift(bigValue, bigRotation, opts);\r\n    const rightPart = unsignedRightShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\r\n    \r\n    return leftPart | rightPart;\r\n  }\r\n  \r\n  /**\r\n   * Rotates bits right by specified amount\r\n   */\r\n  export function rotateRight(\r\n    value: bigint | string | number,\r\n    rotation: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    let bigRotation = toBigInt(rotation);\r\n    \r\n    validateNonNegative(bigRotation);\r\n    \r\n    // Normalize rotation to be within maxBits\r\n    if (bigRotation >= BigInt(opts.maxBits)) {\r\n      bigRotation = bigRotation % BigInt(opts.maxBits);\r\n    }\r\n    \r\n    if (bigRotation === 0n) {\r\n      return bigValue;\r\n    }\r\n    \r\n    const rightPart = unsignedRightShift(bigValue, bigRotation, opts);\r\n    const leftPart = leftShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\r\n    \r\n    return leftPart | rightPart;\r\n  }\r\n  \r\n  /**\r\n   * Counts number of set bits (1s)\r\n   */\r\n  export function popCount(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    let count = 0n;\r\n    while (bigValue !== 0n) {\r\n      count += bigValue & 1n;\r\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns number of trailing zero bits\r\n   */\r\n  export function trailingZeros(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return BigInt(opts.maxBits);\r\n    }\r\n    \r\n    let count = 0n;\r\n    while ((bigValue & 1n) === 0n) {\r\n      count++;\r\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns number of leading zero bits\r\n   */\r\n  export function leadingZeros(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return BigInt(opts.maxBits);\r\n    }\r\n    \r\n    let count = 0n;\r\n    const msb = 1n << BigInt(opts.maxBits - 1);\r\n    \r\n    while ((bigValue & msb) === 0n && count < BigInt(opts.maxBits)) {\r\n      count++;\r\n      bigValue = leftShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns bit at specified position\r\n   */\r\n  export function getBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): boolean {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return (bigValue & (1n << bigPosition)) !== 0n;\r\n  }\r\n  \r\n  /**\r\n   * Sets bit at specified position\r\n   */\r\n  export function setBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue | (1n << bigPosition);\r\n  }\r\n  \r\n  /**\r\n   * Clears bit at specified position\r\n   */\r\n  export function clearBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue & ~(1n << bigPosition);\r\n  }\r\n  \r\n  /**\r\n   * Toggles bit at specified position\r\n   */\r\n  export function toggleBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue ^ (1n << bigPosition);\r\n  }\r\n  \r\n  export default {\r\n    and,\r\n    or,\r\n    xor,\r\n    not,\r\n    leftShift,\r\n    rightShift,\r\n    unsignedRightShift,\r\n    rotateLeft,\r\n    rotateRight,\r\n    popCount,\r\n    trailingZeros,\r\n    leadingZeros,\r\n    getBit,\r\n    setBit,\r\n    clearBit,\r\n    toggleBit\r\n  };","/**\r\n * Power operations module for Hypernum library\r\n * Provides efficient implementations for exponentiation and related operations\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    OverflowError,\r\n    validateNonNegative,\r\n    checkPowerOverflow\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    round,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for power operations\r\n   */\r\n  export interface PowerOptions {\r\n    /** Precision for decimal operations */\r\n    precision?: number;\r\n    /** Rounding mode for decimal operations */\r\n    roundingMode?: RoundingMode;\r\n    /** Whether to check for overflow */\r\n    checkOverflow?: boolean;\r\n    /** Maximum allowed computation steps */\r\n    maxSteps?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<PowerOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true,\r\n    maxSteps: 1000\r\n  };\r\n  \r\n  /**\r\n   * Raises a number to an integer power using binary exponentiation\r\n   */\r\n  export function power(\r\n    baseValue: bigint | string | number,\r\n    exponentValue: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(baseValue);\r\n    const bigExponent = toBigInt(exponentValue);\r\n  \r\n    // Handle special cases\r\n    if (bigExponent === 0n) {\r\n      return 1n;\r\n    }\r\n    if (bigExponent === 1n) {\r\n      return bigBase;\r\n    }\r\n    if (bigBase === 0n && bigExponent < 0n) {\r\n      throw new ValidationError('Zero cannot be raised to a negative power');\r\n    }\r\n    if (bigBase === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigBase === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigBase === -1n) {\r\n      return bigExponent % 2n === 0n ? 1n : -1n;\r\n    }\r\n  \r\n    // Validate inputs\r\n    if (bigExponent < 0n) {\r\n      throw new ValidationError('Negative exponents not supported for integer power');\r\n    }\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkPowerOverflow(bigBase, bigExponent);\r\n    }\r\n  \r\n    // Binary exponentiation algorithm\r\n    let result = 1n;\r\n    let base = bigBase;\r\n    let exponent = bigExponent;\r\n    let steps = 0;\r\n  \r\n    while (exponent > 0n) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Power operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      if (exponent & 1n) {\r\n        result *= base;\r\n      }\r\n      base *= base;\r\n      exponent >>= 1n;\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates square root using Newton's method\r\n   */\r\n  export function sqrt(\r\n    value: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n  \r\n    validateNonNegative(bigValue);\r\n  \r\n    if (bigValue === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n  \r\n    // Newton's method for square root\r\n    let guess = bigValue >> 1n;\r\n    let lastGuess: bigint;\r\n    let steps = 0;\r\n  \r\n    do {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Square root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      lastGuess = guess;\r\n      guess = (guess + bigValue / guess) >> 1n;\r\n    } while (guess < lastGuess);\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(lastGuess, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return lastGuess;\r\n  }\r\n  \r\n  /**\r\n   * Calculates nth root using Newton's method\r\n   */\r\n  export function nthRoot(\r\n    value: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigValue);\r\n    if (bigN <= 0n) {\r\n      throw new ValidationError('Root index must be positive');\r\n    }\r\n  \r\n    if (bigValue === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigN === 1n) {\r\n      return bigValue;\r\n    }\r\n    if (bigN === 2n) {\r\n      return sqrt(bigValue, opts);\r\n    }\r\n  \r\n    // Newton's method for nth root\r\n    let guess = bigValue >> 1n;\r\n    let lastGuess: bigint;\r\n    let steps = 0;\r\n  \r\n    const nMinus1 = bigN - 1n;\r\n  \r\n    do {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Nth root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      lastGuess = guess;\r\n      const powered = power(guess, nMinus1, opts);\r\n      guess = ((nMinus1 * guess) + (bigValue / powered)) / bigN;\r\n    } while (guess < lastGuess);\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(lastGuess, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return lastGuess;\r\n  }\r\n  \r\n  /**\r\n   * Calculates tetration (repeated exponentiation)\r\n   * a↑↑n = a^(a^(a^...)) (n times)\r\n   */\r\n  export function tetration(\r\n    base: bigint | string | number,\r\n    height: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(base);\r\n    const bigHeight = toBigInt(height);\r\n  \r\n    validateNonNegative(bigHeight);\r\n  \r\n    if (bigHeight === 0n) {\r\n      return 1n;\r\n    }\r\n    if (bigHeight === 1n) {\r\n      return bigBase;\r\n    }\r\n    if (bigBase === 0n) {\r\n      return bigHeight % 2n === 0n ? 1n : 0n;\r\n    }\r\n    if (bigBase === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigBase === 2n && bigHeight > 4n) {\r\n      throw new OverflowError('Tetration would overflow for base 2 and height > 4');\r\n    }\r\n  \r\n    let result = bigBase;\r\n    let steps = 0;\r\n  \r\n    for (let i = 1n; i < bigHeight; i++) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Tetration operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      result = power(bigBase, result, opts);\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates super-root (inverse tetration)\r\n   * Finds x where x↑↑n = value\r\n   */\r\n  export function superRoot(\r\n    value: bigint | string | number,\r\n    height: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigHeight = toBigInt(height);\r\n  \r\n    validateNonNegative(bigHeight);\r\n    if (bigHeight === 0n) {\r\n      throw new ValidationError('Height cannot be zero for super-root');\r\n    }\r\n    if (bigValue < 1n) {\r\n      throw new ValidationError('Value must be at least 1 for super-root');\r\n    }\r\n  \r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigHeight === 1n) {\r\n      return bigValue;\r\n    }\r\n  \r\n    // Binary search for super-root\r\n    let left = 1n;\r\n    let right = bigValue;\r\n    let steps = 0;\r\n  \r\n    while (left <= right) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Super-root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      const mid = (left + right) >> 1n;\r\n      try {\r\n        const test = tetration(mid, bigHeight, opts);\r\n        if (test === bigValue) {\r\n          return mid;\r\n        }\r\n        if (test < bigValue) {\r\n          left = mid + 1n;\r\n        } else {\r\n          right = mid - 1n;\r\n        }\r\n      } catch (error) {\r\n        right = mid - 1n;\r\n      }\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(right, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return right;\r\n  }\r\n  \r\n  export default {\r\n    power,\r\n    sqrt,\r\n    nthRoot,\r\n    tetration,\r\n    superRoot\r\n  };","/**\r\n * Represents the result of a comparison operation\r\n * -1: first value is less than second value\r\n *  0: values are equal\r\n *  1: first value is greater than second value\r\n */\r\nexport type ComparisonResult = -1 | 0 | 1;\r\n\r\n/**\r\n * Generic comparator function type for heap elements\r\n */\r\nexport type Comparator<T> = (a: T, b: T) => ComparisonResult;\r\n\r\n/**\r\n * Abstract base heap class implementing common heap operations\r\n */\r\nabstract class Heap<T> {\r\n  protected heap: T[];\r\n  protected readonly compare: Comparator<T>;\r\n\r\n  constructor(comparator: Comparator<T>) {\r\n    this.heap = [];\r\n    this.compare = comparator;\r\n  }\r\n\r\n  /**\r\n   * Gets the size of the heap\r\n   */\r\n  public size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  /**\r\n   * Checks if the heap is empty\r\n   */\r\n  public isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Peeks at the root element without removing it\r\n   */\r\n  public peek(): T | undefined {\r\n    return this.heap[0];\r\n  }\r\n\r\n  /**\r\n   * Inserts a new element into the heap\r\n   */\r\n  public push(value: T): void {\r\n    this.heap.push(value);\r\n    this.siftUp(this.heap.length - 1);\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the root element\r\n   */\r\n  public pop(): T | undefined {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n\r\n    const root = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n\r\n    if (!this.isEmpty()) {\r\n      this.heap[0] = last;\r\n      this.siftDown(0);\r\n    }\r\n\r\n    return root;\r\n  }\r\n\r\n  /**\r\n   * Removes all elements from the heap\r\n   */\r\n  public clear(): void {\r\n    this.heap = [];\r\n  }\r\n\r\n  /**\r\n   * Creates a heap from an array of elements\r\n   */\r\n  public static heapify<T extends {}>(array: T[], comparator: Comparator<T>): Heap<T> {\r\n    const heap = this instanceof MinHeap ? new MinHeap(comparator) : new MaxHeap(comparator);\r\n    array.forEach(item => heap.push(item));\r\n    return heap;\r\n  }\r\n\r\n  /**\r\n   * Gets the parent index of a node\r\n   */\r\n  protected getParentIndex(index: number): number {\r\n    return Math.floor((index - 1) / 2);\r\n  }\r\n\r\n  /**\r\n   * Gets the left child index of a node\r\n   */\r\n  protected getLeftChildIndex(index: number): number {\r\n    return 2 * index + 1;\r\n  }\r\n\r\n  /**\r\n   * Gets the right child index of a node\r\n   */\r\n  protected getRightChildIndex(index: number): number {\r\n    return 2 * index + 2;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the heap\r\n   */\r\n  protected swap(i: number, j: number): void {\r\n    const temp = this.heap[i]!;\r\n    this.heap[i] = this.heap[j]!;\r\n    this.heap[j] = temp;\r\n  }\r\n\r\n  /**\r\n   * Moves an element up the heap until heap property is satisfied\r\n   */\r\n  protected abstract siftUp(index: number): void;\r\n\r\n  /**\r\n   * Moves an element down the heap until heap property is satisfied\r\n   */\r\n  protected abstract siftDown(index: number): void;\r\n}\r\n\r\n/**\r\n * MinHeap implementation where the root is the smallest element\r\n */\r\nexport class MinHeap<T> extends Heap<T> {\r\n  constructor(comparator: Comparator<T>) {\r\n    super(comparator);\r\n  }\r\n\r\n  protected siftUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = this.getParentIndex(index);\r\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) >= 0) {\r\n        break;\r\n      }\r\n      this.swap(index, parentIndex);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  protected siftDown(index: number): void {\r\n    const size = this.heap.length;\r\n    \r\n    while (true) {\r\n      let smallest = index;\r\n      const left = this.getLeftChildIndex(index);\r\n      const right = this.getRightChildIndex(index);\r\n\r\n      if (left < size && this.compare(this.heap[left]!, this.heap[smallest]!) < 0) {\r\n        smallest = left;\r\n      }\r\n\r\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right] as T, this.heap[smallest] as T) < 0) {\r\n        smallest = right;\r\n      }\r\n\r\n      if (smallest === index) {\r\n        break;\r\n      }\r\n\r\n      this.swap(index, smallest);\r\n      index = smallest;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * MaxHeap implementation where the root is the largest element\r\n */\r\nexport class MaxHeap<T> extends Heap<T> {\r\n  constructor(comparator: Comparator<T>) {\r\n    super(comparator);\r\n  }\r\n\r\n  protected siftUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = this.getParentIndex(index);\r\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) <= 0) {\r\n        break;\r\n      }\r\n      this.swap(index, parentIndex);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  protected siftDown(index: number): void {\r\n    const size = this.heap.length;\r\n    \r\n    while (true) {\r\n      let largest = index;\r\n      const left = this.getLeftChildIndex(index);\r\n      const right = this.getRightChildIndex(index);\r\n\r\n      if (left < size && this.heap[left] !== undefined && this.compare(this.heap[left]!, this.heap[largest]!) > 0) {\r\n        largest = left;\r\n      }\r\n\r\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right]!, this.heap[largest]!) > 0) {\r\n        largest = right;\r\n      }\r\n\r\n      if (largest === index) {\r\n        break;\r\n      }\r\n\r\n      this.swap(index, largest);\r\n      index = largest;\r\n    }\r\n  }\r\n}\r\n\r\n// Type Guards\r\nexport const isMinHeap = <T>(heap: Heap<T>): heap is MinHeap<T> => {\r\n  return heap instanceof MinHeap;\r\n};\r\n\r\nexport const isMaxHeap = <T>(heap: Heap<T>): heap is MaxHeap<T> => {\r\n  return heap instanceof MaxHeap;\r\n};\r\n\r\n/**\r\n * Custom comparator for large numbers\r\n */\r\nexport function createLargeNumberComparator(): (a: bigint, b: bigint) => number {\r\n  return (a, b) => {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n  };\r\n}","import { MaxHeap, createLargeNumberComparator, Comparator } from \"../storage/Heap\";\r\n\r\n  /**\r\n   * Interface representing an Ackermann node in the computation structure\r\n   */\r\n  interface IAckermannNode {\r\n    m: number;\r\n    n: number;\r\n    value: bigint;\r\n    prevM?: IAckermannNode;  // Link to A(m-1, n)\r\n    prevN?: IAckermannNode;  // Link to A(m, n-1)\r\n    nextM?: IAckermannNode;  // Link to A(m+1, n)\r\n    nextN?: IAckermannNode;  // Link to A(m, n+1)\r\n  }\r\n  \r\n  /**\r\n   * Type for Ackermann computation path step\r\n   */\r\n  type ComputationStep = {\r\n    m: number;\r\n    n: number;\r\n    value: bigint;\r\n  };\r\n  \r\n  /**\r\n   * Type for growth rate analysis\r\n   */\r\n  type GrowthAnalysis = {\r\n    value: bigint;\r\n    increase: bigint;\r\n    multiplier: bigint;\r\n  };\r\n  \r\n  /**\r\n   * Class representing the Ackermann function computation structure\r\n   * Implements caching and relationship tracking between values\r\n   */\r\n  export class AckermannStructure {\r\n    private nodes: Map<string, IAckermannNode>;\r\n    private maxComputedM: number;\r\n    private maxComputedN: number;\r\n    private heap: MaxHeap<bigint>;\r\n  \r\n    constructor() {\r\n      this.nodes = new Map();\r\n      this.maxComputedM = -1;\r\n      this.maxComputedN = -1;\r\n      this.heap = new MaxHeap<bigint>(createLargeNumberComparator() as Comparator<bigint>);\r\n    }\r\n  \r\n    /**\r\n     * Generates a unique key for node storage\r\n     */\r\n    private static getNodeKey(m: number, n: number): string {\r\n      return `${m},${n}`;\r\n    }\r\n  \r\n    /**\r\n     * Computes the Ackermann function value\r\n     * Uses recursion with memoization\r\n     */\r\n    private computeAckermann(m: number, n: number): bigint {\r\n      // Handle invalid inputs\r\n      if (m < 0 || n < 0) {\r\n        throw new Error('Ackermann function undefined for negative numbers');\r\n      }\r\n  \r\n      // Check if already computed\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      const existing = this.nodes.get(key);\r\n      if (existing) {\r\n        return existing.value;\r\n      }\r\n  \r\n      // Compute based on Ackermann function definition\r\n      let value: bigint;\r\n      try {\r\n        if (m === 0) {\r\n          value = BigInt(n + 1);\r\n        } else if (n === 0) {\r\n          value = this.computeAckermann(m - 1, 1);\r\n        } else {\r\n          const inner = this.computeAckermann(m, n - 1);\r\n          // Convert bigint to number for recursion, being careful about size\r\n          const innerNum = inner <= BigInt(Number.MAX_SAFE_INTEGER) \r\n            ? Number(inner) \r\n            : Number.MAX_SAFE_INTEGER;\r\n          value = this.computeAckermann(m - 1, innerNum);\r\n        }\r\n      } catch (error) {\r\n        // Handle stack overflow or computation limits\r\n        if (error instanceof RangeError) {\r\n          return BigInt(Number.MAX_SAFE_INTEGER);\r\n        }\r\n        throw error;\r\n      }\r\n  \r\n      return value;\r\n    }\r\n  \r\n    /**\r\n     * Adds a new node to the structure\r\n     */\r\n    public addNode(m: number, n: number): IAckermannNode {\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      if (this.nodes.has(key)) {\r\n        return this.nodes.get(key)!;\r\n      }\r\n  \r\n      // Create new node\r\n      const value = this.computeAckermann(m, n);\r\n      const node: IAckermannNode = { m, n, value };\r\n      this.nodes.set(key, node);\r\n  \r\n      // Link to existing nodes\r\n      const prevMKey = AckermannStructure.getNodeKey(m - 1, n);\r\n      const prevNKey = AckermannStructure.getNodeKey(m, n - 1);\r\n  \r\n      if (this.nodes.has(prevMKey)) {\r\n        const prevM = this.nodes.get(prevMKey)!;\r\n        node.prevM = prevM;\r\n        prevM.nextM = node;\r\n      }\r\n  \r\n      if (this.nodes.has(prevNKey)) {\r\n        const prevN = this.nodes.get(prevNKey)!;\r\n        node.prevN = prevN;\r\n        prevN.nextN = node;\r\n      }\r\n  \r\n      // Update tracking\r\n      this.maxComputedM = Math.max(this.maxComputedM, m);\r\n      this.maxComputedN = Math.max(this.maxComputedN, n);\r\n      this.heap.push(value);\r\n  \r\n      return node;\r\n    }\r\n  \r\n    /**\r\n     * Builds nodes for a range of m and n values\r\n     */\r\n    public buildRange(mRange: number, nRange: number): void {\r\n      for (let m = 0; m <= mRange; m++) {\r\n        for (let n = 0; n <= nRange; n++) {\r\n          this.addNode(m, n);\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Gets the computation path to reach A(m,n)\r\n     */\r\n    public getComputationPath(m: number, n: number): ComputationStep[] {\r\n      const path: ComputationStep[] = [];\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      let current = this.nodes.get(key);\r\n  \r\n      while (current) {\r\n        path.push({\r\n          m: current.m,\r\n          n: current.n,\r\n          value: current.value\r\n        });\r\n  \r\n        // Follow computation path backwards\r\n        if (current.m === 0) {\r\n          break;\r\n        } else if (current.n === 0) {\r\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, 1));\r\n        } else {\r\n          const prevN = this.nodes.get(AckermannStructure.getNodeKey(current.m, current.n - 1));\r\n          if (prevN) {\r\n            path.push({\r\n              m: prevN.m,\r\n              n: prevN.n,\r\n              value: prevN.value\r\n            });\r\n          }\r\n          // Convert bigint to number safely for the next lookup\r\n          const nextValue = prevN?.value ?? BigInt(0);\r\n          const safeNextValue = nextValue <= BigInt(Number.MAX_SAFE_INTEGER)\r\n            ? Number(nextValue)\r\n            : Number.MAX_SAFE_INTEGER;\r\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, safeNextValue));\r\n        }\r\n      }\r\n  \r\n      return path.reverse();\r\n    }\r\n  \r\n    /**\r\n     * Analyzes growth rate for a fixed m value\r\n     */\r\n    public analyzeGrowthRate(m: number): Map<number, GrowthAnalysis> {\r\n      const growth = new Map<number, GrowthAnalysis>();\r\n      let prevValue = BigInt(1);\r\n  \r\n      for (let n = 0; n <= this.maxComputedN; n++) {\r\n        const key = AckermannStructure.getNodeKey(m, n);\r\n        const node = this.nodes.get(key);\r\n        if (!node || node.value >= BigInt(Number.MAX_SAFE_INTEGER)) {\r\n          break;\r\n        }\r\n  \r\n        growth.set(n, {\r\n          value: node.value,\r\n          increase: node.value - prevValue,\r\n          multiplier: prevValue === BigInt(0) ? BigInt(0) : node.value / prevValue\r\n        });\r\n  \r\n        prevValue = node.value;\r\n      }\r\n  \r\n      return growth;\r\n    }\r\n  \r\n    /**\r\n     * Gets the largest computed value\r\n     */\r\n    public getLargestValue(): bigint {\r\n      return this.heap.peek() ?? BigInt(0);\r\n    }\r\n  \r\n    /**\r\n     * Gets a specific Ackermann value if it exists\r\n     */\r\n    public getValue(m: number, n: number): bigint | undefined {\r\n      return this.nodes.get(AckermannStructure.getNodeKey(m, n))?.value;\r\n    }\r\n  }\r\n  \r\n  export default AckermannStructure;","import { Comparator } from '../storage/Heap';\r\n/**\r\n * Interface for tree node statistics\r\n */\r\ninterface NodeStats {\r\n  height: number;\r\n  size: number;\r\n  sum: bigint;\r\n  min: bigint;\r\n  max: bigint;\r\n}\r\n\r\n/**\r\n * Interface for tree traversal configuration\r\n */\r\ninterface TraversalConfig {\r\n  includeStats?: boolean;\r\n  skipSubtrees?: boolean;\r\n  maxDepth?: number;\r\n}\r\n\r\n/**\r\n * Class representing a node in the number tree\r\n */\r\nclass NumberNode {\r\n  value: bigint;\r\n  left: NumberNode | null;\r\n  right: NumberNode | null;\r\n  parent: NumberNode | null;\r\n  height: number;\r\n  size: number;\r\n  sum: bigint;\r\n\r\n  constructor(value: bigint | string | number) {\r\n    this.value = typeof value === 'bigint' ? value : BigInt(value);\r\n    this.left = null;\r\n    this.right = null;\r\n    this.parent = null;\r\n    this.height = 1;\r\n    this.size = 1;\r\n    this.sum = this.value;\r\n  }\r\n\r\n  /**\r\n   * Updates node statistics based on children\r\n   */\r\n  updateStats(): void {\r\n    this.height = 1 + Math.max(\r\n      this.left?.height ?? 0,\r\n      this.right?.height ?? 0\r\n    );\r\n    this.size = 1 + (this.left?.size ?? 0) + (this.right?.size ?? 0);\r\n    this.sum = this.value + \r\n      (this.left?.sum ?? BigInt(0)) + \r\n      (this.right?.sum ?? BigInt(0));\r\n  }\r\n\r\n  /**\r\n   * Gets balance factor of the node\r\n   */\r\n  getBalance(): number {\r\n    return (this.left?.height ?? 0) - (this.right?.height ?? 0);\r\n  }\r\n\r\n  /**\r\n   * Gets complete statistics for the node and its subtree\r\n   */\r\n  getStats(): NodeStats {\r\n    return {\r\n      height: this.height,\r\n      size: this.size,\r\n      sum: this.sum,\r\n      min: this.findMin().value,\r\n      max: this.findMax().value\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Finds minimum value node in the subtree\r\n   */\r\n  findMin(): NumberNode {\r\n    let current: NumberNode = this;\r\n    while (current.left) {\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Finds maximum value node in the subtree\r\n   */\r\n  findMax(): NumberNode {\r\n    let current: NumberNode = this;\r\n    while (current.right) {\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n}\r\n\r\n/**\r\n * AVL Tree implementation specialized for handling large numbers\r\n */\r\nexport class NumberTree {\r\n  private root: NumberNode | null;\r\n  private readonly comparator: Comparator<bigint>;\r\n\r\n  constructor(comparator?: Comparator<bigint>) {\r\n    this.root = null;\r\n    this.comparator = comparator ?? ((a: bigint, b: bigint): -1 | 0 | 1 => {\r\n      if (a < b) return -1;\r\n      if (a > b) return 1;\r\n      return 0;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the root node if it exists\r\n   */\r\n  public getRoot(): NumberNode | null {\r\n    return this.root;\r\n  }\r\n\r\n  /**\r\n   * Inserts a new value into the tree\r\n   */\r\n  public insert(value: bigint | string | number): NumberNode {\r\n    const newValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    this.root = this.insertNode(this.root, newValue);\r\n    return this.find(newValue)!;\r\n  }\r\n\r\n  /**\r\n   * Recursively inserts a new node\r\n   */\r\n  private insertNode(node: NumberNode | null, value: bigint): NumberNode {\r\n    if (!node) {\r\n      return new NumberNode(value);\r\n    }\r\n\r\n    const compareResult = this.comparator(value, node.value);\r\n    if (compareResult < 0) {\r\n      node.left = this.insertNode(node.left, value);\r\n      node.left.parent = node;\r\n    } else if (compareResult > 0) {\r\n      node.right = this.insertNode(node.right, value);\r\n      node.right.parent = node;\r\n    } else {\r\n      return node; // Duplicate value, return existing node\r\n    }\r\n\r\n    node.updateStats();\r\n    return this.balance(node);\r\n  }\r\n\r\n  /**\r\n   * Balances a node using AVL rotations\r\n   */\r\n  private balance(node: NumberNode): NumberNode {\r\n    const balance = node.getBalance();\r\n\r\n    // Left heavy\r\n    if (balance > 1) {\r\n      if (node.left && node.left.getBalance() < 0) {\r\n        node.left = this.rotateLeft(node.left);\r\n      }\r\n      return this.rotateRight(node);\r\n    }\r\n\r\n    // Right heavy\r\n    if (balance < -1) {\r\n      if (node.right && node.right.getBalance() > 0) {\r\n        node.right = this.rotateRight(node.right);\r\n      }\r\n      return this.rotateLeft(node);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Performs left rotation\r\n   */\r\n  private rotateLeft(node: NumberNode): NumberNode {\r\n    const rightChild = node.right!;\r\n    const rightLeftChild = rightChild.left;\r\n\r\n    rightChild.left = node;\r\n    node.right = rightLeftChild;\r\n\r\n    if (rightLeftChild) {\r\n      rightLeftChild.parent = node;\r\n    }\r\n    rightChild.parent = node.parent;\r\n    node.parent = rightChild;\r\n\r\n    node.updateStats();\r\n    rightChild.updateStats();\r\n\r\n    return rightChild;\r\n  }\r\n\r\n  /**\r\n   * Performs right rotation\r\n   */\r\n  private rotateRight(node: NumberNode): NumberNode {\r\n    const leftChild = node.left!;\r\n    const leftRightChild = leftChild.right;\r\n\r\n    leftChild.right = node;\r\n    node.left = leftRightChild;\r\n\r\n    if (leftRightChild) {\r\n      leftRightChild.parent = node;\r\n    }\r\n    leftChild.parent = node.parent;\r\n    node.parent = leftChild;\r\n\r\n    node.updateStats();\r\n    leftChild.updateStats();\r\n\r\n    return leftChild;\r\n  }\r\n\r\n  /**\r\n   * Removes a value from the tree\r\n   */\r\n  public remove(value: bigint | string | number): boolean {\r\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    const nodeToRemove = this.find(searchValue);\r\n    \r\n    if (!nodeToRemove) {\r\n      return false;\r\n    }\r\n\r\n    this.root = this.removeNode(this.root, searchValue);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Recursively removes a node\r\n   */\r\n  private removeNode(node: NumberNode | null, value: bigint): NumberNode | null {\r\n    if (!node) {\r\n      return null;\r\n    }\r\n\r\n    const compareResult = this.comparator(value, node.value);\r\n    if (compareResult < 0) {\r\n      node.left = this.removeNode(node.left, value);\r\n      if (node.left) {\r\n        node.left.parent = node;\r\n      }\r\n    } else if (compareResult > 0) {\r\n      node.right = this.removeNode(node.right, value);\r\n      if (node.right) {\r\n        node.right.parent = node;\r\n      }\r\n    } else {\r\n      // Node to delete found\r\n      if (!node.left) {\r\n        return node.right;\r\n      }\r\n      if (!node.right) {\r\n        return node.left;\r\n      }\r\n\r\n      // Node has two children\r\n      const successor = node.right.findMin();\r\n      node.value = successor.value;\r\n      node.right = this.removeNode(node.right, successor.value);\r\n      if (node.right) {\r\n        node.right.parent = node;\r\n      }\r\n    }\r\n\r\n    node.updateStats();\r\n    return this.balance(node);\r\n  }\r\n\r\n  /**\r\n   * Finds a node by value\r\n   */\r\n  public find(value: bigint | string | number): NumberNode | null {\r\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    let current = this.root;\r\n\r\n    while (current) {\r\n      const compareResult = this.comparator(searchValue, current.value);\r\n      if (compareResult === 0) {\r\n        return current;\r\n      }\r\n      current = compareResult < 0 ? current.left : current.right;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Traverses the tree in specified order and returns values\r\n   */\r\n  public traverse(order: 'inOrder' | 'preOrder' | 'postOrder' = 'inOrder', \r\n                 config: TraversalConfig = {}): bigint[] {\r\n    const result: bigint[] = [];\r\n    \r\n    const traverse = (node: NumberNode | null, depth: number = 0): void => {\r\n      if (!node || (config.maxDepth !== undefined && depth >= config.maxDepth)) {\r\n        return;\r\n      }\r\n\r\n      if (order === 'preOrder') {\r\n        result.push(node.value);\r\n      }\r\n\r\n      if (!config.skipSubtrees) {\r\n        traverse(node.left, depth + 1);\r\n      }\r\n\r\n      if (order === 'inOrder') {\r\n        result.push(node.value);\r\n      }\r\n\r\n      if (!config.skipSubtrees) {\r\n        traverse(node.right, depth + 1);\r\n      }\r\n\r\n      if (order === 'postOrder') {\r\n        result.push(node.value);\r\n      }\r\n    };\r\n\r\n    traverse(this.root);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets overall tree statistics\r\n   */\r\n  public getTreeStats(): NodeStats | null {\r\n    return this.root?.getStats() ?? null;\r\n  }\r\n\r\n  /**\r\n   * Gets the nth smallest value in the tree\r\n   */\r\n  public getNthValue(n: number): bigint | null {\r\n    if (!this.root || n < 1 || n > this.root.size) {\r\n      return null;\r\n    }\r\n\r\n    const findNth = (node: NumberNode | null, position: number): bigint | null => {\r\n      if (!node) {\r\n        return null;\r\n      }\r\n\r\n      const leftSize = node.left?.size ?? 0;\r\n      \r\n      if (position === leftSize + 1) {\r\n        return node.value;\r\n      }\r\n      \r\n      if (position <= leftSize) {\r\n        return findNth(node.left, position);\r\n      }\r\n      \r\n      return findNth(node.right, position - leftSize - 1);\r\n    };\r\n\r\n    return findNth(this.root, n);\r\n  }\r\n\r\n  /**\r\n   * Gets a range of values between start and end (inclusive)\r\n   */\r\n  public getRange(start: bigint | string | number, \r\n                 end: bigint | string | number): bigint[] {\r\n    const startValue = typeof start === 'bigint' ? start : BigInt(start);\r\n    const endValue = typeof end === 'bigint' ? end : BigInt(end);\r\n    const result: bigint[] = [];\r\n\r\n    const collectRange = (node: NumberNode | null): void => {\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      if (this.comparator(node.value, startValue) >= 0 && \r\n          this.comparator(node.value, endValue) <= 0) {\r\n        collectRange(node.left);\r\n        result.push(node.value);\r\n        collectRange(node.right);\r\n      } else if (this.comparator(node.value, startValue) > 0) {\r\n        collectRange(node.left);\r\n      } else {\r\n        collectRange(node.right);\r\n      }\r\n    };\r\n\r\n    collectRange(this.root);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default NumberTree;","import { Comparator, MinHeap, MaxHeap } from '../storage/Heap';\r\n\r\n/**\r\n * Interface for segment tree node operations\r\n */\r\nexport interface SegmentTreeNode<T> {  value: T;\r\n  lazy?: T;\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\n/**\r\n * Type for BigArray operation result\r\n */\r\nexport type OperationResult<T> = {\r\n  success: boolean;\r\n  value?: T;\r\n  error?: string;\r\n};\r\n\r\n/**\r\n * Options for BigArray initialization\r\n */\r\nexport interface BigArrayOptions<T> {\r\n  initialCapacity?: number;\r\n  growthFactor?: number;\r\n  comparator?: Comparator<T>;\r\n}\r\n\r\n/**\r\n * A specialized array implementation for handling large numbers and providing\r\n * efficient operations with segment tree support\r\n */\r\nexport class BigArray<T> {\r\n  private data: T[];\r\n  private segmentTree: Array<SegmentTreeNode<T> | null>;\r\n  private readonly growthFactor: number;\r\n  private readonly comparator: Comparator<T>;\r\n  private size: number;\r\n  private capacity: number;\r\n\r\n  constructor(options: BigArrayOptions<T> = {}) {\r\n    const {\r\n      initialCapacity = 16,\r\n      growthFactor = 2,\r\n      comparator = ((a: T, b: T): -1 | 0 | 1 => {\r\n        if (a < b) return -1;\r\n        if (a > b) return 1;\r\n        return 0;\r\n      }) as Comparator<T>\r\n    } = options;\r\n\r\n    this.capacity = initialCapacity;\r\n    this.growthFactor = growthFactor;\r\n    this.comparator = comparator;\r\n    this.size = 0;\r\n    this.data = new Array(this.capacity);\r\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\r\n  }\r\n\r\n  /**\r\n   * Gets the current size of the array\r\n   */\r\n  public getSize(): number {\r\n    return this.size;\r\n  }\r\n\r\n  /**\r\n   * Gets the current capacity of the array\r\n   */\r\n  public getCapacity(): number {\r\n    return this.capacity;\r\n  }\r\n\r\n  /**\r\n   * Resizes the internal array when needed\r\n   */\r\n  private resize(newCapacity: number): void {\r\n    const newData = new Array(newCapacity);\r\n    for (let i = 0; i < this.size; i++) {\r\n      newData[i] = this.data[i];\r\n    }\r\n    this.data = newData;\r\n    this.capacity = newCapacity;\r\n    this.rebuildSegmentTree();\r\n  }\r\n\r\n  /**\r\n   * Appends an element to the end of the array\r\n   */\r\n  public push(value: T): OperationResult<number> {\r\n    try {\r\n      if (this.size >= this.capacity) {\r\n        this.resize(this.capacity * this.growthFactor);\r\n      }\r\n      this.data[this.size] = value;\r\n      this.updateSegmentTree(0, this.size, value);\r\n      this.size++;\r\n      return { success: true, value: this.size - 1 };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error during push'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the last element\r\n   */\r\n  public pop(): OperationResult<T> {\r\n    if (this.size === 0) {\r\n      return { success: false, error: 'Array is empty' };\r\n    }\r\n\r\n    const value = this.data[this.size - 1];\r\n    this.size--;\r\n    \r\n    // Shrink array if it's too sparse\r\n    if (this.size < this.capacity / (this.growthFactor * 2)) {\r\n      this.resize(Math.max(16, Math.floor(this.capacity / this.growthFactor)));\r\n    }\r\n\r\n    return { success: true, value };\r\n  }\r\n\r\n  /**\r\n   * Gets element at specified index\r\n   */\r\n  public get(index: number): OperationResult<T> {\r\n    if (index < 0 || index >= this.size) {\r\n      return { success: false, error: 'Index out of bounds' };\r\n    }\r\n    return { success: true, value: this.data[index] };\r\n  }\r\n\r\n  /**\r\n   * Sets element at specified index\r\n   */\r\n  public set(index: number, value: T): OperationResult<T> {\r\n    if (index < 0 || index >= this.size) {\r\n      return { success: false, error: 'Index out of bounds' };\r\n    }\r\n    \r\n    const oldValue = this.data[index];\r\n    this.data[index] = value;\r\n    this.updateSegmentTree(0, index, value);\r\n    \r\n    return { success: true, value: oldValue };\r\n  }\r\n\r\n  /**\r\n   * Rebuilds the segment tree after major changes\r\n   */\r\n  private rebuildSegmentTree(): void {\r\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\r\n    if (this.size > 0) {\r\n      this.buildSegmentTree(0, 0, this.size - 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds a segment tree node recursively\r\n   */\r\n  private buildSegmentTree(node: number, start: number, end: number): void {\r\n    if (start === end) {\r\n      this.segmentTree[node] = {\r\n        value: this.data[start] as T,\r\n        start,\r\n        end\r\n      };\r\n      return;\r\n    }\r\n\r\n    const mid = Math.floor((start + end) / 2);\r\n    this.buildSegmentTree(2 * node + 1, start, mid);\r\n    this.buildSegmentTree(2 * node + 2, mid + 1, end);\r\n\r\n    const leftNode = this.segmentTree[2 * node + 1];\r\n    const rightNode = this.segmentTree[2 * node + 2];\r\n\r\n    if (leftNode && rightNode) {\r\n      this.segmentTree[node] = {\r\n        value: this.comparator(leftNode.value, rightNode.value) >= 0 \r\n          ? leftNode.value \r\n          : rightNode.value,\r\n        start,\r\n        end\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the segment tree after a value change\r\n   */\r\n  private updateSegmentTree(node: number, index: number, value: T): void {\r\n    if (!this.segmentTree[node]) {\r\n      return;\r\n    }\r\n\r\n    const currentNode = this.segmentTree[node]!;\r\n    if (currentNode.start === currentNode.end) {\r\n      currentNode.value = value;\r\n      return;\r\n    }\r\n\r\n    const mid = Math.floor((currentNode.start + currentNode.end) / 2);\r\n    if (index <= mid) {\r\n      this.updateSegmentTree(2 * node + 1, index, value);\r\n    } else {\r\n      this.updateSegmentTree(2 * node + 2, index, value);\r\n    }\r\n\r\n    const leftNode = this.segmentTree[2 * node + 1];\r\n    const rightNode = this.segmentTree[2 * node + 2];\r\n\r\n    if (leftNode && rightNode) {\r\n      currentNode.value = this.comparator(leftNode.value, rightNode.value) >= 0 \r\n        ? leftNode.value \r\n        : rightNode.value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Queries the maximum value in a range\r\n   */\r\n  public queryRange(start: number, end: number): OperationResult<T> {\r\n    if (start < 0 || end >= this.size || start > end) {\r\n      return { success: false, error: 'Invalid range' };\r\n    }\r\n\r\n    const result = this.querySegmentTree(0, start, end);\r\n    return result \r\n      ? { success: true, value: result }\r\n      : { success: false, error: 'Range query failed' };\r\n  }\r\n\r\n  /**\r\n   * Recursively queries the segment tree\r\n   */\r\n  private querySegmentTree(node: number, queryStart: number, queryEnd: number): T | null {\r\n    const currentNode = this.segmentTree[node];\r\n    if (!currentNode) {\r\n      return null;\r\n    }\r\n\r\n    if (queryStart <= currentNode.start && queryEnd >= currentNode.end) {\r\n      return currentNode.value;\r\n    }\r\n\r\n    if (queryEnd < currentNode.start || queryStart > currentNode.end) {\r\n      return null;\r\n    }\r\n\r\n    const leftResult = this.querySegmentTree(2 * node + 1, queryStart, queryEnd);\r\n    const rightResult = this.querySegmentTree(2 * node + 2, queryStart, queryEnd);\r\n\r\n    if (leftResult === null) return rightResult;\r\n    if (rightResult === null) return leftResult;\r\n\r\n    return this.comparator(leftResult, rightResult) >= 0 ? leftResult : rightResult;\r\n  }\r\n\r\n  /**\r\n   * Creates a heap from the current array\r\n   */\r\n  public toHeap(isMin: boolean = true): MinHeap<T> | MaxHeap<T> {\r\n    const heap = isMin \r\n      ? new MinHeap<T>(this.comparator)\r\n      : new MaxHeap<T>(this.comparator);\r\n      \r\n    for (let i = 0; i < this.size; i++) {\r\n      if (this.data[i] !== undefined) {\r\n        if (this.data[i] !== undefined) {\r\n          heap.push(this.data[i] as T);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return heap;\r\n  }\r\n\r\n  /**\r\n   * Sorts the array in-place\r\n   */\r\n  public sort(ascending: boolean = true): void {\r\n    const heap = this.toHeap(!ascending);\r\n    for (let i = this.size - 1; i >= 0; i--) {\r\n      const value = heap.pop();\r\n      if (value !== undefined) {\r\n        this.data[i] = value;\r\n      }\r\n    }\r\n    this.rebuildSegmentTree();\r\n  }\r\n\r\n  /**\r\n   * Returns array as native array\r\n   */\r\n  public toArray(): T[] {\r\n    return this.data.slice(0, this.size);\r\n  }\r\n}\r\n\r\nexport default BigArray;","import { validateNonNegative, ValidationError, OverflowError } from '../utils/validation';\r\n\r\n/**\r\n * Interface for power tower computation options\r\n */\r\ninterface PowerTowerOptions {\r\n  maxHeight?: number;\r\n  maxValue?: bigint;\r\n  checkOverflow?: boolean;\r\n  precision?: number;\r\n}\r\n\r\n/**\r\n * Interface for power tower node to track computation state\r\n */\r\ninterface PowerTowerNode {\r\n  value: bigint;\r\n  height: number;\r\n  evaluated: boolean;\r\n  previous: PowerTowerNode | null;\r\n  next: PowerTowerNode | null;\r\n}\r\n\r\n/**\r\n * Default options for power tower computations\r\n */\r\nconst DEFAULT_OPTIONS: Required<PowerTowerOptions> = {\r\n  maxHeight: 100,\r\n  maxValue: BigInt(Number.MAX_SAFE_INTEGER),\r\n  checkOverflow: true,\r\n  precision: 0\r\n};\r\n\r\n/**\r\n * Class representing a power tower (tetration) computation structure\r\n * Handles expressions of the form: a↑↑b = a^(a^(a^...)) (b times)\r\n */\r\nexport class PowerTower {\r\n  private readonly options: Required<PowerTowerOptions>;\r\n  private head: PowerTowerNode | null;\r\n  private tail: PowerTowerNode | null;\r\n  private size: number;\r\n\r\n  constructor(options: PowerTowerOptions = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  /**\r\n   * Creates a new power tower node\r\n   */\r\n  private createNode(value: bigint, height: number): PowerTowerNode {\r\n    return {\r\n      value,\r\n      height,\r\n      evaluated: false,\r\n      previous: null,\r\n      next: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates power tower height\r\n   */\r\n  private validateHeight(height: number): void {\r\n    if (height < 0) {\r\n      throw new ValidationError('Height cannot be negative');\r\n    }\r\n    if (height > this.options.maxHeight) {\r\n      throw new ValidationError(`Height exceeds maximum of ${this.options.maxHeight}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates value for computation\r\n   */\r\n  private validateValue(value: bigint): void {\r\n    validateNonNegative(value);\r\n    if (this.options.checkOverflow && value > this.options.maxValue) {\r\n      throw new OverflowError(`Value exceeds maximum of ${this.options.maxValue}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes power with overflow checking\r\n   */\r\n  private computePower(base: bigint, exponent: bigint): bigint {\r\n    if (exponent === BigInt(0)) {\r\n      return BigInt(1);\r\n    }\r\n    if (exponent === BigInt(1)) {\r\n      return base;\r\n    }\r\n\r\n    let result = base;\r\n    for (let i = BigInt(1); i < exponent; i++) {\r\n      if (this.options.checkOverflow) {\r\n        // Check if next multiplication would overflow\r\n        const next = result * base;\r\n        if (next > this.options.maxValue) {\r\n          throw new OverflowError('Power computation would overflow');\r\n        }\r\n        result = next;\r\n      } else {\r\n        result *= base;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Builds a power tower of specified height with given base\r\n   */\r\n  public build(base: bigint | number | string, height: number): void {\r\n    this.validateHeight(height);\r\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\r\n    this.validateValue(baseValue);\r\n\r\n    this.clear(); // Clear existing tower\r\n\r\n    for (let i = 0; i < height; i++) {\r\n      const node = this.createNode(baseValue, i + 1);\r\n      if (!this.head) {\r\n        this.head = node;\r\n        this.tail = node;\r\n      } else {\r\n        node.previous = this.tail;\r\n        this.tail!.next = node;\r\n        this.tail = node;\r\n      }\r\n      this.size++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluates the power tower up to specified height\r\n   */\r\n  public evaluate(height?: number): bigint {\r\n    if (!this.head) {\r\n      return BigInt(1); // Empty tower evaluates to 1\r\n    }\r\n\r\n    const targetHeight = height ?? this.size;\r\n    this.validateHeight(targetHeight);\r\n\r\n    let current = this.head;\r\n    let result = current.value;\r\n    let currentHeight = 1;\r\n\r\n    try {\r\n      while (current.next && currentHeight < targetHeight) {\r\n        result = this.computePower(current.next.value, result);\r\n        current.evaluated = true;\r\n        current = current.next;\r\n        currentHeight++;\r\n      }\r\n      current.evaluated = true;\r\n      return result;\r\n    } catch (error) {\r\n      if (error instanceof OverflowError) {\r\n        // Mark nodes up to current height as evaluated\r\n        let node = this.head;\r\n        while (node !== current) {\r\n          node.evaluated = true;\r\n          node = node.next!;\r\n        }\r\n        throw error;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current height of the power tower\r\n   */\r\n  public getHeight(): number {\r\n    return this.size;\r\n  }\r\n\r\n  /**\r\n   * Checks if the tower can be evaluated to a given height\r\n   */\r\n  public isComputable(height?: number): boolean {\r\n    try {\r\n      const targetHeight = height ?? this.size;\r\n      this.validateHeight(targetHeight);\r\n      \r\n      // Check first few levels without full computation\r\n      let current = this.head;\r\n      let currentHeight = 0;\r\n      \r\n      while (current && currentHeight < targetHeight) {\r\n        // Quick check for obvious overflow conditions\r\n        if (current.value > BigInt(4) && currentHeight > 3) {\r\n          return false;\r\n        }\r\n        current = current.next;\r\n        currentHeight++;\r\n      }\r\n      \r\n      // Try actual computation with a lower overflow threshold\r\n      const safeOptions = { ...this.options, maxValue: this.options.maxValue >> BigInt(1) };\r\n      const safeTower = new PowerTower(safeOptions);\r\n      safeTower.build(this.head!.value, targetHeight);\r\n      safeTower.evaluate();\r\n      \r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the computation state at each level\r\n   */\r\n  public getState(): { height: number; value: bigint; evaluated: boolean }[] {\r\n    const state = [];\r\n    let current = this.head;\r\n    \r\n    while (current) {\r\n      state.push({\r\n        height: current.height,\r\n        value: current.value,\r\n        evaluated: current.evaluated\r\n      });\r\n      current = current.next;\r\n    }\r\n    \r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * Clears the power tower\r\n   */\r\n  public clear(): void {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  /**\r\n   * Gets the maximum computationally feasible height for a given base\r\n   */\r\n  public static getMaxFeasibleHeight(base: bigint | number | string): number {\r\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\r\n    validateNonNegative(baseValue);\r\n\r\n    if (baseValue === BigInt(0)) return 0;\r\n    if (baseValue === BigInt(1)) return Infinity;\r\n    if (baseValue === BigInt(2)) return 4; // 2↑↑4 is already enormous\r\n    if (baseValue === BigInt(3)) return 3; // 3↑↑3 is already astronomical\r\n    if (baseValue === BigInt(4)) return 2;\r\n    return 1; // For bases > 4, only height 1 is reliably computable\r\n  }\r\n\r\n  /**\r\n   * Creates a string representation of the power tower\r\n   */\r\n  public toString(): string {\r\n    if (!this.head) {\r\n      return \"Empty Tower\";\r\n    }\r\n\r\n    let result = this.head.value.toString();\r\n    let current = this.head;\r\n    \r\n    while (current.next) {\r\n      result = `${current.next.value}^(${result})`;\r\n      current = current.next;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PowerTower;","/**\r\n * Formatting utilities for Hypernum library\r\n * Provides functions for formatting large numbers and converting between different representations\r\n */\r\n\r\nimport { ValidationError } from './validation';\r\n\r\n// Types for formatting options\r\nexport interface FormatOptions {\r\n  notation?: 'standard' | 'scientific' | 'engineering' | 'compact';\r\n  precision?: number;\r\n  grouping?: boolean;\r\n  groupSize?: number;\r\n  decimalSeparator?: string;\r\n  groupSeparator?: string;\r\n}\r\n\r\nexport interface ScientificNotation {\r\n  coefficient: string;\r\n  exponent: number;\r\n}\r\n\r\nexport interface ScientificNotation {\r\n  coefficient: string;\r\n  exponent: number;\r\n}\r\n\r\n// Default formatting options\r\nconst DEFAULT_OPTIONS: Required<FormatOptions> = {\r\n  notation: 'standard',\r\n  precision: 0,\r\n  grouping: true,\r\n  groupSize: 3,\r\n  decimalSeparator: '.',\r\n  groupSeparator: ',',\r\n};\r\n\r\n/**\r\n * Formats a BigInt value according to specified options\r\n */\r\nexport const formatBigInt = (value: bigint, options: FormatOptions = {}): string => {\r\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\r\n  \r\n  // Handle negative numbers\r\n  const isNegative = value < BigInt(0);\r\n  const absValue = isNegative ? -value : value;\r\n  \r\n  let result: string;\r\n  switch (opts.notation) {\r\n    case 'scientific':\r\n      result = formatScientific(absValue, opts).coefficient + 'e' + \r\n               formatScientific(absValue, opts).exponent;\r\n      break;\r\n    case 'engineering':\r\n      result = formatEngineering(absValue, opts);\r\n      break;\r\n    case 'compact':\r\n      result = formatCompact(absValue, opts);\r\n      break;\r\n    default:\r\n      result = formatStandard(absValue, opts);\r\n  }\r\n  \r\n  return isNegative ? '-' + result : result;\r\n};\r\n\r\n/**\r\n * Formats a number in standard notation with grouping\r\n */\r\nconst formatStandard = (value: bigint, options: Required<FormatOptions>): string => {\r\n  let str = value.toString();\r\n  \r\n  if (!options.grouping) {\r\n    return str;\r\n  }\r\n  \r\n  // Apply grouping from the right\r\n  const result: string[] = [];\r\n  let position = str.length;\r\n  \r\n  while (position > 0) {\r\n    const start = Math.max(0, position - options.groupSize);\r\n    result.unshift(str.slice(start, position));\r\n    position = start;\r\n  }\r\n  \r\n  return result.join(options.groupSeparator);\r\n};\r\n\r\n/**\r\n * Converts a number to scientific notation\r\n */\r\nconst formatScientific = (value: bigint, options: Required<FormatOptions>): ScientificNotation => {\r\n  if (value === BigInt(0)) {\r\n    return { coefficient: '0', exponent: 0 };\r\n  }\r\n  \r\n  const str = value.toString();\r\n  const exponent = str.length - 1;\r\n  \r\n  let coefficient = str[0] || '';\r\n  coefficient += options.decimalSeparator + str.slice(1, options.precision + 1);\r\n  \r\n  return {\r\n    coefficient: coefficient,\r\n    exponent: exponent,\r\n  };\r\n};\r\n\r\n/**\r\n * Formats a number in engineering notation (exponents divisible by 3)\r\n */\r\nconst formatEngineering = (value: bigint, options: Required<FormatOptions>): string => {\r\n  if (value === BigInt(0)) {\r\n    return '0';\r\n  }\r\n  \r\n  const str = value.toString();\r\n  const len = str.length;\r\n  const exponent = Math.floor((len - 1) / 3) * 3;\r\n  \r\n  let coefficient = '';\r\n  const digitsBeforePoint = len - exponent;\r\n  \r\n  for (let i = 0; i < Math.min(len, digitsBeforePoint + options.precision); i++) {\r\n    if (i === digitsBeforePoint && i < len) {\r\n      coefficient += options.decimalSeparator;\r\n    }\r\n    coefficient += str[i];\r\n  }\r\n  \r\n  return `${coefficient}e${exponent}`;\r\n};\r\n\r\n/**\r\n * Formats a number in compact notation (K, M, B, T)\r\n */\r\nconst formatCompact = (value: bigint, options: Required<FormatOptions>): string => {\r\n  const suffixes = ['', 'K', 'M', 'B', 'T', 'Q'];\r\n  const str = value.toString();\r\n  const len = str.length;\r\n  \r\n  if (len <= 3) {\r\n    return formatStandard(value, options);\r\n  }\r\n  \r\n  const suffixIndex = Math.min(Math.floor((len - 1) / 3), suffixes.length - 1);\r\n  const suffix = suffixes[suffixIndex];\r\n  \r\n  const scale = BigInt(10) ** BigInt(suffixIndex * 3);\r\n  const scaledValue = value / scale;\r\n  \r\n  let result = scaledValue.toString();\r\n  if (options.precision > 0) {\r\n    const remainder = value % scale;\r\n    if (remainder > BigInt(0)) {\r\n      const decimalPart = remainder.toString().padStart(3, '0').slice(0, options.precision);\r\n      result += options.decimalSeparator + decimalPart;\r\n    }\r\n  }\r\n  \r\n  return result + suffix;\r\n};\r\n\r\n/**\r\n * Parses a formatted string back to BigInt\r\n */\r\nexport const parseBigIntString = (str: string, options: FormatOptions = {}): bigint => {\r\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\r\n  \r\n  // Remove grouping separators\r\n  let cleanStr = str.replace(new RegExp(`\\\\${opts.groupSeparator}`, 'g'), '');\r\n  \r\n  // Handle scientific notation\r\n  if (cleanStr.toLowerCase().includes('e')) {\r\n    const [coefficient, exponent] = cleanStr.toLowerCase().split('e');\r\n    const base = BigInt(10);\r\n    const exp = BigInt(exponent || '0');\r\n    return BigInt(Math.floor(Number(coefficient))) * (base ** exp);\r\n  }\r\n  \r\n  // Handle suffixes\r\n  const suffixMap = new Map([\r\n    ['k', BigInt(1000)],\r\n    ['m', BigInt(1000000)],\r\n    ['b', BigInt(1000000000)],\r\n    ['t', BigInt(1000000000000)],\r\n    ['q', BigInt(1000000000000000)],\r\n  ]);\r\n  \r\n  const suffix = cleanStr.slice(-1).toLowerCase();\r\n  const multiplier = suffixMap.get(suffix);\r\n  if (multiplier) {\r\n    cleanStr = cleanStr.slice(0, -1);\r\n    const value = BigInt(Math.floor(Number(cleanStr)));\r\n    return value * multiplier;\r\n  }\r\n  \r\n  // Handle regular numbers\r\n  return BigInt(cleanStr);\r\n};\r\n\r\n/**\r\n * Normalizes a string representation for comparison\r\n */\r\nexport const normalizeNumberString = (str: string): string => {\r\n  // Remove all spaces and separators\r\n  str = str.replace(/[\\s,]/g, '');\r\n  \r\n  // Handle scientific notation\r\n  if (str.toLowerCase().includes('e')) {\r\n    const [coefficient, exponent] = str.toLowerCase().split('e');\r\n    const exp = parseInt(exponent || '0');\r\n    const coef = parseFloat(coefficient || '0');\r\n    return (coef * Math.pow(10, exp)).toString();\r\n  }\r\n  \r\n  return str;\r\n};\r\n\r\n/**\r\n * Formats a number for display in a tree structure\r\n */\r\nexport const formatTreeValue = (value: bigint, depth: number = 0): string => {\r\n  const indent = '  '.repeat(depth);\r\n  return `${indent}${formatBigInt(value, { notation: 'compact' })}`;\r\n};\r\n\r\n/**\r\n * Formats a range of numbers for display\r\n */\r\nexport const formatRange = (start: bigint, end: bigint, options: FormatOptions = {}): string => {\r\n  return `[${formatBigInt(start, options)} ... ${formatBigInt(end, options)}]`;\r\n};\r\n\r\n/**\r\n * Formats a percentage\r\n */\r\nexport const formatPercentage = (value: bigint, total: bigint, precision: number = 2): string => {\r\n  if (total === BigInt(0)) {\r\n    throw new ValidationError('Cannot calculate percentage with zero total');\r\n  }\r\n  \r\n  const percentage = (Number(value) * 100) / Number(total);\r\n  return `${percentage.toFixed(precision)}%`;\r\n};","/**\r\n * Comparison operations module for Hypernum library\r\n * Provides functions for comparing large numbers with precision support\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    normalizePrecision,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for comparison operations\r\n   */\r\n  export interface ComparisonOptions {\r\n    precision?: number;\r\n    roundingMode?: RoundingMode;\r\n    tolerance?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ComparisonOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    tolerance: 0\r\n  };\r\n  \r\n  /**\r\n   * Result type for comparison operations\r\n   * -1: first value is less than second value\r\n   *  0: values are equal\r\n   *  1: first value is greater than second value\r\n   */\r\n  export type ComparisonResult = -1 | 0 | 1;\r\n  \r\n  /**\r\n   * Compares two numbers with optional precision\r\n   */\r\n  export function compare(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): ComparisonResult {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.precision === 0 && opts.tolerance === 0) {\r\n      if (bigA < bigB) return -1;\r\n      if (bigA > bigB) return 1;\r\n      return 0;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    \r\n    if (opts.tolerance > 0) {\r\n      const diff = scaledA - scaledB;\r\n      const toleranceValue = BigInt(10) ** BigInt(opts.tolerance);\r\n      \r\n      if (diff < -toleranceValue) return -1;\r\n      if (diff > toleranceValue) return 1;\r\n      return 0;\r\n    }\r\n  \r\n    if (scaledA < scaledB) return -1;\r\n    if (scaledA > scaledB) return 1;\r\n    return 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if two numbers are equal\r\n   */\r\n  export function equals(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is less than second\r\n   */\r\n  export function lessThan(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === -1;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is less than or equal to second\r\n   */\r\n  export function lessThanOrEqual(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    const result = compare(a, b, options);\r\n    return result === -1 || result === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is greater than second\r\n   */\r\n  export function greaterThan(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === 1;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is greater than or equal to second\r\n   */\r\n  export function greaterThanOrEqual(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    const result = compare(a, b, options);\r\n    return result === 1 || result === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if a number is between two others (inclusive)\r\n   */\r\n  export function between(\r\n    value: bigint | string | number,\r\n    min: bigint | string | number,\r\n    max: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return greaterThanOrEqual(value, min, options) && lessThanOrEqual(value, max, options);\r\n  }\r\n  \r\n  /**\r\n   * Finds the maximum value in an array of numbers\r\n   */\r\n  export function max(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    if (values.length === 0) {\r\n      throw new ValidationError('Cannot find maximum of empty array');\r\n    }\r\n  \r\n    return values.reduce<bigint>((max, current) => {\r\n      const bigMax = toBigInt(max);\r\n      const bigCurrent = toBigInt(current);\r\n      return greaterThan(bigCurrent, bigMax, options) ? bigCurrent : bigMax;\r\n    }, toBigInt(values[0]));\r\n  }\r\n  \r\n  /**\r\n   * Finds the minimum value in an array of numbers\r\n   */\r\n  export function min(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    if (values.length === 0) {\r\n      throw new ValidationError('Cannot find minimum of empty array');\r\n    }\r\n  \r\n    return values.reduce<bigint>((min, current) => {\r\n      const bigMin = toBigInt(min);\r\n      const bigCurrent = toBigInt(current);\r\n      return lessThan(bigCurrent, bigMin, options) ? bigCurrent : bigMin;\r\n    }, toBigInt(values[0]));\r\n  }\r\n  \r\n  /**\r\n   * Clamps a value between minimum and maximum bounds\r\n   */\r\n  export function clamp(\r\n    value: bigint | string | number,\r\n    min: bigint | string | number,\r\n    max: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    const bigValue = toBigInt(value);\r\n    const bigMin = toBigInt(min);\r\n    const bigMax = toBigInt(max);\r\n  \r\n    if (lessThan(bigMax, bigMin, options)) {\r\n      throw new ValidationError('Maximum bound must be greater than or equal to minimum bound');\r\n    }\r\n  \r\n    if (lessThan(bigValue, bigMin, options)) return bigMin;\r\n    if (greaterThan(bigValue, bigMax, options)) return bigMax;\r\n    return bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Checks if all values in array are equal within tolerance\r\n   */\r\n  export function allEqual(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    const first = toBigInt(values[0]);\r\n    return values.every(value => equals(value, first, options));\r\n  }\r\n  \r\n  /**\r\n   * Checks if values are in ascending order\r\n   */\r\n  export function isAscending(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    for (let i = 1; i < values.length; i++) {\r\n      if (values[i] === undefined || values[i - 1] === undefined || !greaterThanOrEqual(values[i]!, values[i - 1]!, options)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Checks if values are in descending order\r\n   */\r\n  export function isDescending(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    for (let i = 1; i < values.length; i++) {\r\n      if (values[i] === undefined || values[i - 1] === undefined || !lessThanOrEqual(values[i]!, values[i - 1]!, options)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Creates a comparator function for sorting\r\n   */\r\n  export function createComparator(\r\n    options: ComparisonOptions = {}\r\n  ): (a: bigint | string | number, b: bigint | string | number) => number {\r\n    return (a, b) => compare(a, b, options);\r\n  }\r\n  \r\n  export default {\r\n    compare,\r\n    equals,\r\n    lessThan,\r\n    lessThanOrEqual,\r\n    greaterThan,\r\n    greaterThanOrEqual,\r\n    between,\r\n    max,\r\n    min,\r\n    clamp,\r\n    allEqual,\r\n    isAscending,\r\n    isDescending,\r\n    createComparator\r\n  };","/**\r\n * Conversion operations module for Hypernum library\r\n * Provides functions for converting numbers between different formats and bases\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for conversion operations\r\n   */\r\n  export interface ConversionOptions {\r\n    /** Precision for decimal operations */\r\n    precision?: number;\r\n    /** Rounding mode for decimal operations */\r\n    roundingMode?: RoundingMode;\r\n    /** Whether to use uppercase for hex/base-N output */\r\n    uppercase?: boolean;\r\n    /** Whether to add prefix for base-N output (0x, 0b, etc.) */\r\n    prefix?: boolean;\r\n    /** Minimum number of digits (pad with zeros) */\r\n    minDigits?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ConversionOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    uppercase: false,\r\n    prefix: false,\r\n    minDigits: 1\r\n  };\r\n  \r\n  /**\r\n   * Converts number to binary string representation\r\n   */\r\n  export function toBinary(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let binary = bigValue.toString(2);\r\n    \r\n    // Pad with zeros if needed\r\n    while (binary.length < opts.minDigits) {\r\n      binary = '0' + binary;\r\n    }\r\n    \r\n    return opts.prefix ? '0b' + binary : binary;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to octal string representation\r\n   */\r\n  export function toOctal(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let octal = bigValue.toString(8);\r\n    \r\n    while (octal.length < opts.minDigits) {\r\n      octal = '0' + octal;\r\n    }\r\n    \r\n    return opts.prefix ? '0o' + octal : octal;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to hexadecimal string representation\r\n   */\r\n  export function toHexadecimal(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let hex = bigValue.toString(16);\r\n    \r\n    if (opts.uppercase) {\r\n      hex = hex.toUpperCase();\r\n    }\r\n    \r\n    while (hex.length < opts.minDigits) {\r\n      hex = '0' + hex;\r\n    }\r\n    \r\n    return opts.prefix ? '0x' + hex : hex;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to string in specified base\r\n   */\r\n  export function toBase(\r\n    value: bigint | string | number,\r\n    base: number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    if (base < 2 || base > 36) {\r\n      throw new ValidationError('Base must be between 2 and 36');\r\n    }\r\n    \r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let result = bigValue.toString(base);\r\n    \r\n    if (opts.uppercase) {\r\n      result = result.toUpperCase();\r\n    }\r\n    \r\n    while (result.length < opts.minDigits) {\r\n      result = '0' + result;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Converts string from specified base to bigint\r\n   */\r\n  export function fromBase(\r\n    value: string,\r\n    base: number\r\n  ): bigint {\r\n    if (base < 2 || base > 36) {\r\n      throw new ValidationError('Base must be between 2 and 36');\r\n    }\r\n    \r\n    // Remove base prefixes if present\r\n    const cleanValue = value.toLowerCase()\r\n      .replace(/^0x/, '')  // hex\r\n      .replace(/^0b/, '')  // binary\r\n      .replace(/^0o/, ''); // octal\r\n    \r\n    try {\r\n      return BigInt(`${base}n${cleanValue}`);\r\n    } catch (error) {\r\n      throw new ValidationError(`Invalid number format for base ${base}: ${value}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Converts decimal string to fraction representation\r\n   */\r\n  export function toFraction(\r\n    value: string,\r\n  ): [bigint, bigint] {\r\n    \r\n    // Split into integer and decimal parts\r\n    const [intPart, decPart = ''] = value.split('.');\r\n    \r\n    if (!decPart) {\r\n      return [toBigInt(intPart), 1n];\r\n    }\r\n    \r\n    // Convert decimal to fraction\r\n    const numerator = toBigInt(intPart + decPart);\r\n    const denominator = 10n ** BigInt(decPart.length);\r\n    \r\n    // Simplify fraction\r\n    const gcd = calculateGCD(numerator, denominator);\r\n    \r\n    return [numerator / gcd, denominator / gcd];\r\n  }\r\n  \r\n  /**\r\n   * Converts fraction to decimal string with specified precision\r\n   */\r\n  export function fromFraction(\r\n    numerator: bigint | string | number,\r\n    denominator: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigNumerator = toBigInt(numerator);\r\n    const bigDenominator = toBigInt(denominator);\r\n    \r\n    if (bigDenominator === 0n) {\r\n      throw new ValidationError('Denominator cannot be zero');\r\n    }\r\n    \r\n    const quotient = bigNumerator / bigDenominator;\r\n    const remainder = bigNumerator % bigDenominator;\r\n    \r\n    if (remainder === 0n || opts.precision === 0) {\r\n      return quotient.toString();\r\n    }\r\n    \r\n    // Calculate decimal part\r\n    const scaleFactor = 10n ** BigInt(opts.precision);\r\n    const scaledRemainder = (remainder * scaleFactor) / bigDenominator;\r\n    \r\n    return `${quotient}.${scaledRemainder.toString().padStart(opts.precision, '0')}`;\r\n  }\r\n  \r\n  /**\r\n   * Converts scientific notation to decimal string\r\n   */\r\n  export function fromScientific(\r\n    value: string,\r\n  ): string {\r\n    \r\n    // Parse scientific notation format\r\n    const match = value.match(/^(-?\\d+\\.?\\d*)[eE]([+-]?\\d+)$/);\r\n    if (!match) {\r\n      throw new ValidationError('Invalid scientific notation format');\r\n    }\r\n    \r\n    const [, significand, exponent] = match;\r\n    const exp = parseInt(exponent || '0', 10);\r\n    \r\n    // Convert to regular decimal\r\n    if (exp >= 0) {\r\n      if (significand === undefined) {\r\n        throw new ValidationError('Invalid scientific notation format');\r\n      }\r\n      return (BigInt(significand.replace('.', '')) * (10n ** BigInt(exp))).toString();\r\n    } else {\r\n      const absExp = Math.abs(exp);\r\n      if (significand === undefined) {\r\n        throw new ValidationError('Invalid scientific notation format');\r\n      }\r\n      const scaledValue = BigInt(significand.replace('.', ''));\r\n      return (scaledValue / (10n ** BigInt(absExp))).toString();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Converts decimal to scientific notation\r\n   */\r\n  export function toScientific(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return '0e0';\r\n    }\r\n    \r\n    const str = bigValue.toString();\r\n    const firstDigit = str[0] === '-' ? str[1] : str[0];\r\n    const exponent = str.length - (str[0] === '-' ? 2 : 1);\r\n    \r\n    let result = firstDigit;\r\n    if (str.length > 1) {\r\n      const restDigits = str.slice(str[0] === '-' ? 2 : 1);\r\n      if (opts.precision > 0) {\r\n        result += '.' + restDigits.slice(0, opts.precision);\r\n      }\r\n    }\r\n    \r\n    if (str[0] === '-') {\r\n      result = '-' + result;\r\n    }\r\n    \r\n    return `${result}e${exponent}`;\r\n  }\r\n  \r\n  /**\r\n   * Calculates Greatest Common Divisor (helper function)\r\n   */\r\n  function calculateGCD(a: bigint, b: bigint): bigint {\r\n    a = a < 0n ? -a : a;\r\n    b = b < 0n ? -b : b;\r\n    \r\n    while (b !== 0n) {\r\n      const temp = b;\r\n      b = a % b;\r\n      a = temp;\r\n    }\r\n    \r\n    return a;\r\n  }\r\n  \r\n\r\n  /**\r\n * Converts Roman numeral to number\r\n */\r\nexport function fromRoman(value: string): bigint {\r\n    const romanValues = new Map<string, number>([\r\n      ['I', 1],\r\n      ['V', 5],\r\n      ['X', 10],\r\n      ['L', 50],\r\n      ['C', 100],\r\n      ['D', 500],\r\n      ['M', 1000]\r\n    ]);\r\n  \r\n    let result = 0;\r\n    let prevValue = 0;\r\n  \r\n    // Process from right to left\r\n    for (let i = value.length - 1; i >= 0; i--) {\r\n      const char = value[i]?.toUpperCase() ?? '';\r\n      const current = romanValues.get(char);\r\n  \r\n      if (current === undefined) {\r\n        throw new ValidationError(`Invalid Roman numeral character: ${char}`);\r\n      }\r\n  \r\n      if (current >= prevValue) {\r\n        result += current;\r\n      } else {\r\n        result -= current;\r\n      }\r\n  \r\n      prevValue = current;\r\n    }\r\n  \r\n    return BigInt(result);\r\n  }\r\n  \r\n  /**\r\n   * Converts number to Roman numeral\r\n   */\r\n  export function toRoman(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const num = Number(toBigInt(value));\r\n  \r\n    if (num <= 0 || num > 3999) {\r\n      throw new ValidationError('Number must be between 1 and 3999 for Roman numerals');\r\n    }\r\n  \r\n    // Define symbol pairs with proper typing\r\n    type RomanPair = [string, string];\r\n    type RomanSingle = [string];\r\n    type RomanSymbol = RomanPair | RomanSingle;\r\n  \r\n    const romanSymbols: RomanSymbol[] = [\r\n      ['I', 'V'], // ones\r\n      ['X', 'L'], // tens\r\n      ['C', 'D'], // hundreds\r\n      ['M']       // thousands\r\n    ];\r\n  \r\n    let result = '';\r\n    let position = 0;\r\n    let remaining = num;\r\n  \r\n    while (remaining > 0) {\r\n      const digit = remaining % 10;\r\n      const symbols = romanSymbols[position];\r\n  \r\n      if (!symbols) {\r\n        break; // Safety check for position overflow\r\n      }\r\n  \r\n      const unit = symbols[0];\r\n      const five = symbols[1] ?? '';\r\n      const next = position < 3 ? romanSymbols[position + 1]?.[0] ?? '' : '';\r\n  \r\n      let digitStr = '';\r\n      if (digit === 9 && next) {\r\n        digitStr = unit + next;\r\n      } else if (digit >= 5 && five) {\r\n        digitStr = five + unit.repeat(digit - 5);\r\n      } else if (digit === 4 && five) {\r\n        digitStr = unit + five;\r\n      } else {\r\n        digitStr = unit.repeat(digit);\r\n      }\r\n  \r\n      result = digitStr + result;\r\n      remaining = Math.floor(remaining / 10);\r\n      position++;\r\n    }\r\n  \r\n    return opts.uppercase ? result : result.toLowerCase();\r\n  }\r\n  export default {\r\n    toBinary,\r\n    toOctal,\r\n    toHexadecimal,\r\n    toBase,\r\n    fromBase,\r\n    toFraction,\r\n    fromFraction,\r\n    fromScientific,\r\n    toScientific,\r\n    fromRoman,\r\n    toRoman\r\n  };","/**\r\n * Hypernum - A TypeScript/JavaScript library for large number operations\r\n * Provides comprehensive tools for handling large numbers and complex mathematical operations\r\n */\r\n\r\nimport { HypernumConfig, mergeConfig, validateConfig } from './core';\r\nimport { power } from './operations';\r\nimport arithmetic from './operations/arithmetic';\r\nimport bitwise from './operations/bitwise';\r\nimport { MinHeap, MaxHeap } from './storage/Heap';\r\nimport { AckermannStructure, BigArray, NumberTree, PowerTower } from './structures';\r\n\r\n// Core functionality\r\nexport * from './core/constants';\r\nexport * from './core/errors';\r\n\r\n// Data structures\r\nexport { AckermannStructure } from './structures/Ackermann';\r\nexport { BigArray } from './structures/BigArray';\r\nexport { NumberTree } from './structures/NumberTree';\r\nexport { MinHeap, MaxHeap,  } from './storage/index';\r\nexport type {Comparator} from './storage/index';\r\nexport { PowerTower } from './structures/PowerTower';\r\n\r\n// Operations\r\nexport { default as arithmetic } from './operations/arithmetic';\r\nexport { default as bitwise } from './operations/bitwise';\r\nexport { default as power } from './operations/power';\r\n\r\n// Utility functions\r\nexport {\r\n  toBigInt,\r\n  validateNonNegative,\r\n  validatePositive,\r\n  checkAdditionOverflow,\r\n  checkMultiplicationOverflow,\r\n  checkPowerOverflow,\r\n  ValidationError,\r\n  OverflowError\r\n} from './utils/validation';\r\n\r\nexport {\r\n  formatBigInt,\r\n  parseBigIntString,\r\n  normalizeNumberString,\r\n  formatTreeValue,\r\n  formatRange,\r\n  formatPercentage\r\n} from './utils/formatting';\r\n\r\nexport {\r\n  RoundingMode,\r\n  round,\r\n  scaleByPowerOfTen,\r\n  scaledDivision,\r\n  normalizePrecision,\r\n  calculateRequiredPrecision,\r\n  equalWithinPrecision\r\n} from './utils/precision';\r\n\r\n// Configuration types\r\nexport type {\r\n  HypernumConfig,\r\n  BasicConfig,\r\n  FullConfig,\r\n  ArithmeticConfig,\r\n  DataStructuresConfig,\r\n  FormattingConfig,\r\n  PerformanceConfig,\r\n  FeatureFlags\r\n} from './types/core';\r\n\r\nexport type {\r\n  DEFAULT_BASIC_CONFIG,\r\n  DEFAULT_FULL_CONFIG,\r\n  validateConfig,\r\n  mergeConfig,\r\n  isFullConfig,\r\n  isBasicConfig\r\n} from './types/common';\r\n\r\n// Common types\r\nexport type {\r\n  NumericInput,\r\n  Result,\r\n  BaseOptions,\r\n  FormatOptions,\r\n  CacheConfig,\r\n  MathConstantsConfig,\r\n  DebugConfig,\r\n  NumericRange,\r\n  OperationStatus,\r\n  PerformanceMetrics,\r\n  NodeStats,\r\n  OperationOptions\r\n} from './types/common';\r\n\r\n/**\r\n * Library version\r\n */\r\nexport const VERSION = '0.1.0';\r\n\r\n/**\r\n * Creates a new Hypernum instance with custom configuration\r\n */\r\nexport function createHypernum(config?: Partial<HypernumConfig>) {\r\n  const finalConfig = mergeConfig(config || {});\r\n  validateConfig(finalConfig);\r\n  \r\n  return {\r\n    config: finalConfig,\r\n    arithmetic,\r\n    bitwise,\r\n    power,\r\n    AckermannStructure,\r\n    BigArray,\r\n    NumberTree,\r\n    MinHeap,\r\n    MaxHeap,\r\n    PowerTower\r\n  };\r\n}\r\n\r\n/**\r\n * Default instance with basic configuration\r\n */\r\nexport default createHypernum();"],"names":["Error","constructor","message","super","this","name","toBigInt","value","isBigInt","test","isValidNumberString","ValidationError","BigInt","isNaN","isFinite","isValidNumber","Number","isInteger","checkAdditionOverflow","a","b","MAX_SAFE_INTEGER","OverflowError","MIN_SAFE_INTEGER","checkMultiplicationOverflow","maxValue","minValue","checkPowerOverflow","base","exponent","validateNonNegative","RoundingMode","scaleByPowerOfTen","power","round","precision","mode","HALF_EVEN","scale","scaled","remainder","FLOOR","CEIL","DOWN","UP","HALF_UP","HALF_DOWN","normalizePrecision","precisionA","precisionB","targetPrecision","Math","max","scaledDivision","numerator","denominator","roundingMode","scaledNumerator","DEFAULT_BASIC_CONFIG","checkOverflow","maxSteps","debug","DEFAULT_FULL_CONFIG","arithmetic","defaultPrecision","defaultRoundingMode","maxComputationSteps","autoPrecision","enabled","maxPrecision","minPrecision","constants","cache","algorithm","dataStructures","array","initialCapacity","growthFactor","maxSize","tree","maxDepth","autoBalance","nodeLimit","heap","growthPolicy","validatePropertyOnOperation","ttl","evictionPolicy","persistToDisk","compressionEnabled","formatting","notation","grouping","groupSize","decimalSeparator","groupSeparator","uppercase","scientific","minExponent","maxSignificantDigits","exponentSeparator","engineering","useSIPrefixes","localization","locale","useLocaleGrouping","performance","enableTracking","samplingRate","thresholds","warnThresholdMs","errorThresholdMs","maxMemoryBytes","metrics","timing","memory","verbose","trackPerformance","logLevel","features","experimentalFeatures","useWasm","workerThreads","sharedArrayBuffer","bigIntTypedArrays","isFullConfig","config","validateConfig","validateFullConfig","undefined","validateBasicConfig","ZERO","ONE","TWO","TEN","NEGATIVE_ONE","MAX_POWER_BASE","MAX_POWER_EXPONENT","MAX_TETRATION_HEIGHT","MAX_FACTORIAL_INPUT","ERROR_MESSAGES","OVERFLOW","UNDERFLOW","NEGATIVE_ROOT","NEGATIVE_EXPONENT","DIVISION_BY_ZERO","INVALID_PRECISION","INVALID_BASE","INVALID_ROMAN","COMPUTATION_LIMIT","NEGATIVE_INDEX","TREE_DEPTH_EXCEEDED","INVALID_HEAP_PROPERTY","DEFAULT_OPTIONS","HypernumError","Object","setPrototypeOf","prototype","UnderflowError","DivisionByZeroError","PrecisionError","ComputationLimitError","DataStructureError","HeapPropertyError","TreeError","IndexError","FormatError","RomanNumeralError","isHypernumError","error","options","opts","bigBase","bigExponent","result","remaining","abs","bigValue","gcd","bigA","bigB","temp","add","scaledA","scaledB","subtract","multiply","divide","bigNumerator","bigDenominator","x","y","sign","lcm","maxBits","strict","validateShift","shift","leftShift","bigShift","unsignedRightShift","bitwise","and","or","xor","not","rightShift","rotateLeft","rotation","bigRotation","rotateRight","rightPart","popCount","count","trailingZeros","leadingZeros","msb","getBit","position","bigPosition","setBit","clearBit","toggleBit","baseValue","exponentValue","steps","sqrt","lastGuess","guess","tetration","height","bigHeight","i","power$1","nthRoot","n","bigN","nMinus1","superRoot","left","right","mid","Heap","comparator","compare","size","length","isEmpty","peek","push","siftUp","pop","root","last","siftDown","clear","heapify","MinHeap","MaxHeap","forEach","item","getParentIndex","index","floor","getLeftChildIndex","getRightChildIndex","swap","j","parentIndex","smallest","largest","AckermannStructure","nodes","Map","maxComputedM","maxComputedN","getNodeKey","m","computeAckermann","key","existing","get","inner","innerNum","RangeError","addNode","has","node","set","prevMKey","prevNKey","prevM","nextM","prevN","nextN","buildRange","mRange","nRange","getComputationPath","path","current","nextValue","safeNextValue","reverse","analyzeGrowthRate","growth","prevValue","increase","multiplier","getLargestValue","getValue","NumberNode","parent","sum","updateStats","getBalance","getStats","min","findMin","findMax","NumberTree","getRoot","insert","newValue","insertNode","find","compareResult","balance","rightChild","rightLeftChild","leftChild","leftRightChild","remove","searchValue","removeNode","successor","traverse","order","depth","skipSubtrees","getTreeStats","getNthValue","findNth","leftSize","getRange","start","end","startValue","endValue","collectRange","BigArray","capacity","data","Array","segmentTree","fill","getSize","getCapacity","resize","newCapacity","newData","rebuildSegmentTree","updateSegmentTree","success","oldValue","buildSegmentTree","leftNode","rightNode","currentNode","queryRange","querySegmentTree","queryStart","queryEnd","leftResult","rightResult","toHeap","isMin","sort","ascending","toArray","slice","maxHeight","PowerTower","head","tail","createNode","evaluated","previous","next","validateHeight","validateValue","computePower","build","evaluate","targetHeight","currentHeight","getHeight","isComputable","safeOptions","safeTower","getState","state","getMaxFeasibleHeight","Infinity","toString","formatBigInt","isNegative","absValue","formatScientific","coefficient","formatEngineering","formatCompact","formatStandard","str","unshift","join","len","digitsBeforePoint","suffixes","suffixIndex","suffix","decimalPart","padStart","createHypernum","finalConfig","custom","fullConfig","mergeConfig","OVERFLOW_CHECKING","AUTOMATIC_PRECISION","MEMOIZATION","TREE_BALANCING","DEBUG_MODE","symbol","WARN_THRESHOLD_MS","ERROR_THRESHOLD_MS","MAX_ARRAY_SIZE","MAX_TREE_SIZE","nonZeroIndex","split","findIndex","char","type","diff","tolerance","total","toFixed","repeat","replace","toLowerCase","includes","exp","parseInt","parseFloat","pow","cleanStr","RegExp","suffixMap"],"mappings":"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"}