{"version":3,"file":"index.umd.js","sources":["../src/utils/validation.ts","../src/utils/precision.ts","../src/core/config.ts","../src/core/constants.ts","../src/core/errors.ts","../src/operations/arithmetic.ts","../src/operations/bitwise.ts","../src/operations/power.ts","../src/storage/Heap.ts","../src/structures/ackermann.ts","../src/structures/big-array.ts","../src/structures/number-tree.ts","../src/structures/power-tower.ts","../src/utils/formatting.ts","../src/core/hypernum.ts","../src/operations/comparison.ts","../src/operations/conversion.ts","../src/operations/factorial.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Validation utilities for Hypernum library\r\n * Provides type checking and validation functions for large number operations\r\n */\r\n\r\n// Custom error types for validation\r\nexport class ValidationError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'ValidationError';\r\n    }\r\n  }\r\n  \r\n  export class OverflowError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'OverflowError';\r\n    }\r\n  }\r\n  \r\n  // Type guards\r\n  export const isBigInt = (value: unknown): value is bigint => {\r\n    return typeof value === 'bigint';\r\n  };\r\n  \r\n  export const isValidNumberString = (value: string): boolean => {\r\n    return /^-?\\d+$/.test(value);\r\n  };\r\n  \r\n  export const isValidNumber = (value: unknown): value is number => {\r\n    return typeof value === 'number' && !isNaN(value) && isFinite(value);\r\n  };\r\n  \r\n  // Type conversions with validation\r\n  export const toBigInt = (value: unknown): bigint => {\r\n    if (isBigInt(value)) {\r\n      return value;\r\n    }\r\n    \r\n    if (typeof value === 'string') {\r\n      if (!isValidNumberString(value)) {\r\n        throw new ValidationError(`Invalid number string: ${value}`);\r\n      }\r\n      return BigInt(value);\r\n    }\r\n    \r\n    if (isValidNumber(value)) {\r\n      if (!Number.isInteger(value)) {\r\n        throw new ValidationError('Cannot convert non-integer number to BigInt');\r\n      }\r\n      return BigInt(value);\r\n    }\r\n    \r\n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`);\r\n  };\r\n  \r\n  // Range validation\r\n  export const validateRange = (value: bigint, min?: bigint, max?: bigint): void => {\r\n    if (min !== undefined && value < min) {\r\n      throw new ValidationError(`Value ${value} is below minimum ${min}`);\r\n    }\r\n    if (max !== undefined && value > max) {\r\n      throw new ValidationError(`Value ${value} exceeds maximum ${max}`);\r\n    }\r\n  };\r\n  \r\n  // Operation safety checks\r\n  export const checkAdditionOverflow = (a: bigint, b: bigint): void => {\r\n    // Check if addition would overflow\r\n    if (b > 0 && a > BigInt(Number.MAX_SAFE_INTEGER) - b) {\r\n      throw new OverflowError('Addition would overflow');\r\n    }\r\n    if (b < 0 && a < BigInt(Number.MIN_SAFE_INTEGER) - b) {\r\n      throw new OverflowError('Addition would underflow');\r\n    }\r\n  };\r\n  \r\n  export const checkMultiplicationOverflow = (a: bigint, b: bigint): void => {\r\n    // Check if multiplication would overflow\r\n    if (a !== BigInt(0) && b !== BigInt(0)) {\r\n      const maxValue = BigInt(Number.MAX_SAFE_INTEGER);\r\n      const minValue = BigInt(Number.MIN_SAFE_INTEGER);\r\n      \r\n      if (a > maxValue / b || a < minValue / b) {\r\n        throw new OverflowError('Multiplication would overflow');\r\n      }\r\n    }\r\n  };\r\n  \r\n  export const checkPowerOverflow = (base: bigint, exponent: bigint): void => {\r\n    // Basic overflow checks for exponentiation\r\n    if (exponent < BigInt(0)) {\r\n      throw new ValidationError('Negative exponents not supported for integers');\r\n    }\r\n    \r\n    if (base === BigInt(0) && exponent === BigInt(0)) {\r\n      throw new ValidationError('Zero raised to zero is undefined');\r\n    }\r\n    \r\n    if (exponent > BigInt(1000)) {\r\n      throw new OverflowError('Exponent too large, computation would overflow');\r\n    }\r\n  };\r\n  \r\n  // Array and data structure validation\r\n  export const validateArrayLength = (length: number): void => {\r\n    if (!Number.isInteger(length) || length < 0) {\r\n      throw new ValidationError('Array length must be a non-negative integer');\r\n    }\r\n    if (length > Number.MAX_SAFE_INTEGER) {\r\n      throw new ValidationError('Array length exceeds maximum safe integer');\r\n    }\r\n  };\r\n  \r\n  export const validateArrayIndex = (index: number, length: number): void => {\r\n    if (!Number.isInteger(index)) {\r\n      throw new ValidationError('Array index must be an integer');\r\n    }\r\n    if (index < 0 || index >= length) {\r\n      throw new ValidationError('Array index out of bounds');\r\n    }\r\n  };\r\n  \r\n  // Tree validation\r\n  export const validateTreeNode = (value: unknown): void => {\r\n    try {\r\n      toBigInt(value);\r\n    } catch (error) {\r\n      throw new ValidationError('Invalid tree node value');\r\n    }\r\n  };\r\n  \r\n  // Heap validation\r\n  export const validateHeapProperty = <T>(\r\n    value: T,\r\n    parent: T | undefined,\r\n    comparator: (a: T, b: T) => -1 | 0 | 1,\r\n    isMinHeap: boolean\r\n  ): void => {\r\n    if (!parent) return;\r\n    \r\n    const comparison = comparator(value, parent);\r\n    if (isMinHeap && comparison < 0) {\r\n      throw new ValidationError('Min heap property violated');\r\n    }\r\n    if (!isMinHeap && comparison > 0) {\r\n      throw new ValidationError('Max heap property violated');\r\n    }\r\n  };\r\n  \r\n  // Ackermann function validation\r\n  export const validateAckermannInput = (m: number, n: number): void => {\r\n    if (!Number.isInteger(m) || !Number.isInteger(n)) {\r\n      throw new ValidationError('Ackermann inputs must be integers');\r\n    }\r\n    if (m < 0 || n < 0) {\r\n      throw new ValidationError('Ackermann inputs must be non-negative');\r\n    }\r\n    if (m > 4) {\r\n      throw new ValidationError('First Ackermann parameter too large for computation');\r\n    }\r\n  };\r\n  \r\n  // General numeric validation utilities\r\n  export const isInRange = (value: bigint, min: bigint, max: bigint): boolean => {\r\n    return value >= min && value <= max;\r\n  };\r\n  \r\n  export const isPowerOfTwo = (value: bigint): boolean => {\r\n    return value > BigInt(0) && (value & (value - BigInt(1))) === BigInt(0);\r\n  };\r\n  \r\n  export const validatePositive = (value: bigint): void => {\r\n    if (value <= BigInt(0)) {\r\n      throw new ValidationError('Value must be positive');\r\n    }\r\n  };\r\n  \r\n  export const validateNonNegative = (value: bigint): void => {\r\n    if (value < BigInt(0)) {\r\n      throw new ValidationError('Value must be non-negative');\r\n    }\r\n  };","/**\r\n * Precision utilities for Hypernum library\r\n * Provides functions for handling decimal precision and rounding operations\r\n */\r\n\r\nimport { ValidationError } from './validation';\r\n\r\n/**\r\n * Rounding modes for decimal operations\r\n */\r\nexport enum RoundingMode {\r\n  FLOOR = 'FLOOR',           // Round towards negative infinity\r\n  CEIL = 'CEIL',             // Round towards positive infinity\r\n  DOWN = 'DOWN',             // Round towards zero\r\n  UP = 'UP',                 // Round away from zero\r\n  HALF_EVEN = 'HALF_EVEN',   // Round to nearest even number when tied (Banker's rounding)\r\n  HALF_UP = 'HALF_UP',       // Round up when tied\r\n  HALF_DOWN = 'HALF_DOWN',   // Round down when tied\r\n}\r\n\r\n/**\r\n * Scale a bigint by a power of 10\r\n */\r\nexport const scaleByPowerOfTen = (value: bigint, power: number): bigint => {\r\n  if (power === 0) return value;\r\n  if (power > 0) {\r\n    return value * (BigInt(10) ** BigInt(power));\r\n  }\r\n  return value / (BigInt(10) ** BigInt(-power));\r\n};\r\n\r\n/**\r\n * Round a number according to specified mode and precision\r\n */\r\nexport const round = (\r\n  value: bigint,\r\n  precision: number = 0,\r\n  mode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  if (precision === 0) {\r\n    return value;\r\n  }\r\n\r\n  const scale = BigInt(10) ** BigInt(precision);\r\n  const scaled = value / scale;\r\n  const remainder = value % scale;\r\n\r\n  switch (mode) {\r\n    case RoundingMode.FLOOR:\r\n      return scaled * scale;\r\n\r\n    case RoundingMode.CEIL:\r\n      return remainder > 0n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.DOWN:\r\n      return value >= 0n ? scaled * scale : (scaled - 1n) * scale;\r\n\r\n    case RoundingMode.UP:\r\n      return value >= 0n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_UP:\r\n      return remainder >= scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_DOWN:\r\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_EVEN:\r\n      if (remainder === scale / 2n) {\r\n        return scaled % 2n === 0n ? scaled * scale : (scaled + 1n) * scale;\r\n      }\r\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    default:\r\n      throw new ValidationError('Invalid rounding mode');\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate precision required to represent a number without loss\r\n */\r\nexport const calculateRequiredPrecision = (value: bigint): number => {\r\n  if (value === 0n) return 0;\r\n  \r\n  const str = value.toString();\r\n  const nonZeroIndex = str.split('').reverse().findIndex(char => char !== '0');\r\n  return nonZeroIndex === -1 ? 0 : nonZeroIndex;\r\n};\r\n\r\n/**\r\n * Normalize two numbers to the same precision\r\n */\r\nexport const normalizePrecision = (\r\n  a: bigint,\r\n  b: bigint,\r\n  precisionA: number,\r\n  precisionB: number\r\n): [bigint, bigint] => {\r\n  const targetPrecision = Math.max(precisionA, precisionB);\r\n  \r\n  const scaledA = scaleByPowerOfTen(a, targetPrecision - precisionA);\r\n  const scaledB = scaleByPowerOfTen(b, targetPrecision - precisionB);\r\n  \r\n  return [scaledA, scaledB];\r\n};\r\n\r\n/**\r\n * Scale a division operation to achieve desired precision\r\n */\r\nexport const scaledDivision = (\r\n  numerator: bigint,\r\n  denominator: bigint,\r\n  precision: number,\r\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (denominator === 0n) {\r\n    throw new ValidationError('Division by zero');\r\n  }\r\n\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  // Scale up numerator to handle desired precision\r\n  const scaledNumerator = scaleByPowerOfTen(numerator, precision);\r\n  const quotient = scaledNumerator / denominator;\r\n  \r\n  return round(quotient, 0, roundingMode);\r\n};\r\n\r\n/**\r\n * Calculate the number of significant digits\r\n */\r\nexport const significantDigits = (value: bigint): number => {\r\n  const nonZeroPattern = /[1-9]/;\r\n  const str = value.toString();\r\n  const firstSignificant = str.search(nonZeroPattern);\r\n  if (firstSignificant === -1) return 0;\r\n  \r\n  const lastSignificant = str.split('').reverse().findIndex(char => char !== '0');\r\n  return str.length - firstSignificant - (lastSignificant === -1 ? 0 : lastSignificant);\r\n};\r\n\r\n/**\r\n * Truncate to specified number of significant digits\r\n */\r\nexport const truncateToSignificantDigits = (\r\n  value: bigint,\r\n  digits: number,\r\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (digits <= 0) {\r\n    throw new ValidationError('Number of significant digits must be positive');\r\n  }\r\n\r\n  const currentDigits = significantDigits(value);\r\n  \r\n  if (currentDigits <= digits) {\r\n    return value;\r\n  }\r\n\r\n  const scale = currentDigits - digits;\r\n  return round(value, scale, roundingMode);\r\n};\r\n\r\n/**\r\n * Check if two numbers are equal within a specified precision\r\n */\r\nexport const equalWithinPrecision = (\r\n  a: bigint,\r\n  b: bigint,\r\n  precision: number\r\n): boolean => {\r\n  const diff = a - b;\r\n  const tolerance = BigInt(10) ** BigInt(precision);\r\n  return diff.toString().length <= tolerance.toString().length;\r\n};\r\n\r\n/**\r\n * Get the fractional part of a number at a given precision\r\n */\r\nexport const getFractionalPart = (\r\n  value: bigint,\r\n  precision: number\r\n): bigint => {\r\n  if (precision <= 0) return 0n;\r\n  \r\n  const scale = BigInt(10) ** BigInt(precision);\r\n  return value % scale;\r\n};\r\n\r\n/**\r\n * Format a number with exact precision (no rounding)\r\n */\r\nexport const toExactPrecision = (value: bigint, precision: number): string => {\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  let str = value.toString();\r\n  const isNegative = str.startsWith('-');\r\n  if (isNegative) {\r\n    str = str.slice(1);\r\n  }\r\n\r\n  while (str.length <= precision) {\r\n    str = '0' + str;\r\n  }\r\n\r\n  const integerPart = str.slice(0, -precision) || '0';\r\n  const fractionalPart = str.slice(-precision);\r\n\r\n  return `${isNegative ? '-' : ''}${integerPart}.${fractionalPart}`;\r\n};","/**\r\n * Configuration type definitions for Hypernum library\r\n * Defines all configuration options and their default values\r\n */\r\n\r\nimport { RoundingMode } from '../utils/precision';\r\nimport { \r\n  FormatOptions,\r\n  DebugConfig,\r\n  CacheConfig,\r\n  MathConstantsConfig\r\n} from './common';\r\n\r\n/**\r\n * Basic configuration options for simple usage\r\n */\r\nexport interface BasicConfig {\r\n  /** Decimal precision for operations */\r\n  precision?: number;\r\n  /** Rounding mode for decimal operations */\r\n  roundingMode?: RoundingMode;\r\n  /** Whether to check for overflow */\r\n  checkOverflow?: boolean;\r\n  /** Maximum allowed computation steps */\r\n  maxSteps?: number;\r\n  /** Enable debug mode */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Configuration for arithmetic operations\r\n */\r\nexport interface ArithmeticConfig {\r\n  /** Default precision for decimal operations */\r\n  defaultPrecision: number;\r\n  /** Default rounding mode */\r\n  defaultRoundingMode: RoundingMode;\r\n  /** Whether to check for overflow by default */\r\n  checkOverflow: boolean;\r\n  /** Maximum steps for iterative calculations */\r\n  maxComputationSteps: number;\r\n  /** Configure automatic precision adjustment */\r\n  autoPrecision: {\r\n    enabled: boolean;\r\n    maxPrecision: number;\r\n    minPrecision: number;\r\n  };\r\n  /** Constants calculation configuration */\r\n  constants: MathConstantsConfig;\r\n}\r\n\r\n/**\r\n * Configuration for data structures\r\n */\r\nexport interface DataStructuresConfig {\r\n  /** Array configuration */\r\n  array: {\r\n    initialCapacity: number;\r\n    growthFactor: number;\r\n    maxSize: number;\r\n  };\r\n  /** Tree configuration */\r\n  tree: {\r\n    maxDepth: number;\r\n    autoBalance: boolean;\r\n    nodeLimit: number;\r\n  };\r\n  /** Heap configuration */\r\n  heap: {\r\n    initialCapacity: number;\r\n    growthPolicy: 'double' | 'linear' | 'fibonacci';\r\n    validatePropertyOnOperation: boolean;\r\n  };\r\n  /** Cache configuration */\r\n  cache: CacheConfig & {\r\n    enabled: boolean;\r\n    persistToDisk: boolean;\r\n    compressionEnabled: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration for number formatting\r\n */\r\nexport interface FormattingConfig extends FormatOptions {\r\n  /** Scientific notation configuration */\r\n  scientific: {\r\n    /** Minimum exponent to trigger scientific notation */\r\n    minExponent: number;\r\n    /** Maximum significant digits */\r\n    maxSignificantDigits: number;\r\n    /** Exponent separator character */\r\n    exponentSeparator: string;\r\n  };\r\n  /** Engineering notation configuration */\r\n  engineering: {\r\n    /** Use SI prefixes */\r\n    useSIPrefixes: boolean;\r\n    /** Custom unit definitions */\r\n    customUnits?: Map<number, string>;\r\n  };\r\n  /** Localization settings */\r\n  localization: {\r\n    /** Locale identifier */\r\n    locale: string;\r\n    /** Custom number formatting */\r\n    numberFormat?: Intl.NumberFormatOptions;\r\n    /** Use locale-specific grouping */\r\n    useLocaleGrouping: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration for performance monitoring\r\n */\r\nexport interface PerformanceConfig {\r\n  /** Enable performance tracking */\r\n  enableTracking: boolean;\r\n  /** Sampling rate for metrics (0-1) */\r\n  samplingRate: number;\r\n  /** Performance thresholds */\r\n  thresholds: {\r\n    /** Warning threshold in milliseconds */\r\n    warnThresholdMs: number;\r\n    /** Error threshold in milliseconds */\r\n    errorThresholdMs: number;\r\n    /** Maximum allowed memory usage in bytes */\r\n    maxMemoryBytes: number;\r\n  };\r\n  /** Metrics collection configuration */\r\n  metrics: {\r\n    /** Enable detailed operation timing */\r\n    timing: boolean;\r\n    /** Track memory usage */\r\n    memory: boolean;\r\n    /** Track cache performance */\r\n    cache: boolean;\r\n    /** Custom metrics to track */\r\n    custom?: Map<string, (operation: any) => number>;\r\n  };\r\n}\r\n\r\n/**\r\n * Feature flags for optional functionality\r\n */\r\nexport interface FeatureFlags {\r\n  /** Enable experimental features */\r\n  experimentalFeatures: boolean;\r\n  /** Use WebAssembly implementations when available */\r\n  useWasm: boolean;\r\n  /** Enable worker thread support */\r\n  workerThreads: boolean;\r\n  /** Enable SharedArrayBuffer support */\r\n  sharedArrayBuffer: boolean;\r\n  /** Enable BigInt64Array support */\r\n  bigIntTypedArrays: boolean;\r\n}\r\n\r\n/**\r\n * Full configuration interface with all options\r\n */\r\nexport interface FullConfig {\r\n  /** Arithmetic operation configuration */\r\n  arithmetic: ArithmeticConfig;\r\n  /** Data structure configuration */\r\n  dataStructures: DataStructuresConfig;\r\n  /** Formatting configuration */\r\n  formatting: FormattingConfig;\r\n  /** Performance configuration */\r\n  performance: PerformanceConfig;\r\n  /** Debug configuration */\r\n  debug: DebugConfig;\r\n  /** Feature flags */\r\n  features: FeatureFlags;\r\n  /** Custom configuration options */\r\n  custom?: Map<string, any>;\r\n}\r\n\r\n/**\r\n * Converts FullConfig to BasicConfig if necessary\r\n */\r\nexport function convertToBasicConfig(config: HypernumConfig): BasicConfig {\r\n  if (isBasicConfig(config)) {\r\n    return config;\r\n  }\r\n  return {\r\n    precision: config.arithmetic.defaultPrecision,\r\n    roundingMode: config.arithmetic.defaultRoundingMode,\r\n    checkOverflow: config.arithmetic.checkOverflow,\r\n    maxSteps: config.arithmetic.maxComputationSteps,\r\n    debug: config.debug.verbose\r\n  };\r\n}\r\n\r\n/**\r\n * Combined configuration type that can be either basic or full\r\n */\r\nexport type HypernumConfig = BasicConfig | FullConfig;\r\n\r\n/**\r\n * Default configuration values for basic config\r\n */\r\nexport const DEFAULT_BASIC_CONFIG: Required<BasicConfig> = {\r\n  precision: 0,\r\n  roundingMode: RoundingMode.HALF_EVEN,\r\n  checkOverflow: true,\r\n  maxSteps: 1000,\r\n  debug: false\r\n};\r\n\r\n/**\r\n * Full default configuration values\r\n */\r\nexport const DEFAULT_FULL_CONFIG: FullConfig = {\r\n  arithmetic: {\r\n    defaultPrecision: 0,\r\n    defaultRoundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true,\r\n    maxComputationSteps: 1000,\r\n    autoPrecision: {\r\n      enabled: true,\r\n      maxPrecision: 100,\r\n      minPrecision: 0\r\n    },\r\n    constants: {\r\n      precision: 50,\r\n      cache: true,\r\n      algorithm: 'series'\r\n    }\r\n  },\r\n  dataStructures: {\r\n    array: {\r\n      initialCapacity: 16,\r\n      growthFactor: 2,\r\n      maxSize: 1_000_000\r\n    },\r\n    tree: {\r\n      maxDepth: 1000,\r\n      autoBalance: true,\r\n      nodeLimit: 1_000_000\r\n    },\r\n    heap: {\r\n      initialCapacity: 16,\r\n      growthPolicy: 'double',\r\n      validatePropertyOnOperation: true\r\n    },\r\n    cache: {\r\n      enabled: true,\r\n      maxSize: 1000,\r\n      ttl: 3600000, // 1 hour\r\n      evictionPolicy: 'LRU',\r\n      persistToDisk: false,\r\n      compressionEnabled: false\r\n    }\r\n  },\r\n  formatting: {\r\n    notation: 'standard',\r\n    precision: 0,\r\n    grouping: true,\r\n    groupSize: 3,\r\n    decimalSeparator: '.',\r\n    groupSeparator: ',',\r\n    uppercase: false,\r\n    scientific: {\r\n      minExponent: 6,\r\n      maxSignificantDigits: 6,\r\n      exponentSeparator: 'e'\r\n    },\r\n    engineering: {\r\n      useSIPrefixes: true\r\n    },\r\n    localization: {\r\n      locale: 'en-US',\r\n      useLocaleGrouping: false\r\n    }\r\n  },\r\n  performance: {\r\n    enableTracking: false,\r\n    samplingRate: 0.1,\r\n    thresholds: {\r\n      warnThresholdMs: 100,\r\n      errorThresholdMs: 1000,\r\n      maxMemoryBytes: 1024 * 1024 * 1024 // 1GB\r\n    },\r\n    metrics: {\r\n      timing: true,\r\n      memory: true,\r\n      cache: true\r\n    }\r\n  },\r\n  debug: {\r\n    verbose: false,\r\n    trackPerformance: false,\r\n    logLevel: 'error'\r\n  },\r\n  features: {\r\n    experimentalFeatures: false,\r\n    useWasm: false,\r\n    workerThreads: false,\r\n    sharedArrayBuffer: false,\r\n    bigIntTypedArrays: true\r\n  }\r\n};\r\n\r\n/**\r\n * Type guard to check if config is a full configuration\r\n */\r\nexport function isFullConfig(config: HypernumConfig): config is FullConfig {\r\n  return 'arithmetic' in config && 'dataStructures' in config;\r\n}\r\n\r\n/**\r\n * Type guard to check if config is a basic configuration\r\n */\r\nexport function isBasicConfig(config: HypernumConfig): config is BasicConfig {\r\n  return !isFullConfig(config);\r\n}\r\n\r\n/**\r\n * Validates configuration values\r\n */\r\nexport function validateConfig(config: HypernumConfig): void {\r\n  if (isFullConfig(config)) {\r\n    validateFullConfig(config);\r\n  } else {\r\n    validateBasicConfig(config);\r\n  }\r\n}\r\n\r\n/**\r\n * Validates basic configuration values\r\n */\r\nfunction validateBasicConfig(config: BasicConfig): void {\r\n  if (config.precision !== undefined && config.precision < 0) {\r\n    throw new Error('Precision cannot be negative');\r\n  }\r\n  if (config.maxSteps !== undefined && config.maxSteps <= 0) {\r\n    throw new Error('Maximum steps must be positive');\r\n  }\r\n  if (config.debug !== undefined && typeof config.debug !== 'boolean') {\r\n    throw new Error('Debug flag must be a boolean');\r\n  }\r\n}\r\n\r\n/**\r\n * Validates full configuration values\r\n */\r\nfunction validateFullConfig(config: FullConfig): void {\r\n  if (config.arithmetic.defaultPrecision < 0) {\r\n    throw new Error('Default precision cannot be negative');\r\n  }\r\n  if (config.arithmetic.maxComputationSteps <= 0) {\r\n    throw new Error('Max computation steps must be positive');\r\n  }\r\n  if (config.dataStructures.array.initialCapacity <= 0) {\r\n    throw new Error('Initial capacity must be positive');\r\n  }\r\n  if (config.dataStructures.array.growthFactor <= 1) {\r\n    throw new Error('Growth factor must be greater than 1');\r\n  }\r\n  if (config.performance.samplingRate < 0 || config.performance.samplingRate > 1) {\r\n    throw new Error('Sampling rate must be between 0 and 1');\r\n  }\r\n}\r\n\r\n/**\r\n * Merges configuration with appropriate defaults\r\n */\r\nexport function mergeConfig(custom: Partial<HypernumConfig> = {}): HypernumConfig {\r\n  if (isFullConfig(custom  as FullConfig)) {\r\n    const fullConfig = custom as FullConfig;\r\n    return {\r\n      ...DEFAULT_FULL_CONFIG,\r\n      ...fullConfig,\r\n      arithmetic: { ...DEFAULT_FULL_CONFIG.arithmetic, ...fullConfig.arithmetic },\r\n      dataStructures: { ...DEFAULT_FULL_CONFIG.dataStructures, ...fullConfig.dataStructures },\r\n      formatting: { ...DEFAULT_FULL_CONFIG.formatting, ...fullConfig.formatting },\r\n      performance: { ...DEFAULT_FULL_CONFIG.performance, ...fullConfig.performance },\r\n      debug: { ...DEFAULT_FULL_CONFIG.debug, ...fullConfig.debug },\r\n      features: { ...DEFAULT_FULL_CONFIG.features, ...fullConfig.features }\r\n    };\r\n  }\r\n  \r\n  const basicConfig: BasicConfig = {\r\n    precision: (custom as Partial<BasicConfig>).precision ?? DEFAULT_BASIC_CONFIG.precision,\r\n    roundingMode: (custom as Partial<BasicConfig>).roundingMode ?? DEFAULT_BASIC_CONFIG.roundingMode,\r\n    checkOverflow: (custom as Partial<BasicConfig>).checkOverflow ?? DEFAULT_BASIC_CONFIG.checkOverflow,\r\n    maxSteps: (custom as Partial<BasicConfig>).maxSteps ?? DEFAULT_BASIC_CONFIG.maxSteps,\r\n    debug: (custom as Partial<BasicConfig>).debug ?? DEFAULT_BASIC_CONFIG.debug\r\n  };\r\n\r\n  return basicConfig;\r\n}","/**\r\n * Core constants for Hypernum library\r\n * Defines fundamental values and limits used across the library\r\n */\r\n\r\n// Numerical limits\r\nexport const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\r\nexport const MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\r\nexport const MAX_PRECISION = 100;\r\nexport const MAX_COMPUTATION_STEPS = 1000;\r\nexport const MAX_BITS = 1024;\r\n\r\n// Commonly used values\r\nexport const ZERO = BigInt(0);\r\nexport const ONE = BigInt(1);\r\nexport const TWO = BigInt(2);\r\nexport const TEN = BigInt(10);\r\nexport const NEGATIVE_ONE = BigInt(-1);\r\n\r\n// Power operation limits\r\nexport const MAX_POWER_BASE = BigInt(2) ** BigInt(53);\r\nexport const MAX_POWER_EXPONENT = BigInt(1000);\r\nexport const MAX_TETRATION_HEIGHT = BigInt(4);\r\nexport const MAX_FACTORIAL_INPUT = BigInt(1000);\r\n\r\n// Tree and heap configuration\r\nexport const DEFAULT_TREE_MAX_DEPTH = 1000;\r\nexport const DEFAULT_HEAP_INITIAL_CAPACITY = 16;\r\nexport const DEFAULT_ARRAY_GROWTH_FACTOR = 2;\r\nexport const MIN_ARRAY_CAPACITY = 16;\r\n\r\n// Formatting configuration\r\nexport const DEFAULT_DECIMAL_SEPARATOR = '.';\r\nexport const DEFAULT_GROUP_SEPARATOR = ',';\r\nexport const DEFAULT_GROUP_SIZE = 3;\r\nexport const MAX_GROUP_SIZE = 10;\r\n\r\n// Roman numeral limits\r\nexport const MIN_ROMAN_VALUE = 1;\r\nexport const MAX_ROMAN_VALUE = 3999;\r\n\r\n// Ackermann function limits\r\nexport const MAX_ACKERMANN_M = 4;\r\nexport const MAX_ACKERMANN_N = 1000;\r\n\r\n// Cache configuration\r\nexport const DEFAULT_CACHE_SIZE = 1000;\r\nexport const MAX_CACHE_SIZE = 10000;\r\n\r\n// Error messages\r\nexport const ERROR_MESSAGES = {\r\n  OVERFLOW: 'Operation would result in overflow',\r\n  UNDERFLOW: 'Operation would result in underflow',\r\n  NEGATIVE_ROOT: 'Cannot compute root of negative number',\r\n  NEGATIVE_EXPONENT: 'Negative exponents not supported for integers',\r\n  DIVISION_BY_ZERO: 'Division by zero',\r\n  INVALID_PRECISION: 'Precision must be non-negative and not exceed MAX_PRECISION',\r\n  INVALID_BASE: 'Base must be a positive integer',\r\n  INVALID_ROMAN: 'Invalid Roman numeral',\r\n  COMPUTATION_LIMIT: 'Computation exceeded maximum allowed steps',\r\n  NEGATIVE_INDEX: 'Array index cannot be negative',\r\n  TREE_DEPTH_EXCEEDED: 'Maximum tree depth exceeded',\r\n  INVALID_HEAP_PROPERTY: 'Heap property violation detected'\r\n} as const;\r\n\r\n// Feature flags for optional functionality\r\nexport const FEATURES = {\r\n  OVERFLOW_CHECKING: true,\r\n  AUTOMATIC_PRECISION: true,\r\n  MEMOIZATION: true,\r\n  TREE_BALANCING: true,\r\n  DEBUG_MODE: false\r\n} as const;\r\n\r\n// Default options for various operations\r\nexport const DEFAULT_OPTIONS = {\r\n  precision: 0,\r\n  roundingMode: 'HALF_EVEN',\r\n  checkOverflow: true,\r\n  maxSteps: MAX_COMPUTATION_STEPS,\r\n  grouping: true,\r\n  uppercase: false,\r\n  cache: true\r\n} as const;\r\n\r\n// Units for number formatting (powers of 1000)\r\nexport const NUMBER_UNITS = [\r\n  { value: 1n, symbol: '' },\r\n  { value: 1000n, symbol: 'K' },\r\n  { value: 1000000n, symbol: 'M' },\r\n  { value: 1000000000n, symbol: 'B' },\r\n  { value: 1000000000000n, symbol: 'T' },\r\n  { value: 1000000000000000n, symbol: 'Q' }\r\n] as const;\r\n\r\n// Performance monitoring thresholds\r\nexport const PERFORMANCE = {\r\n  WARN_THRESHOLD_MS: 100,\r\n  ERROR_THRESHOLD_MS: 1000,\r\n  MAX_ARRAY_SIZE: 1000000,\r\n  MAX_TREE_SIZE: 1000000\r\n} as const;","/**\r\n * Custom error types for Hypernum library\r\n * Provides specific error classes for different types of errors that can occur\r\n * during mathematical operations and data structure manipulations\r\n */\r\n\r\nimport { ERROR_MESSAGES } from './constants';\r\n\r\n/**\r\n * Base error class for Hypernum library\r\n * All other error classes inherit from this\r\n */\r\nexport class HypernumError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'HypernumError';\r\n    Object.setPrototypeOf(this, HypernumError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for validation failures\r\n */\r\nexport class ValidationError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for arithmetic overflow conditions\r\n */\r\nexport class OverflowError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.OVERFLOW) {\r\n    super(message);\r\n    this.name = 'OverflowError';\r\n    Object.setPrototypeOf(this, OverflowError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for arithmetic underflow conditions\r\n */\r\nexport class UnderflowError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.UNDERFLOW) {\r\n    super(message);\r\n    this.name = 'UnderflowError';\r\n    Object.setPrototypeOf(this, UnderflowError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for division by zero\r\n */\r\nexport class DivisionByZeroError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.DIVISION_BY_ZERO) {\r\n    super(message);\r\n    this.name = 'DivisionByZeroError';\r\n    Object.setPrototypeOf(this, DivisionByZeroError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for precision-related issues\r\n */\r\nexport class PrecisionError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_PRECISION) {\r\n    super(message);\r\n    this.name = 'PrecisionError';\r\n    Object.setPrototypeOf(this, PrecisionError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for computation limits exceeded\r\n */\r\nexport class ComputationLimitError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.COMPUTATION_LIMIT) {\r\n    super(message);\r\n    this.name = 'ComputationLimitError';\r\n    Object.setPrototypeOf(this, ComputationLimitError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid operations on data structures\r\n */\r\nexport class DataStructureError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'DataStructureError';\r\n    Object.setPrototypeOf(this, DataStructureError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for heap property violations\r\n */\r\nexport class HeapPropertyError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_HEAP_PROPERTY) {\r\n    super(message);\r\n    this.name = 'HeapPropertyError';\r\n    Object.setPrototypeOf(this, HeapPropertyError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for tree-related issues\r\n */\r\nexport class TreeError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.TREE_DEPTH_EXCEEDED) {\r\n    super(message);\r\n    this.name = 'TreeError';\r\n    Object.setPrototypeOf(this, TreeError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for array index out of bounds\r\n */\r\nexport class IndexError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.NEGATIVE_INDEX) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n    Object.setPrototypeOf(this, IndexError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid number format or conversion\r\n */\r\nexport class FormatError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'FormatError';\r\n    Object.setPrototypeOf(this, FormatError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid Roman numeral operations\r\n */\r\nexport class RomanNumeralError extends FormatError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_ROMAN) {\r\n    super(message);\r\n    this.name = 'RomanNumeralError';\r\n    Object.setPrototypeOf(this, RomanNumeralError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard to check if an error is a Hypernum error\r\n */\r\nexport function isHypernumError(error: unknown): error is HypernumError {\r\n  return error instanceof HypernumError;\r\n}\r\n\r\n/**\r\n * Helper function to wrap unknown errors into HypernumError\r\n */\r\nexport function wrapError(error: unknown): HypernumError {\r\n  if (isHypernumError(error)) {\r\n    return error;\r\n  }\r\n  if (error instanceof Error) {\r\n    return new HypernumError(error.message);\r\n  }\r\n  return new HypernumError('An unknown error occurred');\r\n}\r\n\r\n/**\r\n * Helper function to create an appropriate error from a message and optional type\r\n */\r\nexport function createError(message: string, type?: string): HypernumError {\r\n  switch (type) {\r\n    case 'validation':\r\n      return new ValidationError(message);\r\n    case 'overflow':\r\n      return new OverflowError(message);\r\n    case 'underflow':\r\n      return new UnderflowError(message);\r\n    case 'division':\r\n      return new DivisionByZeroError(message);\r\n    case 'precision':\r\n      return new PrecisionError(message);\r\n    case 'computation':\r\n      return new ComputationLimitError(message);\r\n    case 'heap':\r\n      return new HeapPropertyError(message);\r\n    case 'tree':\r\n      return new TreeError(message);\r\n    case 'index':\r\n      return new IndexError(message);\r\n    case 'format':\r\n      return new FormatError(message);\r\n    case 'roman':\r\n      return new RomanNumeralError(message);\r\n    default:\r\n      return new HypernumError(message);\r\n  }\r\n}","/**\r\n * Arithmetic operations module for Hypernum library\r\n * Provides high-precision arithmetic operations with BigInt support\r\n */\r\n\r\nimport {\r\n    validateNonNegative,\r\n    toBigInt,\r\n    checkAdditionOverflow,\r\n    checkMultiplicationOverflow,\r\n    checkPowerOverflow,\r\n    ValidationError,\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    round,\r\n    scaledDivision,\r\n    normalizePrecision,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for arithmetic operations\r\n   */\r\n  export interface ArithmeticOptions {\r\n    precision?: number;\r\n    roundingMode?: RoundingMode;\r\n    checkOverflow?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ArithmeticOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true\r\n  };\r\n  \r\n  /**\r\n   * Adds two numbers with optional precision and overflow checking\r\n   */\r\n  export function add(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkAdditionOverflow(bigA, bigB);\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA + bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA + scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Subtracts two numbers with optional precision and overflow checking\r\n   */\r\n  export function subtract(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkAdditionOverflow(bigA, -bigB);\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA - bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA - scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Multiplies two numbers with optional precision and overflow checking\r\n   */\r\n  export function multiply(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkMultiplicationOverflow(bigA, bigB);\r\n    }\r\n  \r\n    const result = bigA * bigB;\r\n    if (opts.precision === 0) {\r\n      return result;\r\n    }\r\n  \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Divides two numbers with specified precision and rounding\r\n   */\r\n  export function divide(\r\n    numerator: bigint | string | number,\r\n    denominator: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigNumerator = toBigInt(numerator);\r\n    const bigDenominator = toBigInt(denominator);\r\n  \r\n    if (bigDenominator === BigInt(0)) {\r\n      throw new ValidationError('Division by zero');\r\n    }\r\n  \r\n    return scaledDivision(\r\n      bigNumerator,\r\n      bigDenominator,\r\n      opts.precision,\r\n      opts.roundingMode\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Calculates remainder with optional precision\r\n   */\r\n  export function remainder(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (bigB === BigInt(0)) {\r\n      throw new ValidationError('Division by zero in remainder operation');\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA % bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA % scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Raises a number to a power with optional precision\r\n   */\r\n  export function power(\r\n    base: bigint | string | number,\r\n    exponent: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(base);\r\n    const bigExponent = toBigInt(exponent);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkPowerOverflow(bigBase, bigExponent);\r\n    }\r\n  \r\n    validateNonNegative(bigExponent);\r\n  \r\n    if (bigExponent === BigInt(0)) {\r\n      return BigInt(1);\r\n    }\r\n  \r\n    if (bigExponent === BigInt(1)) {\r\n      return bigBase;\r\n    }\r\n  \r\n    let result = bigBase;\r\n    let remaining = bigExponent - BigInt(1);\r\n  \r\n    while (remaining > BigInt(0)) {\r\n      if (opts.checkOverflow) {\r\n        checkMultiplicationOverflow(result, bigBase);\r\n      }\r\n      result *= bigBase;\r\n      remaining--;\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates the square root with specified precision\r\n   */\r\n  export function sqrt(\r\n    value: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    validateNonNegative(bigValue);\r\n  \r\n    if (bigValue === BigInt(0)) {\r\n      return BigInt(0);\r\n    }\r\n  \r\n    // Scale up for precision\r\n    const scaleFactor = BigInt(10) ** BigInt(opts.precision * 2);\r\n    const scaled = bigValue * scaleFactor;\r\n  \r\n    // Newton's method for square root\r\n    let x = scaled;\r\n    let y = (x + scaled / x) >> BigInt(1);\r\n  \r\n    while (y < x) {\r\n      x = y;\r\n      y = (x + scaled / x) >> BigInt(1);\r\n    }\r\n  \r\n    return round(x, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Calculates the absolute value\r\n   */\r\n  export function abs(value: bigint | string | number): bigint {\r\n    const bigValue = toBigInt(value);\r\n    return bigValue < BigInt(0) ? -bigValue : bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Returns the sign of a number (-1, 0, or 1)\r\n   */\r\n  export function sign(value: bigint | string | number): bigint {\r\n    const bigValue = toBigInt(value);\r\n    if (bigValue < BigInt(0)) return BigInt(-1);\r\n    if (bigValue > BigInt(0)) return BigInt(1);\r\n    return BigInt(0);\r\n  }\r\n  \r\n  /**\r\n   * Calculates the greatest common divisor of two numbers\r\n   */\r\n  export function gcd(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    let bigA = abs(toBigInt(a));\r\n    let bigB = abs(toBigInt(b));\r\n  \r\n    while (bigB !== BigInt(0)) {\r\n      const temp = bigB;\r\n      bigB = bigA % bigB;\r\n      bigA = temp;\r\n    }\r\n  \r\n    return bigA;\r\n  }\r\n  \r\n  /**\r\n   * Calculates the least common multiple of two numbers\r\n   */\r\n  export function lcm(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = abs(toBigInt(a));\r\n    const bigB = abs(toBigInt(b));\r\n    \r\n    if (bigA === BigInt(0) || bigB === BigInt(0)) {\r\n      return BigInt(0);\r\n    }\r\n  \r\n    return abs(bigA * bigB) / gcd(bigA, bigB);\r\n  }\r\n  \r\n  // /**\r\n  //  * Calculates factorial of a number\r\n  //  */\r\n  // export function factorial(value: bigint | string | number): bigint {\r\n  //   const bigValue = toBigInt(value);\r\n  //   validateNonNegative(bigValue);\r\n  \r\n  //   if (bigValue > BigInt(1000)) {\r\n  //     throw new OverflowError('Factorial input too large');\r\n  //   }\r\n  \r\n  //   if (bigValue <= BigInt(1)) {\r\n  //     return BigInt(1);\r\n  //   }\r\n  \r\n  //   let result = BigInt(1);\r\n  //   let current = BigInt(2);\r\n  \r\n  //   while (current <= bigValue) {\r\n  //     result *= current;\r\n  //     current++;\r\n  //   }\r\n  \r\n  //   return result;\r\n  // }\r\n  \r\n  export default {\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide,\r\n    remainder,\r\n    power,\r\n    sqrt,\r\n    abs,\r\n    sign,\r\n    gcd,\r\n    lcm, \r\n    // factorial\r\n    };\r\n\r\n  ","/**\r\n * Bitwise operations module for Hypernum library\r\n * Provides functions for bit-level manipulations of large numbers\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    validateNonNegative\r\n  } from '../utils/validation';\r\n  \r\n  /**\r\n   * Options for bitwise operations\r\n   */\r\n  export interface BitwiseOptions {\r\n    /** Maximum bits to consider in operations */\r\n    maxBits?: number;\r\n    /** Whether to throw on overflow */\r\n    strict?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<BitwiseOptions> = {\r\n    maxBits: 1024,\r\n    strict: true\r\n  };\r\n  \r\n  /**\r\n   * Validates shift amount is within reasonable bounds\r\n   */\r\n  function validateShift(shift: bigint, options: Required<BitwiseOptions>): void {\r\n    if (shift < 0n) {\r\n      throw new ValidationError('Shift amount cannot be negative');\r\n    }\r\n    if (options.strict && shift >= BigInt(options.maxBits)) {\r\n      throw new ValidationError(`Shift amount exceeds maximum of ${options.maxBits} bits`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise AND operation\r\n   */\r\n  export function and(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n\r\n    return bigA & bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise OR operation\r\n   */\r\n  export function or(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n    \r\n    return bigA | bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise XOR operation\r\n   */\r\n  export function xor(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n    \r\n    return bigA ^ bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise NOT operation\r\n   */\r\n  export function not(\r\n    value: bigint | string | number\r\n  ): bigint {\r\n    const bigValue = toBigInt(value);\r\n    \r\n    return ~bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Performs left shift operation\r\n   */\r\n  export function leftShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    return bigValue << bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Performs right shift operation\r\n   */\r\n  export function rightShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    return bigValue >> bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Performs unsigned right shift operation\r\n   * Note: BigInt doesn't have >>> operator, so we implement it manually\r\n   */\r\n  export function unsignedRightShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    \r\n    if (bigValue >= 0n) {\r\n      return bigValue >> bigShift;\r\n    }\r\n    \r\n    // Handle negative numbers by first converting to positive\r\n    const mask = (1n << BigInt(opts.maxBits)) - 1n;\r\n    return (bigValue & mask) >> bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Rotates bits left by specified amount\r\n   */\r\n  export function rotateLeft(\r\n    value: bigint | string | number,\r\n    rotation: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    let bigRotation = toBigInt(rotation);\r\n    \r\n    validateNonNegative(bigRotation);\r\n    \r\n    // Normalize rotation to be within maxBits\r\n    if (bigRotation >= BigInt(opts.maxBits)) {\r\n      bigRotation = bigRotation % BigInt(opts.maxBits);\r\n    }\r\n    \r\n    if (bigRotation === 0n) {\r\n      return bigValue;\r\n    }\r\n    \r\n    const leftPart = leftShift(bigValue, bigRotation, opts);\r\n    const rightPart = unsignedRightShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\r\n    \r\n    return leftPart | rightPart;\r\n  }\r\n  \r\n  /**\r\n   * Rotates bits right by specified amount\r\n   */\r\n  export function rotateRight(\r\n    value: bigint | string | number,\r\n    rotation: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    let bigRotation = toBigInt(rotation);\r\n    \r\n    validateNonNegative(bigRotation);\r\n    \r\n    // Normalize rotation to be within maxBits\r\n    if (bigRotation >= BigInt(opts.maxBits)) {\r\n      bigRotation = bigRotation % BigInt(opts.maxBits);\r\n    }\r\n    \r\n    if (bigRotation === 0n) {\r\n      return bigValue;\r\n    }\r\n    \r\n    const rightPart = unsignedRightShift(bigValue, bigRotation, opts);\r\n    const leftPart = leftShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\r\n    \r\n    return leftPart | rightPart;\r\n  }\r\n  \r\n  /**\r\n   * Counts number of set bits (1s)\r\n   */\r\n  export function popCount(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    let count = 0n;\r\n    while (bigValue !== 0n) {\r\n      count += bigValue & 1n;\r\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns number of trailing zero bits\r\n   */\r\n  export function trailingZeros(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return BigInt(opts.maxBits);\r\n    }\r\n    \r\n    let count = 0n;\r\n    while ((bigValue & 1n) === 0n) {\r\n      count++;\r\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns number of leading zero bits\r\n   */\r\n  export function leadingZeros(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return BigInt(opts.maxBits);\r\n    }\r\n    \r\n    let count = 0n;\r\n    const msb = 1n << BigInt(opts.maxBits - 1);\r\n    \r\n    while ((bigValue & msb) === 0n && count < BigInt(opts.maxBits)) {\r\n      count++;\r\n      bigValue = leftShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns bit at specified position\r\n   */\r\n  export function getBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): boolean {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return (bigValue & (1n << bigPosition)) !== 0n;\r\n  }\r\n  \r\n  /**\r\n   * Sets bit at specified position\r\n   */\r\n  export function setBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue | (1n << bigPosition);\r\n  }\r\n  \r\n  /**\r\n   * Clears bit at specified position\r\n   */\r\n  export function clearBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue & ~(1n << bigPosition);\r\n  }\r\n  \r\n  /**\r\n   * Toggles bit at specified position\r\n   */\r\n  export function toggleBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue ^ (1n << bigPosition);\r\n  }\r\n  \r\n  export default {\r\n    and,\r\n    or,\r\n    xor,\r\n    not,\r\n    leftShift,\r\n    rightShift,\r\n    unsignedRightShift,\r\n    rotateLeft,\r\n    rotateRight,\r\n    popCount,\r\n    trailingZeros,\r\n    leadingZeros,\r\n    getBit,\r\n    setBit,\r\n    clearBit,\r\n    toggleBit\r\n  };","/**\r\n * Power operations module for Hypernum library\r\n * Provides efficient implementations for exponentiation and related operations\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    OverflowError,\r\n    validateNonNegative,\r\n    checkPowerOverflow\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    round,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for power operations\r\n   */\r\n  export interface PowerOptions {\r\n    /** Precision for decimal operations */\r\n    precision?: number;\r\n    /** Rounding mode for decimal operations */\r\n    roundingMode?: RoundingMode;\r\n    /** Whether to check for overflow */\r\n    checkOverflow?: boolean;\r\n    /** Maximum allowed computation steps */\r\n    maxSteps?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<PowerOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true,\r\n    maxSteps: 1000\r\n  };\r\n  \r\n  /**\r\n   * Raises a number to an integer power using binary exponentiation\r\n   */\r\n  export function power(\r\n    baseValue: bigint | string | number,\r\n    exponentValue: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(baseValue);\r\n    const bigExponent = toBigInt(exponentValue);\r\n  \r\n    // Handle special cases\r\n    if (bigExponent === 0n) {\r\n      return 1n;\r\n    }\r\n    if (bigExponent === 1n) {\r\n      return bigBase;\r\n    }\r\n    if (bigBase === 0n && bigExponent < 0n) {\r\n      throw new ValidationError('Zero cannot be raised to a negative power');\r\n    }\r\n    if (bigBase === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigBase === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigBase === -1n) {\r\n      return bigExponent % 2n === 0n ? 1n : -1n;\r\n    }\r\n  \r\n    // Validate inputs\r\n    if (bigExponent < 0n) {\r\n      throw new ValidationError('Negative exponents not supported for integer power');\r\n    }\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkPowerOverflow(bigBase, bigExponent);\r\n    }\r\n  \r\n    // Binary exponentiation algorithm\r\n    let result = 1n;\r\n    let base = bigBase;\r\n    let exponent = bigExponent;\r\n    let steps = 0;\r\n  \r\n    while (exponent > 0n) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Power operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      if (exponent & 1n) {\r\n        result *= base;\r\n      }\r\n      base *= base;\r\n      exponent >>= 1n;\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates square root using Newton's method\r\n   */\r\n  export function sqrt(\r\n    value: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n  \r\n    validateNonNegative(bigValue);\r\n  \r\n    if (bigValue === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n  \r\n    // Newton's method for square root\r\n    let guess = bigValue >> 1n;\r\n    let lastGuess: bigint;\r\n    let steps = 0;\r\n  \r\n    do {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Square root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      lastGuess = guess;\r\n      guess = (guess + bigValue / guess) >> 1n;\r\n    } while (guess < lastGuess);\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(lastGuess, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return lastGuess;\r\n  }\r\n  \r\n  /**\r\n   * Calculates nth root using Newton's method\r\n   */\r\n  export function nthRoot(\r\n    value: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigValue);\r\n    if (bigN <= 0n) {\r\n      throw new ValidationError('Root index must be positive');\r\n    }\r\n  \r\n    if (bigValue === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigN === 1n) {\r\n      return bigValue;\r\n    }\r\n    if (bigN === 2n) {\r\n      return sqrt(bigValue, opts);\r\n    }\r\n  \r\n    // Newton's method for nth root\r\n    let guess = bigValue >> 1n;\r\n    let lastGuess: bigint;\r\n    let steps = 0;\r\n  \r\n    const nMinus1 = bigN - 1n;\r\n  \r\n    do {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Nth root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      lastGuess = guess;\r\n      const powered = power(guess, nMinus1, opts);\r\n      guess = ((nMinus1 * guess) + (bigValue / powered)) / bigN;\r\n    } while (guess < lastGuess);\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(lastGuess, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return lastGuess;\r\n  }\r\n  \r\n  /**\r\n   * Calculates tetration (repeated exponentiation)\r\n   * an = a^(a^(a^...)) (n times)\r\n   */\r\n  export function tetration(\r\n    base: bigint | string | number,\r\n    height: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(base);\r\n    const bigHeight = toBigInt(height);\r\n  \r\n    validateNonNegative(bigHeight);\r\n  \r\n    if (bigHeight === 0n) {\r\n      return 1n;\r\n    }\r\n    if (bigHeight === 1n) {\r\n      return bigBase;\r\n    }\r\n    if (bigBase === 0n) {\r\n      return bigHeight % 2n === 0n ? 1n : 0n;\r\n    }\r\n    if (bigBase === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigBase === 2n && bigHeight > 4n) {\r\n      throw new OverflowError('Tetration would overflow for base 2 and height > 4');\r\n    }\r\n  \r\n    let result = bigBase;\r\n    let steps = 0;\r\n  \r\n    for (let i = 1n; i < bigHeight; i++) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Tetration operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      result = power(bigBase, result, opts);\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates super-root (inverse tetration)\r\n   * Finds x where xn = value\r\n   */\r\n  export function superRoot(\r\n    value: bigint | string | number,\r\n    height: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigHeight = toBigInt(height);\r\n  \r\n    validateNonNegative(bigHeight);\r\n    if (bigHeight === 0n) {\r\n      throw new ValidationError('Height cannot be zero for super-root');\r\n    }\r\n    if (bigValue < 1n) {\r\n      throw new ValidationError('Value must be at least 1 for super-root');\r\n    }\r\n  \r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigHeight === 1n) {\r\n      return bigValue;\r\n    }\r\n  \r\n    // Binary search for super-root\r\n    let left = 1n;\r\n    let right = bigValue;\r\n    let steps = 0;\r\n  \r\n    while (left <= right) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Super-root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      const mid = (left + right) >> 1n;\r\n      try {\r\n        const test = tetration(mid, bigHeight, opts);\r\n        if (test === bigValue) {\r\n          return mid;\r\n        }\r\n        if (test < bigValue) {\r\n          left = mid + 1n;\r\n        } else {\r\n          right = mid - 1n;\r\n        }\r\n      } catch (error) {\r\n        right = mid - 1n;\r\n      }\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(right, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return right;\r\n  }\r\n  \r\n  export default {\r\n    power,\r\n    sqrt,\r\n    nthRoot,\r\n    tetration,\r\n    superRoot\r\n  };","\r\n/**\r\n * Represents the result of a comparison operation\r\n * -1: first value is less than second value\r\n *  0: values are equal\r\n *  1: first value is greater than second value\r\n */\r\nexport type ComparisonResult = -1 | 0 | 1;\r\n\r\n/**\r\n * Generic comparator function type for heap elements\r\n */\r\nexport type Comparator<T> = (a: T, b: T) => ComparisonResult;\r\n\r\n/**\r\n * Abstract base heap class implementing common heap operations\r\n */\r\nabstract class Heap<T> {\r\n  protected heap: T[];\r\n  protected readonly compare: Comparator<T>;\r\n\r\n  constructor(comparator: Comparator<T>) {\r\n    this.heap = [];\r\n    this.compare = comparator;\r\n  }\r\n\r\n  /**\r\n   * Gets the size of the heap\r\n   */\r\n  public size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  /**\r\n   * Checks if the heap is empty\r\n   */\r\n  public isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Peeks at the root element without removing it\r\n   */\r\n  public peek(): T | undefined {\r\n    return this.heap[0];\r\n  }\r\n\r\n  /**\r\n   * Inserts a new element into the heap\r\n   */\r\n  public push(value: T): void {\r\n    this.heap.push(value);\r\n    this.siftUp(this.heap.length - 1);\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the root element\r\n   */\r\n  public pop(): T | undefined {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n\r\n    const root = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n\r\n    if (!this.isEmpty()) {\r\n      this.heap[0] = last;\r\n      this.siftDown(0);\r\n    }\r\n\r\n    return root;\r\n  }\r\n\r\n  /**\r\n   * Removes all elements from the heap\r\n   */\r\n  public clear(): void {\r\n    this.heap = [];\r\n  }\r\n\r\n  /**\r\n   * Creates a heap from an array of elements\r\n   */\r\n  public static heapify<T extends {}>(array: T[], comparator: Comparator<T>): Heap<T> {\r\n    const heap = this instanceof MinHeap ? new MinHeap(comparator) : new MaxHeap(comparator);\r\n    array.forEach(item => heap.push(item));\r\n    return heap;\r\n  }\r\n\r\n  /**\r\n   * Gets the parent index of a node\r\n   */\r\n  protected getParentIndex(index: number): number {\r\n    return Math.floor((index - 1) / 2);\r\n  }\r\n\r\n  /**\r\n   * Gets the left child index of a node\r\n   */\r\n  protected getLeftChildIndex(index: number): number {\r\n    return 2 * index + 1;\r\n  }\r\n\r\n  /**\r\n   * Gets the right child index of a node\r\n   */\r\n  protected getRightChildIndex(index: number): number {\r\n    return 2 * index + 2;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the heap\r\n   */\r\n  protected swap(i: number, j: number): void {\r\n    const temp = this.heap[i]!;\r\n    this.heap[i] = this.heap[j]!;\r\n    this.heap[j] = temp;\r\n  }\r\n\r\n  /**\r\n   * Moves an element up the heap until heap property is satisfied\r\n   */\r\n  protected abstract siftUp(index: number): void;\r\n\r\n  /**\r\n   * Moves an element down the heap until heap property is satisfied\r\n   */\r\n  protected abstract siftDown(index: number): void;\r\n}\r\n\r\n/**\r\n * MinHeap implementation where the root is the smallest element\r\n */\r\nexport class MinHeap<T> extends Heap<T> {\r\n  constructor(comparator: Comparator<T>) {\r\n    super(comparator);\r\n  }\r\n\r\n  protected siftUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = this.getParentIndex(index);\r\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) >= 0) {\r\n        break;\r\n      }\r\n      this.swap(index, parentIndex);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  protected siftDown(index: number): void {\r\n    const size = this.heap.length;\r\n    \r\n    while (true) {\r\n      let smallest = index;\r\n      const left = this.getLeftChildIndex(index);\r\n      const right = this.getRightChildIndex(index);\r\n\r\n      if (left < size && this.compare(this.heap[left]!, this.heap[smallest]!) < 0) {\r\n        smallest = left;\r\n      }\r\n\r\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right] as T, this.heap[smallest] as T) < 0) {\r\n        smallest = right;\r\n      }\r\n\r\n      if (smallest === index) {\r\n        break;\r\n      }\r\n\r\n      this.swap(index, smallest);\r\n      index = smallest;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * MaxHeap implementation where the root is the largest element\r\n */\r\nexport class MaxHeap<T> extends Heap<T> {\r\n  constructor(comparator: Comparator<T>) {\r\n    super(comparator);\r\n  }\r\n\r\n  protected siftUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = this.getParentIndex(index);\r\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) <= 0) {\r\n        break;\r\n      }\r\n      this.swap(index, parentIndex);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  protected siftDown(index: number): void {\r\n    const size = this.heap.length;\r\n    \r\n    while (true) {\r\n      let largest = index;\r\n      const left = this.getLeftChildIndex(index);\r\n      const right = this.getRightChildIndex(index);\r\n\r\n      if (left < size && this.heap[left] !== undefined && this.compare(this.heap[left]!, this.heap[largest]!) > 0) {\r\n        largest = left;\r\n      }\r\n\r\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right]!, this.heap[largest]!) > 0) {\r\n        largest = right;\r\n      }\r\n\r\n      if (largest === index) {\r\n        break;\r\n      }\r\n\r\n      this.swap(index, largest);\r\n      index = largest;\r\n    }\r\n  }\r\n}\r\n\r\n// Type Guards\r\nexport const isMinHeap = <T>(heap: Heap<T>): heap is MinHeap<T> => {\r\n  return heap instanceof MinHeap;\r\n};\r\n\r\nexport const isMaxHeap = <T>(heap: Heap<T>): heap is MaxHeap<T> => {\r\n  return heap instanceof MaxHeap;\r\n};\r\n\r\n/**\r\n * Custom comparator for large numbers\r\n */\r\nexport function createLargeNumberComparator(): (a: bigint, b: bigint) => number {\r\n  return (a, b) => {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n  };\r\n}","import { Comparator } from \"..\";\r\nimport { MaxHeap, createLargeNumberComparator } from \"../storage/Heap\";\r\n\r\n  /**\r\n   * Interface representing an Ackermann node in the computation structure\r\n   */\r\n  interface IAckermannNode {\r\n    m: number;\r\n    n: number;\r\n    value: bigint;\r\n    prevM?: IAckermannNode;  // Link to A(m-1, n)\r\n    prevN?: IAckermannNode;  // Link to A(m, n-1)\r\n    nextM?: IAckermannNode;  // Link to A(m+1, n)\r\n    nextN?: IAckermannNode;  // Link to A(m, n+1)\r\n  }\r\n  \r\n  /**\r\n   * Type for Ackermann computation path step\r\n   */\r\n  type ComputationStep = {\r\n    m: number;\r\n    n: number;\r\n    value: bigint;\r\n  };\r\n  \r\n  /**\r\n   * Type for growth rate analysis\r\n   */\r\n  type GrowthAnalysis = {\r\n    value: bigint;\r\n    increase: bigint;\r\n    multiplier: bigint;\r\n  };\r\n  \r\n  /**\r\n   * Class representing the Ackermann function computation structure\r\n   * Implements caching and relationship tracking between values\r\n   */\r\n  export class AckermannStructure {\r\n    private nodes: Map<string, IAckermannNode>;\r\n    private maxComputedM: number;\r\n    private maxComputedN: number;\r\n    private heap: MaxHeap<bigint>;\r\n  \r\n    constructor() {\r\n      this.nodes = new Map();\r\n      this.maxComputedM = -1;\r\n      this.maxComputedN = -1;\r\n      this.heap = new MaxHeap<bigint>(createLargeNumberComparator() as Comparator<bigint>);\r\n    }\r\n  \r\n    /**\r\n     * Generates a unique key for node storage\r\n     */\r\n    private static getNodeKey(m: number, n: number): string {\r\n      return `${m},${n}`;\r\n    }\r\n  \r\n    /**\r\n     * Computes the Ackermann function value\r\n     * Uses recursion with memoization\r\n     */\r\n    private computeAckermann(m: number, n: number): bigint {\r\n      // Handle invalid inputs\r\n      if (m < 0 || n < 0) {\r\n        throw new Error('Ackermann function undefined for negative numbers');\r\n      }\r\n  \r\n      // Check if already computed\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      const existing = this.nodes.get(key);\r\n      if (existing) {\r\n        return existing.value;\r\n      }\r\n  \r\n      // Compute based on Ackermann function definition\r\n      let value: bigint;\r\n      try {\r\n        if (m === 0) {\r\n          value = BigInt(n + 1);\r\n        } else if (n === 0) {\r\n          value = this.computeAckermann(m - 1, 1);\r\n        } else {\r\n          const inner = this.computeAckermann(m, n - 1);\r\n          // Convert bigint to number for recursion, being careful about size\r\n          const innerNum = inner <= BigInt(Number.MAX_SAFE_INTEGER) \r\n            ? Number(inner) \r\n            : Number.MAX_SAFE_INTEGER;\r\n          value = this.computeAckermann(m - 1, innerNum);\r\n        }\r\n      } catch (error) {\r\n        // Handle stack overflow or computation limits\r\n        if (error instanceof RangeError) {\r\n          return BigInt(Number.MAX_SAFE_INTEGER);\r\n        }\r\n        throw error;\r\n      }\r\n  \r\n      return value;\r\n    }\r\n  \r\n    /**\r\n     * Adds a new node to the structure\r\n     */\r\n    public addNode(m: number, n: number): IAckermannNode {\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      if (this.nodes.has(key)) {\r\n        return this.nodes.get(key)!;\r\n      }\r\n  \r\n      // Create new node\r\n      const value = this.computeAckermann(m, n);\r\n      const node: IAckermannNode = { m, n, value };\r\n      this.nodes.set(key, node);\r\n  \r\n      // Link to existing nodes\r\n      const prevMKey = AckermannStructure.getNodeKey(m - 1, n);\r\n      const prevNKey = AckermannStructure.getNodeKey(m, n - 1);\r\n  \r\n      if (this.nodes.has(prevMKey)) {\r\n        const prevM = this.nodes.get(prevMKey)!;\r\n        node.prevM = prevM;\r\n        prevM.nextM = node;\r\n      }\r\n  \r\n      if (this.nodes.has(prevNKey)) {\r\n        const prevN = this.nodes.get(prevNKey)!;\r\n        node.prevN = prevN;\r\n        prevN.nextN = node;\r\n      }\r\n  \r\n      // Update tracking\r\n      this.maxComputedM = Math.max(this.maxComputedM, m);\r\n      this.maxComputedN = Math.max(this.maxComputedN, n);\r\n      this.heap.push(value);\r\n  \r\n      return node;\r\n    }\r\n  \r\n    /**\r\n     * Builds nodes for a range of m and n values\r\n     */\r\n    public buildRange(mRange: number, nRange: number): void {\r\n      for (let m = 0; m <= mRange; m++) {\r\n        for (let n = 0; n <= nRange; n++) {\r\n          this.addNode(m, n);\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Gets the computation path to reach A(m,n)\r\n     */\r\n    public getComputationPath(m: number, n: number): ComputationStep[] {\r\n      const path: ComputationStep[] = [];\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      let current = this.nodes.get(key);\r\n  \r\n      while (current) {\r\n        path.push({\r\n          m: current.m,\r\n          n: current.n,\r\n          value: current.value\r\n        });\r\n  \r\n        // Follow computation path backwards\r\n        if (current.m === 0) {\r\n          break;\r\n        } else if (current.n === 0) {\r\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, 1));\r\n        } else {\r\n          const prevN = this.nodes.get(AckermannStructure.getNodeKey(current.m, current.n - 1));\r\n          if (prevN) {\r\n            path.push({\r\n              m: prevN.m,\r\n              n: prevN.n,\r\n              value: prevN.value\r\n            });\r\n          }\r\n          // Convert bigint to number safely for the next lookup\r\n          const nextValue = prevN?.value ?? BigInt(0);\r\n          const safeNextValue = nextValue <= BigInt(Number.MAX_SAFE_INTEGER)\r\n            ? Number(nextValue)\r\n            : Number.MAX_SAFE_INTEGER;\r\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, safeNextValue));\r\n        }\r\n      }\r\n  \r\n      return path.reverse();\r\n    }\r\n  \r\n    /**\r\n     * Analyzes growth rate for a fixed m value\r\n     */\r\n    public analyzeGrowthRate(m: number): Map<number, GrowthAnalysis> {\r\n      const growth = new Map<number, GrowthAnalysis>();\r\n      let prevValue = BigInt(1);\r\n  \r\n      for (let n = 0; n <= this.maxComputedN; n++) {\r\n        const key = AckermannStructure.getNodeKey(m, n);\r\n        const node = this.nodes.get(key);\r\n        if (!node || node.value >= BigInt(Number.MAX_SAFE_INTEGER)) {\r\n          break;\r\n        }\r\n  \r\n        growth.set(n, {\r\n          value: node.value,\r\n          increase: node.value - prevValue,\r\n          multiplier: prevValue === BigInt(0) ? BigInt(0) : node.value / prevValue\r\n        });\r\n  \r\n        prevValue = node.value;\r\n      }\r\n  \r\n      return growth;\r\n    }\r\n  \r\n    /**\r\n     * Gets the largest computed value\r\n     */\r\n    public getLargestValue(): bigint {\r\n      return this.heap.peek() ?? BigInt(0);\r\n    }\r\n  \r\n    /**\r\n     * Gets a specific Ackermann value if it exists\r\n     */\r\n    public getValue(m: number, n: number): bigint | undefined {\r\n      return this.nodes.get(AckermannStructure.getNodeKey(m, n))?.value;\r\n    }\r\n  }\r\n  \r\n  export default AckermannStructure;","import { Comparator } from '@/core';\r\nimport { MinHeap, MaxHeap } from '../storage/Heap';\r\n\r\n/**\r\n * Interface for segment tree node operations\r\n */\r\nexport interface SegmentTreeNode<T> {  value: T;\r\n  lazy?: T;\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\n/**\r\n * Type for BigArray operation result\r\n */\r\nexport type OperationResult<T> = {\r\n  success: boolean;\r\n  value?: T;\r\n  error?: string;\r\n};\r\n\r\n/**\r\n * Options for BigArray initialization\r\n */\r\nexport interface BigArrayOptions<T> {\r\n  initialCapacity?: number;\r\n  growthFactor?: number;\r\n  comparator?: Comparator<T>;\r\n}\r\n\r\n/**\r\n * A specialized array implementation for handling large numbers and providing\r\n * efficient operations with segment tree support\r\n */\r\nexport class BigArray<T> {\r\n  private data: T[];\r\n  private segmentTree: Array<SegmentTreeNode<T> | null>;\r\n  private readonly growthFactor: number;\r\n  private readonly comparator: Comparator<T>;\r\n  private size: number;\r\n  private capacity: number;\r\n\r\n  constructor(options: BigArrayOptions<T> = {}) {\r\n    const {\r\n      initialCapacity = 16,\r\n      growthFactor = 2,\r\n      comparator = ((a: T, b: T): -1 | 0 | 1 => {\r\n        if (a < b) return -1;\r\n        if (a > b) return 1;\r\n        return 0;\r\n      }) as Comparator<T>\r\n    } = options;\r\n\r\n    this.capacity = initialCapacity;\r\n    this.growthFactor = growthFactor;\r\n    this.comparator = comparator;\r\n    this.size = 0;\r\n    this.data = new Array(this.capacity);\r\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\r\n  }\r\n\r\n  /**\r\n   * Gets the current size of the array\r\n   */\r\n  public getSize(): number {\r\n    return this.size;\r\n  }\r\n\r\n  /**\r\n   * Gets the current capacity of the array\r\n   */\r\n  public getCapacity(): number {\r\n    return this.capacity;\r\n  }\r\n\r\n  /**\r\n   * Resizes the internal array when needed\r\n   */\r\n  private resize(newCapacity: number): void {\r\n    const newData = new Array(newCapacity);\r\n    for (let i = 0; i < this.size; i++) {\r\n      newData[i] = this.data[i];\r\n    }\r\n    this.data = newData;\r\n    this.capacity = newCapacity;\r\n    this.rebuildSegmentTree();\r\n  }\r\n\r\n  /**\r\n   * Appends an element to the end of the array\r\n   */\r\n  public push(value: T): OperationResult<number> {\r\n    try {\r\n      if (this.size >= this.capacity) {\r\n        this.resize(this.capacity * this.growthFactor);\r\n      }\r\n      this.data[this.size] = value;\r\n      this.updateSegmentTree(0, this.size, value);\r\n      this.size++;\r\n      return { success: true, value: this.size - 1 };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error during push'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the last element\r\n   */\r\n  public pop(): OperationResult<T> {\r\n    if (this.size === 0) {\r\n      return { success: false, error: 'Array is empty' };\r\n    }\r\n\r\n    const value = this.data[this.size - 1];\r\n    this.size--;\r\n    \r\n    // Shrink array if it's too sparse\r\n    if (this.size < this.capacity / (this.growthFactor * 2)) {\r\n      this.resize(Math.max(16, Math.floor(this.capacity / this.growthFactor)));\r\n    }\r\n\r\n    return { success: true, value };\r\n  }\r\n\r\n  /**\r\n   * Gets element at specified index\r\n   */\r\n  public get(index: number): OperationResult<T> {\r\n    if (index < 0 || index >= this.size) {\r\n      return { success: false, error: 'Index out of bounds' };\r\n    }\r\n    return { success: true, value: this.data[index] };\r\n  }\r\n\r\n  /**\r\n   * Sets element at specified index\r\n   */\r\n  public set(index: number, value: T): OperationResult<T> {\r\n    if (index < 0 || index >= this.size) {\r\n      return { success: false, error: 'Index out of bounds' };\r\n    }\r\n    \r\n    const oldValue = this.data[index];\r\n    this.data[index] = value;\r\n    this.updateSegmentTree(0, index, value);\r\n    \r\n    return { success: true, value: oldValue };\r\n  }\r\n\r\n  /**\r\n   * Rebuilds the segment tree after major changes\r\n   */\r\n  private rebuildSegmentTree(): void {\r\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\r\n    if (this.size > 0) {\r\n      this.buildSegmentTree(0, 0, this.size - 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds a segment tree node recursively\r\n   */\r\n  private buildSegmentTree(node: number, start: number, end: number): void {\r\n    if (start === end) {\r\n      this.segmentTree[node] = {\r\n        value: this.data[start] as T,\r\n        start,\r\n        end\r\n      };\r\n      return;\r\n    }\r\n\r\n    const mid = Math.floor((start + end) / 2);\r\n    this.buildSegmentTree(2 * node + 1, start, mid);\r\n    this.buildSegmentTree(2 * node + 2, mid + 1, end);\r\n\r\n    const leftNode = this.segmentTree[2 * node + 1];\r\n    const rightNode = this.segmentTree[2 * node + 2];\r\n\r\n    if (leftNode && rightNode) {\r\n      this.segmentTree[node] = {\r\n        value: this.comparator(leftNode.value, rightNode.value) >= 0 \r\n          ? leftNode.value \r\n          : rightNode.value,\r\n        start,\r\n        end\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the segment tree after a value change\r\n   */\r\n  private updateSegmentTree(node: number, index: number, value: T): void {\r\n    if (!this.segmentTree[node]) {\r\n      return;\r\n    }\r\n\r\n    const currentNode = this.segmentTree[node]!;\r\n    if (currentNode.start === currentNode.end) {\r\n      currentNode.value = value;\r\n      return;\r\n    }\r\n\r\n    const mid = Math.floor((currentNode.start + currentNode.end) / 2);\r\n    if (index <= mid) {\r\n      this.updateSegmentTree(2 * node + 1, index, value);\r\n    } else {\r\n      this.updateSegmentTree(2 * node + 2, index, value);\r\n    }\r\n\r\n    const leftNode = this.segmentTree[2 * node + 1];\r\n    const rightNode = this.segmentTree[2 * node + 2];\r\n\r\n    if (leftNode && rightNode) {\r\n      currentNode.value = this.comparator(leftNode.value, rightNode.value) >= 0 \r\n        ? leftNode.value \r\n        : rightNode.value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Queries the maximum value in a range\r\n   */\r\n  public queryRange(start: number, end: number): OperationResult<T> {\r\n    if (start < 0 || end >= this.size || start > end) {\r\n      return { success: false, error: 'Invalid range' };\r\n    }\r\n\r\n    const result = this.querySegmentTree(0, start, end);\r\n    return result \r\n      ? { success: true, value: result }\r\n      : { success: false, error: 'Range query failed' };\r\n  }\r\n\r\n  /**\r\n   * Recursively queries the segment tree\r\n   */\r\n  private querySegmentTree(node: number, queryStart: number, queryEnd: number): T | null {\r\n    const currentNode = this.segmentTree[node];\r\n    if (!currentNode) {\r\n      return null;\r\n    }\r\n\r\n    if (queryStart <= currentNode.start && queryEnd >= currentNode.end) {\r\n      return currentNode.value;\r\n    }\r\n\r\n    if (queryEnd < currentNode.start || queryStart > currentNode.end) {\r\n      return null;\r\n    }\r\n\r\n    const leftResult = this.querySegmentTree(2 * node + 1, queryStart, queryEnd);\r\n    const rightResult = this.querySegmentTree(2 * node + 2, queryStart, queryEnd);\r\n\r\n    if (leftResult === null) return rightResult;\r\n    if (rightResult === null) return leftResult;\r\n\r\n    return this.comparator(leftResult, rightResult) >= 0 ? leftResult : rightResult;\r\n  }\r\n\r\n  /**\r\n   * Creates a heap from the current array\r\n   */\r\n  public toHeap(isMin: boolean = true): MinHeap<T> | MaxHeap<T> {\r\n    const heap = isMin \r\n      ? new MinHeap<T>(this.comparator)\r\n      : new MaxHeap<T>(this.comparator);\r\n      \r\n    for (let i = 0; i < this.size; i++) {\r\n      if (this.data[i] !== undefined) {\r\n        if (this.data[i] !== undefined) {\r\n          heap.push(this.data[i] as T);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return heap;\r\n  }\r\n\r\n  /**\r\n   * Sorts the array in-place\r\n   */\r\n  public sort(ascending: boolean = true): void {\r\n    const heap = this.toHeap(!ascending);\r\n    for (let i = this.size - 1; i >= 0; i--) {\r\n      const value = heap.pop();\r\n      if (value !== undefined) {\r\n        this.data[i] = value;\r\n      }\r\n    }\r\n    this.rebuildSegmentTree();\r\n  }\r\n\r\n  /**\r\n   * Returns array as native array\r\n   */\r\n  public toArray(): T[] {\r\n    return this.data.slice(0, this.size);\r\n  }\r\n}\r\n\r\nexport default BigArray;","import { Comparator } from \"@/core\";\r\n\r\n/**\r\n * Interface for tree node statistics\r\n */\r\ninterface NodeStats {\r\n  height: number;\r\n  size: number;\r\n  sum: bigint;\r\n  min: bigint;\r\n  max: bigint;\r\n}\r\n\r\n/**\r\n * Interface for tree traversal configuration\r\n */\r\ninterface TraversalConfig {\r\n  includeStats?: boolean;\r\n  skipSubtrees?: boolean;\r\n  maxDepth?: number;\r\n}\r\n\r\n/**\r\n * Class representing a node in the number tree\r\n */\r\nclass NumberNode {\r\n  value: bigint;\r\n  left: NumberNode | null;\r\n  right: NumberNode | null;\r\n  parent: NumberNode | null;\r\n  height: number;\r\n  size: number;\r\n  sum: bigint;\r\n\r\n  constructor(value: bigint | string | number) {\r\n    this.value = typeof value === 'bigint' ? value : BigInt(value);\r\n    this.left = null;\r\n    this.right = null;\r\n    this.parent = null;\r\n    this.height = 1;\r\n    this.size = 1;\r\n    this.sum = this.value;\r\n  }\r\n\r\n  /**\r\n   * Updates node statistics based on children\r\n   */\r\n  updateStats(): void {\r\n    this.height = 1 + Math.max(\r\n      this.left?.height ?? 0,\r\n      this.right?.height ?? 0\r\n    );\r\n    this.size = 1 + (this.left?.size ?? 0) + (this.right?.size ?? 0);\r\n    this.sum = this.value + \r\n      (this.left?.sum ?? BigInt(0)) + \r\n      (this.right?.sum ?? BigInt(0));\r\n  }\r\n\r\n  /**\r\n   * Gets balance factor of the node\r\n   */\r\n  getBalance(): number {\r\n    return (this.left?.height ?? 0) - (this.right?.height ?? 0);\r\n  }\r\n\r\n  /**\r\n   * Gets complete statistics for the node and its subtree\r\n   */\r\n  getStats(): NodeStats {\r\n    return {\r\n      height: this.height,\r\n      size: this.size,\r\n      sum: this.sum,\r\n      min: this.findMin().value,\r\n      max: this.findMax().value\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Finds minimum value node in the subtree\r\n   */\r\n  findMin(): NumberNode {\r\n    let current: NumberNode = this;\r\n    while (current.left) {\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Finds maximum value node in the subtree\r\n   */\r\n  findMax(): NumberNode {\r\n    let current: NumberNode = this;\r\n    while (current.right) {\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n}\r\n\r\n/**\r\n * AVL Tree implementation specialized for handling large numbers\r\n */\r\nexport class NumberTree {\r\n  private root: NumberNode | null;\r\n  private readonly comparator: Comparator<bigint>;\r\n\r\n  constructor(comparator?: Comparator<bigint>) {\r\n    this.root = null;\r\n    this.comparator = comparator ?? ((a: bigint, b: bigint): -1 | 0 | 1 => {\r\n      if (a < b) return -1;\r\n      if (a > b) return 1;\r\n      return 0;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the root node if it exists\r\n   */\r\n  public getRoot(): NumberNode | null {\r\n    return this.root;\r\n  }\r\n\r\n  /**\r\n   * Inserts a new value into the tree\r\n   */\r\n  public insert(value: bigint | string | number): NumberNode {\r\n    const newValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    this.root = this.insertNode(this.root, newValue);\r\n    return this.find(newValue)!;\r\n  }\r\n\r\n  /**\r\n   * Recursively inserts a new node\r\n   */\r\n  private insertNode(node: NumberNode | null, value: bigint): NumberNode {\r\n    if (!node) {\r\n      return new NumberNode(value);\r\n    }\r\n\r\n    const compareResult = this.comparator(value, node.value);\r\n    if (compareResult < 0) {\r\n      node.left = this.insertNode(node.left, value);\r\n      node.left.parent = node;\r\n    } else if (compareResult > 0) {\r\n      node.right = this.insertNode(node.right, value);\r\n      node.right.parent = node;\r\n    } else {\r\n      return node; // Duplicate value, return existing node\r\n    }\r\n\r\n    node.updateStats();\r\n    return this.balance(node);\r\n  }\r\n\r\n  /**\r\n   * Balances a node using AVL rotations\r\n   */\r\n  private balance(node: NumberNode): NumberNode {\r\n    const balance = node.getBalance();\r\n\r\n    // Left heavy\r\n    if (balance > 1) {\r\n      if (node.left && node.left.getBalance() < 0) {\r\n        node.left = this.rotateLeft(node.left);\r\n      }\r\n      return this.rotateRight(node);\r\n    }\r\n\r\n    // Right heavy\r\n    if (balance < -1) {\r\n      if (node.right && node.right.getBalance() > 0) {\r\n        node.right = this.rotateRight(node.right);\r\n      }\r\n      return this.rotateLeft(node);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Performs left rotation\r\n   */\r\n  private rotateLeft(node: NumberNode): NumberNode {\r\n    const rightChild = node.right!;\r\n    const rightLeftChild = rightChild.left;\r\n\r\n    rightChild.left = node;\r\n    node.right = rightLeftChild;\r\n\r\n    if (rightLeftChild) {\r\n      rightLeftChild.parent = node;\r\n    }\r\n    rightChild.parent = node.parent;\r\n    node.parent = rightChild;\r\n\r\n    node.updateStats();\r\n    rightChild.updateStats();\r\n\r\n    return rightChild;\r\n  }\r\n\r\n  /**\r\n   * Performs right rotation\r\n   */\r\n  private rotateRight(node: NumberNode): NumberNode {\r\n    const leftChild = node.left!;\r\n    const leftRightChild = leftChild.right;\r\n\r\n    leftChild.right = node;\r\n    node.left = leftRightChild;\r\n\r\n    if (leftRightChild) {\r\n      leftRightChild.parent = node;\r\n    }\r\n    leftChild.parent = node.parent;\r\n    node.parent = leftChild;\r\n\r\n    node.updateStats();\r\n    leftChild.updateStats();\r\n\r\n    return leftChild;\r\n  }\r\n\r\n  /**\r\n   * Removes a value from the tree\r\n   */\r\n  public remove(value: bigint | string | number): boolean {\r\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    const nodeToRemove = this.find(searchValue);\r\n    \r\n    if (!nodeToRemove) {\r\n      return false;\r\n    }\r\n\r\n    this.root = this.removeNode(this.root, searchValue);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Recursively removes a node\r\n   */\r\n  private removeNode(node: NumberNode | null, value: bigint): NumberNode | null {\r\n    if (!node) {\r\n      return null;\r\n    }\r\n\r\n    const compareResult = this.comparator(value, node.value);\r\n    if (compareResult < 0) {\r\n      node.left = this.removeNode(node.left, value);\r\n      if (node.left) {\r\n        node.left.parent = node;\r\n      }\r\n    } else if (compareResult > 0) {\r\n      node.right = this.removeNode(node.right, value);\r\n      if (node.right) {\r\n        node.right.parent = node;\r\n      }\r\n    } else {\r\n      // Node to delete found\r\n      if (!node.left) {\r\n        return node.right;\r\n      }\r\n      if (!node.right) {\r\n        return node.left;\r\n      }\r\n\r\n      // Node has two children\r\n      const successor = node.right.findMin();\r\n      node.value = successor.value;\r\n      node.right = this.removeNode(node.right, successor.value);\r\n      if (node.right) {\r\n        node.right.parent = node;\r\n      }\r\n    }\r\n\r\n    node.updateStats();\r\n    return this.balance(node);\r\n  }\r\n\r\n  /**\r\n   * Finds a node by value\r\n   */\r\n  public find(value: bigint | string | number): NumberNode | null {\r\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    let current = this.root;\r\n\r\n    while (current) {\r\n      const compareResult = this.comparator(searchValue, current.value);\r\n      if (compareResult === 0) {\r\n        return current;\r\n      }\r\n      current = compareResult < 0 ? current.left : current.right;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Traverses the tree in specified order and returns values\r\n   */\r\n  public traverse(order: 'inOrder' | 'preOrder' | 'postOrder' = 'inOrder', \r\n                 config: TraversalConfig = {}): bigint[] {\r\n    const result: bigint[] = [];\r\n    \r\n    const traverse = (node: NumberNode | null, depth: number = 0): void => {\r\n      if (!node || (config.maxDepth !== undefined && depth >= config.maxDepth)) {\r\n        return;\r\n      }\r\n\r\n      if (order === 'preOrder') {\r\n        result.push(node.value);\r\n      }\r\n\r\n      if (!config.skipSubtrees) {\r\n        traverse(node.left, depth + 1);\r\n      }\r\n\r\n      if (order === 'inOrder') {\r\n        result.push(node.value);\r\n      }\r\n\r\n      if (!config.skipSubtrees) {\r\n        traverse(node.right, depth + 1);\r\n      }\r\n\r\n      if (order === 'postOrder') {\r\n        result.push(node.value);\r\n      }\r\n    };\r\n\r\n    traverse(this.root);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets overall tree statistics\r\n   */\r\n  public getTreeStats(): NodeStats | null {\r\n    return this.root?.getStats() ?? null;\r\n  }\r\n\r\n  /**\r\n   * Gets the nth smallest value in the tree\r\n   */\r\n  public getNthValue(n: number): bigint | null {\r\n    if (!this.root || n < 1 || n > this.root.size) {\r\n      return null;\r\n    }\r\n\r\n    const findNth = (node: NumberNode | null, position: number): bigint | null => {\r\n      if (!node) {\r\n        return null;\r\n      }\r\n\r\n      const leftSize = node.left?.size ?? 0;\r\n      \r\n      if (position === leftSize + 1) {\r\n        return node.value;\r\n      }\r\n      \r\n      if (position <= leftSize) {\r\n        return findNth(node.left, position);\r\n      }\r\n      \r\n      return findNth(node.right, position - leftSize - 1);\r\n    };\r\n\r\n    return findNth(this.root, n);\r\n  }\r\n\r\n  /**\r\n   * Gets a range of values between start and end (inclusive)\r\n   */\r\n  public getRange(start: bigint | string | number, \r\n                 end: bigint | string | number): bigint[] {\r\n    const startValue = typeof start === 'bigint' ? start : BigInt(start);\r\n    const endValue = typeof end === 'bigint' ? end : BigInt(end);\r\n    const result: bigint[] = [];\r\n\r\n    const collectRange = (node: NumberNode | null): void => {\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      if (this.comparator(node.value, startValue) >= 0 && \r\n          this.comparator(node.value, endValue) <= 0) {\r\n        collectRange(node.left);\r\n        result.push(node.value);\r\n        collectRange(node.right);\r\n      } else if (this.comparator(node.value, startValue) > 0) {\r\n        collectRange(node.left);\r\n      } else {\r\n        collectRange(node.right);\r\n      }\r\n    };\r\n\r\n    collectRange(this.root);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default NumberTree;","import { validateNonNegative, ValidationError, OverflowError } from '../utils/validation';\r\n\r\n/**\r\n * Interface for power tower computation options\r\n */\r\ninterface PowerTowerOptions {\r\n  maxHeight?: number;\r\n  maxValue?: bigint;\r\n  checkOverflow?: boolean;\r\n  precision?: number;\r\n}\r\n\r\n/**\r\n * Interface for power tower node to track computation state\r\n */\r\ninterface PowerTowerNode {\r\n  value: bigint;\r\n  height: number;\r\n  evaluated: boolean;\r\n  previous: PowerTowerNode | null;\r\n  next: PowerTowerNode | null;\r\n}\r\n\r\n/**\r\n * Default options for power tower computations\r\n */\r\nconst DEFAULT_OPTIONS: Required<PowerTowerOptions> = {\r\n  maxHeight: 100,\r\n  maxValue: BigInt(Number.MAX_SAFE_INTEGER),\r\n  checkOverflow: true,\r\n  precision: 0\r\n};\r\n\r\n/**\r\n * Class representing a power tower (tetration) computation structure\r\n * Handles expressions of the form: ab = a^(a^(a^...)) (b times)\r\n */\r\nexport class PowerTower {\r\n  private readonly options: Required<PowerTowerOptions>;\r\n  private head: PowerTowerNode | null;\r\n  private tail: PowerTowerNode | null;\r\n  private size: number;\r\n\r\n  constructor(options: PowerTowerOptions = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  /**\r\n   * Creates a new power tower node\r\n   */\r\n  private createNode(value: bigint, height: number): PowerTowerNode {\r\n    return {\r\n      value,\r\n      height,\r\n      evaluated: false,\r\n      previous: null,\r\n      next: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates power tower height\r\n   */\r\n  private validateHeight(height: number): void {\r\n    if (height < 0) {\r\n      throw new ValidationError('Height cannot be negative');\r\n    }\r\n    if (height > this.options.maxHeight) {\r\n      throw new ValidationError(`Height exceeds maximum of ${this.options.maxHeight}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates value for computation\r\n   */\r\n  private validateValue(value: bigint): void {\r\n    validateNonNegative(value);\r\n    if (this.options.checkOverflow && value > this.options.maxValue) {\r\n      throw new OverflowError(`Value exceeds maximum of ${this.options.maxValue}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes power with overflow checking\r\n   */\r\n  private computePower(base: bigint, exponent: bigint): bigint {\r\n    if (exponent === BigInt(0)) {\r\n      return BigInt(1);\r\n    }\r\n    if (exponent === BigInt(1)) {\r\n      return base;\r\n    }\r\n\r\n    let result = base;\r\n    for (let i = BigInt(1); i < exponent; i++) {\r\n      if (this.options.checkOverflow) {\r\n        // Check if next multiplication would overflow\r\n        const next = result * base;\r\n        if (next > this.options.maxValue) {\r\n          throw new OverflowError('Power computation would overflow');\r\n        }\r\n        result = next;\r\n      } else {\r\n        result *= base;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Builds a power tower of specified height with given base\r\n   */\r\n  public build(base: bigint | number | string, height: number): void {\r\n    this.validateHeight(height);\r\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\r\n    this.validateValue(baseValue);\r\n\r\n    this.clear(); // Clear existing tower\r\n\r\n    for (let i = 0; i < height; i++) {\r\n      const node = this.createNode(baseValue, i + 1);\r\n      if (!this.head) {\r\n        this.head = node;\r\n        this.tail = node;\r\n      } else {\r\n        node.previous = this.tail;\r\n        this.tail!.next = node;\r\n        this.tail = node;\r\n      }\r\n      this.size++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluates the power tower up to specified height\r\n   */\r\n  public evaluate(height?: number): bigint {\r\n    if (!this.head) {\r\n      return BigInt(1); // Empty tower evaluates to 1\r\n    }\r\n\r\n    const targetHeight = height ?? this.size;\r\n    this.validateHeight(targetHeight);\r\n\r\n    let current = this.head;\r\n    let result = current.value;\r\n    let currentHeight = 1;\r\n\r\n    try {\r\n      while (current.next && currentHeight < targetHeight) {\r\n        result = this.computePower(current.next.value, result);\r\n        current.evaluated = true;\r\n        current = current.next;\r\n        currentHeight++;\r\n      }\r\n      current.evaluated = true;\r\n      return result;\r\n    } catch (error) {\r\n      if (error instanceof OverflowError) {\r\n        // Mark nodes up to current height as evaluated\r\n        let node = this.head;\r\n        while (node !== current) {\r\n          node.evaluated = true;\r\n          node = node.next!;\r\n        }\r\n        throw error;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current height of the power tower\r\n   */\r\n  public getHeight(): number {\r\n    return this.size;\r\n  }\r\n\r\n  /**\r\n   * Checks if the tower can be evaluated to a given height\r\n   */\r\n  public isComputable(height?: number): boolean {\r\n    try {\r\n      const targetHeight = height ?? this.size;\r\n      this.validateHeight(targetHeight);\r\n      \r\n      // Check first few levels without full computation\r\n      let current = this.head;\r\n      let currentHeight = 0;\r\n      \r\n      while (current && currentHeight < targetHeight) {\r\n        // Quick check for obvious overflow conditions\r\n        if (current.value > BigInt(4) && currentHeight > 3) {\r\n          return false;\r\n        }\r\n        current = current.next;\r\n        currentHeight++;\r\n      }\r\n      \r\n      // Try actual computation with a lower overflow threshold\r\n      const safeOptions = { ...this.options, maxValue: this.options.maxValue >> BigInt(1) };\r\n      const safeTower = new PowerTower(safeOptions);\r\n      safeTower.build(this.head!.value, targetHeight);\r\n      safeTower.evaluate();\r\n      \r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the computation state at each level\r\n   */\r\n  public getState(): { height: number; value: bigint; evaluated: boolean }[] {\r\n    const state = [];\r\n    let current = this.head;\r\n    \r\n    while (current) {\r\n      state.push({\r\n        height: current.height,\r\n        value: current.value,\r\n        evaluated: current.evaluated\r\n      });\r\n      current = current.next;\r\n    }\r\n    \r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * Clears the power tower\r\n   */\r\n  public clear(): void {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  /**\r\n   * Gets the maximum computationally feasible height for a given base\r\n   */\r\n  public static getMaxFeasibleHeight(base: bigint | number | string): number {\r\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\r\n    validateNonNegative(baseValue);\r\n\r\n    if (baseValue === BigInt(0)) return 0;\r\n    if (baseValue === BigInt(1)) return Infinity;\r\n    if (baseValue === BigInt(2)) return 4; // 24 is already enormous\r\n    if (baseValue === BigInt(3)) return 3; // 33 is already astronomical\r\n    if (baseValue === BigInt(4)) return 2;\r\n    return 1; // For bases > 4, only height 1 is reliably computable\r\n  }\r\n\r\n  /**\r\n   * Creates a string representation of the power tower\r\n   */\r\n  public toString(): string {\r\n    if (!this.head) {\r\n      return \"Empty Tower\";\r\n    }\r\n\r\n    let result = this.head.value.toString();\r\n    let current = this.head;\r\n    \r\n    while (current.next) {\r\n      result = `${current.next.value}^(${result})`;\r\n      current = current.next;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PowerTower;","/**\r\n * Formatting utilities for Hypernum library\r\n * Provides functions for formatting large numbers and converting between different representations\r\n */\r\n\r\nimport { ValidationError } from './validation';\r\n\r\n// Types for formatting options\r\nexport interface FormatOptions {\r\n  notation?: 'standard' | 'scientific' | 'engineering' | 'compact';\r\n  precision?: number;\r\n  grouping?: boolean;\r\n  groupSize?: number;\r\n  decimalSeparator?: string;\r\n  groupSeparator?: string;\r\n}\r\n\r\nexport interface ScientificNotation {\r\n  coefficient: string;\r\n  exponent: number;\r\n}\r\n\r\nexport interface ScientificNotation {\r\n  coefficient: string;\r\n  exponent: number;\r\n}\r\n\r\n// Default formatting options\r\nconst DEFAULT_OPTIONS: Required<FormatOptions> = {\r\n  notation: 'standard',\r\n  precision: 0,\r\n  grouping: true,\r\n  groupSize: 3,\r\n  decimalSeparator: '.',\r\n  groupSeparator: ',',\r\n};\r\n\r\n/**\r\n * Formats a BigInt value according to specified options\r\n */\r\nexport const formatBigInt = (value: bigint, options: FormatOptions = {}): string => {\r\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\r\n  \r\n  // Handle negative numbers\r\n  const isNegative = value < BigInt(0);\r\n  const absValue = isNegative ? -value : value;\r\n  \r\n  let result: string;\r\n  switch (opts.notation) {\r\n    case 'scientific':\r\n      result = formatScientific(absValue, opts).coefficient + 'e' + \r\n               formatScientific(absValue, opts).exponent;\r\n      break;\r\n    case 'engineering':\r\n      result = formatEngineering(absValue, opts);\r\n      break;\r\n    case 'compact':\r\n      result = formatCompact(absValue, opts);\r\n      break;\r\n    default:\r\n      result = formatStandard(absValue, opts);\r\n  }\r\n  \r\n  return isNegative ? '-' + result : result;\r\n};\r\n\r\n/**\r\n * Formats a number in standard notation with grouping\r\n */\r\nconst formatStandard = (value: bigint, options: Required<FormatOptions>): string => {\r\n  let str = value.toString();\r\n  \r\n  if (!options.grouping) {\r\n    return str;\r\n  }\r\n  \r\n  // Apply grouping from the right\r\n  const result: string[] = [];\r\n  let position = str.length;\r\n  \r\n  while (position > 0) {\r\n    const start = Math.max(0, position - options.groupSize);\r\n    result.unshift(str.slice(start, position));\r\n    position = start;\r\n  }\r\n  \r\n  return result.join(options.groupSeparator);\r\n};\r\n\r\n/**\r\n * Converts a number to scientific notation\r\n */\r\nconst formatScientific = (value: bigint, options: Required<FormatOptions>): ScientificNotation => {\r\n  if (value === BigInt(0)) {\r\n    return { coefficient: '0', exponent: 0 };\r\n  }\r\n  \r\n  const str = value.toString();\r\n  const exponent = str.length - 1;\r\n  \r\n  let coefficient = str[0] || '';\r\n  coefficient += options.decimalSeparator + str.slice(1, options.precision + 1);\r\n  \r\n  return {\r\n    coefficient: coefficient,\r\n    exponent: exponent,\r\n  };\r\n};\r\n\r\n/**\r\n * Formats a number in engineering notation (exponents divisible by 3)\r\n */\r\nconst formatEngineering = (value: bigint, options: Required<FormatOptions>): string => {\r\n  if (value === BigInt(0)) {\r\n    return '0';\r\n  }\r\n  \r\n  const str = value.toString();\r\n  const len = str.length;\r\n  const exponent = Math.floor((len - 1) / 3) * 3;\r\n  \r\n  let coefficient = '';\r\n  const digitsBeforePoint = len - exponent;\r\n  \r\n  for (let i = 0; i < Math.min(len, digitsBeforePoint + options.precision); i++) {\r\n    if (i === digitsBeforePoint && i < len) {\r\n      coefficient += options.decimalSeparator;\r\n    }\r\n    coefficient += str[i];\r\n  }\r\n  \r\n  return `${coefficient}e${exponent}`;\r\n};\r\n\r\n/**\r\n * Formats a number in compact notation (K, M, B, T)\r\n */\r\nconst formatCompact = (value: bigint, options: Required<FormatOptions>): string => {\r\n  const suffixes = ['', 'K', 'M', 'B', 'T', 'Q'];\r\n  const str = value.toString();\r\n  const len = str.length;\r\n  \r\n  if (len <= 3) {\r\n    return formatStandard(value, options);\r\n  }\r\n  \r\n  const suffixIndex = Math.min(Math.floor((len - 1) / 3), suffixes.length - 1);\r\n  const suffix = suffixes[suffixIndex];\r\n  \r\n  const scale = BigInt(10) ** BigInt(suffixIndex * 3);\r\n  const scaledValue = value / scale;\r\n  \r\n  let result = scaledValue.toString();\r\n  if (options.precision > 0) {\r\n    const remainder = value % scale;\r\n    if (remainder > BigInt(0)) {\r\n      const decimalPart = remainder.toString().padStart(3, '0').slice(0, options.precision);\r\n      result += options.decimalSeparator + decimalPart;\r\n    }\r\n  }\r\n  \r\n  return result + suffix;\r\n};\r\n\r\n/**\r\n * Parses a formatted string back to BigInt\r\n */\r\nexport const parseBigIntString = (str: string, options: FormatOptions = {}): bigint => {\r\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\r\n  \r\n  // Remove grouping separators\r\n  let cleanStr = str.replace(new RegExp(`\\\\${opts.groupSeparator}`, 'g'), '');\r\n  \r\n  // Handle scientific notation\r\n  if (cleanStr.toLowerCase().includes('e')) {\r\n    const [coefficient, exponent] = cleanStr.toLowerCase().split('e');\r\n    const base = BigInt(10);\r\n    const exp = BigInt(exponent || '0');\r\n    return BigInt(Math.floor(Number(coefficient))) * (base ** exp);\r\n  }\r\n  \r\n  // Handle suffixes\r\n  const suffixMap = new Map([\r\n    ['k', BigInt(1000)],\r\n    ['m', BigInt(1000000)],\r\n    ['b', BigInt(1000000000)],\r\n    ['t', BigInt(1000000000000)],\r\n    ['q', BigInt(1000000000000000)],\r\n  ]);\r\n  \r\n  const suffix = cleanStr.slice(-1).toLowerCase();\r\n  const multiplier = suffixMap.get(suffix);\r\n  if (multiplier) {\r\n    cleanStr = cleanStr.slice(0, -1);\r\n    const value = BigInt(Math.floor(Number(cleanStr)));\r\n    return value * multiplier;\r\n  }\r\n  \r\n  // Handle regular numbers\r\n  return BigInt(cleanStr);\r\n};\r\n\r\n/**\r\n * Normalizes a string representation for comparison\r\n */\r\nexport const normalizeNumberString = (str: string): string => {\r\n  // Remove all spaces and separators\r\n  str = str.replace(/[\\s,]/g, '');\r\n  \r\n  // Handle scientific notation\r\n  if (str.toLowerCase().includes('e')) {\r\n    const [coefficient, exponent] = str.toLowerCase().split('e');\r\n    const exp = parseInt(exponent || '0');\r\n    const coef = parseFloat(coefficient || '0');\r\n    return (coef * Math.pow(10, exp)).toString();\r\n  }\r\n  \r\n  return str;\r\n};\r\n\r\n/**\r\n * Formats a number for display in a tree structure\r\n */\r\nexport const formatTreeValue = (value: bigint, depth: number = 0): string => {\r\n  const indent = '  '.repeat(depth);\r\n  return `${indent}${formatBigInt(value, { notation: 'compact' })}`;\r\n};\r\n\r\n/**\r\n * Formats a range of numbers for display\r\n */\r\nexport const formatRange = (start: bigint, end: bigint, options: FormatOptions = {}): string => {\r\n  return `[${formatBigInt(start, options)} ... ${formatBigInt(end, options)}]`;\r\n};\r\n\r\n/**\r\n * Formats a percentage\r\n */\r\nexport const formatPercentage = (value: bigint, total: bigint, precision: number = 2): string => {\r\n  if (total === BigInt(0)) {\r\n    throw new ValidationError('Cannot calculate percentage with zero total');\r\n  }\r\n  \r\n  const percentage = (Number(value) * 100) / Number(total);\r\n  return `${percentage.toFixed(precision)}%`;\r\n};","/**\r\n * Main Hypernum class that provides a high-level interface to all library functionality\r\n */\r\n\r\n\r\nimport {\r\n  DEFAULT_OPTIONS,\r\n  FEATURES,\r\n  MAX_PRECISION,\r\n  MAX_COMPUTATION_STEPS\r\n} from './constants';\r\nimport { \r\n  HypernumError, \r\n  ValidationError, \r\n  OverflowError \r\n} from './errors';\r\n\r\n\r\n// Import all operations and structures\r\nimport * as arithmetic from '../operations/arithmetic';\r\nimport * as bitwise from '../operations/bitwise';\r\nimport * as power from '../operations/power';\r\nimport { BigArray, NumberTree, AckermannStructure } from '../structures';\r\nimport * as formatting from '../utils/formatting';\r\nimport * as validation from '../utils/validation';\r\nimport * as precision from '../utils/precision';\r\nimport { MinHeap, MaxHeap } from '@/storage';\r\n/**\r\n * Configuration options for Hypernum instance\r\n */\r\nexport interface HypernumConfig {\r\n  precision?: number;\r\n  roundingMode?: precision.RoundingMode;\r\n  checkOverflow?: boolean;\r\n  maxSteps?: number;\r\n  debug?: boolean;\r\n}\r\n\r\nexport class Hypernum {\r\n  private readonly config: Required<HypernumConfig>;\r\n  private readonly structures: {\r\n    arrays: Map<string, BigArray<bigint>>;\r\n    trees: Map<string, NumberTree>;\r\n    heaps: Map<string, MinHeap<bigint> | MaxHeap<bigint>>;\r\n  };\r\n\r\n  constructor(config: HypernumConfig = {}) {\r\n    this.config = {\r\n      precision: config.precision ?? DEFAULT_OPTIONS.precision,\r\n      roundingMode: config.roundingMode ?? DEFAULT_OPTIONS.roundingMode as precision.RoundingMode,\r\n      checkOverflow: config.checkOverflow ?? DEFAULT_OPTIONS.checkOverflow,\r\n      maxSteps: config.maxSteps ?? DEFAULT_OPTIONS.maxSteps,\r\n      debug: config.debug ?? FEATURES.DEBUG_MODE\r\n    };\r\n\r\n    // Validate configuration\r\n    if (this.config.precision < 0 || this.config.precision > MAX_PRECISION) {\r\n      throw new ValidationError(`Precision must be between 0 and ${MAX_PRECISION}`);\r\n    }\r\n    if (this.config.maxSteps < 1 || this.config.maxSteps > MAX_COMPUTATION_STEPS) {\r\n      throw new ValidationError(`Max steps must be between 1 and ${MAX_COMPUTATION_STEPS}`);\r\n    }\r\n\r\n    // Initialize data structure storage\r\n    this.structures = {\r\n      arrays: new Map(),\r\n      trees: new Map(),\r\n      heaps: new Map()\r\n    };\r\n  }\r\n\r\n  // Arithmetic Operations\r\n  public add(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.add(a, b, this.config);\r\n  }\r\n\r\n  public subtract(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.subtract(a, b, this.config);\r\n  }\r\n\r\n  public multiply(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.multiply(a, b, this.config);\r\n  }\r\n\r\n  public divide(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.divide(a, b, this.config);\r\n  }\r\n\r\n  public mod(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.remainder(a, b, this.config);\r\n  }\r\n\r\n  // Power Operations\r\n  public power(base: bigint | string | number, exponent: bigint | string | number): bigint {\r\n    return power.power(base, exponent, this.config);\r\n  }\r\n\r\n  public sqrt(value: bigint | string | number): bigint {\r\n    return power.sqrt(value, this.config);\r\n  }\r\n\r\n  public nthRoot(value: bigint | string | number, n: bigint | string | number): bigint {\r\n    return power.nthRoot(value, n, this.config);\r\n  }\r\n\r\n  // Bitwise Operations\r\n  public and(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return bitwise.and(a, b);\r\n  }\r\n\r\n  public or(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return bitwise.or(a, b);\r\n  }\r\n\r\n  public xor(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return bitwise.xor(a, b);\r\n  }\r\n\r\n  public not(value: bigint | string | number): bigint {\r\n    return bitwise.not(value);\r\n  }\r\n /**\r\n   * Calculates the greatest common divisor of two numbers\r\n   */\r\n public gcd(a: bigint | string | number, b: bigint | string | number): bigint {\r\n  return arithmetic.gcd(a, b);\r\n}\r\n\r\n/**\r\n * Calculates the least common multiple of two numbers\r\n */\r\npublic lcm(a: bigint | string | number, b: bigint | string | number): bigint {\r\n  return arithmetic.lcm(a, b);\r\n}\r\n  // Data Structure Management\r\n  public createArray(id: string): BigArray<bigint> {\r\n    if (this.structures.arrays.has(id)) {\r\n      throw new ValidationError(`Array with id '${id}' already exists`);\r\n    }\r\n    const array = new BigArray<bigint>();\r\n    this.structures.arrays.set(id, array);\r\n    return array;\r\n  }\r\n\r\n  public getArray(id: string): BigArray<bigint> {\r\n    const array = this.structures.arrays.get(id);\r\n    if (!array) {\r\n      throw new ValidationError(`Array with id '${id}' not found`);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  public createTree(id: string): NumberTree {\r\n    if (this.structures.trees.has(id)) {\r\n      throw new ValidationError(`Tree with id '${id}' already exists`);\r\n    }\r\n    const tree = new NumberTree();\r\n    this.structures.trees.set(id, tree);\r\n    return tree;\r\n  }\r\n\r\n  public getTree(id: string): NumberTree {\r\n    const tree = this.structures.trees.get(id);\r\n    if (!tree) {\r\n      throw new ValidationError(`Tree with id '${id}' not found`);\r\n    }\r\n    return tree;\r\n  }\r\n\r\n  public createHeap(id: string, isMinHeap: boolean = true): MinHeap<bigint> | MaxHeap<bigint> {\r\n    if (this.structures.heaps.has(id)) {\r\n      throw new ValidationError(`Heap with id '${id}' already exists`);\r\n    }\r\n    const heap = isMinHeap ? new MinHeap<bigint>(this.compareValues) : new MaxHeap<bigint>(this.compareValues);\r\n    this.structures.heaps.set(id, heap);\r\n    return heap;\r\n  }\r\n\r\n  public getHeap(id: string): MinHeap<bigint> | MaxHeap<bigint> {\r\n    const heap = this.structures.heaps.get(id);\r\n    if (!heap) {\r\n      throw new ValidationError(`Heap with id '${id}' not found`);\r\n    }\r\n    return heap;\r\n  }\r\n\r\n  // Special Functions\r\n  public createAckermannStructure(): AckermannStructure {\r\n    return new AckermannStructure();\r\n  }\r\n\r\n  // Formatting and Validation\r\n  public format(value: bigint | string | number, options?: formatting.FormatOptions): string {\r\n    const bigValue = validation.toBigInt(value);\r\n    return formatting.formatBigInt(bigValue, options);\r\n  }\r\n\r\n  public validate(value: unknown): boolean {\r\n    try {\r\n      validation.toBigInt(value);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Configuration Management\r\n  public updateConfig(newConfig: Partial<HypernumConfig>): void {\r\n    Object.assign(this.config, newConfig);\r\n  }\r\n\r\n  public getConfig(): Readonly<Required<HypernumConfig>> {\r\n    return { ...this.config };\r\n  }\r\n\r\n  // Utility Functions\r\n  private compareValues(a: bigint, b: bigint): -1 | 0 | 1 {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n  }\r\n\r\n  // Cleanup\r\n  public dispose(): void {\r\n    this.structures.arrays.clear();\r\n    this.structures.trees.clear();\r\n    this.structures.heaps.clear();\r\n  }\r\n}\r\n\r\n// Export additional types and utilities\r\nexport {\r\n  HypernumError,\r\n  ValidationError,\r\n  OverflowError,\r\n  precision,\r\n  formatting,\r\n  validation\r\n};\r\n\r\nexport default Hypernum;","/**\r\n * Comparison operations module for Hypernum library\r\n * Provides functions for comparing large numbers with precision support\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    normalizePrecision,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for comparison operations\r\n   */\r\n  export interface ComparisonOptions {\r\n    precision?: number;\r\n    roundingMode?: RoundingMode;\r\n    tolerance?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ComparisonOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    tolerance: 0\r\n  };\r\n  \r\n  /**\r\n   * Result type for comparison operations\r\n   * -1: first value is less than second value\r\n   *  0: values are equal\r\n   *  1: first value is greater than second value\r\n   */\r\n  export type ComparisonResult = -1 | 0 | 1;\r\n  \r\n  /**\r\n   * Compares two numbers with optional precision\r\n   */\r\n  export function compare(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): ComparisonResult {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.precision === 0 && opts.tolerance === 0) {\r\n      if (bigA < bigB) return -1;\r\n      if (bigA > bigB) return 1;\r\n      return 0;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    \r\n    if (opts.tolerance > 0) {\r\n      const diff = scaledA - scaledB;\r\n      const toleranceValue = BigInt(10) ** BigInt(opts.tolerance);\r\n      \r\n      if (diff < -toleranceValue) return -1;\r\n      if (diff > toleranceValue) return 1;\r\n      return 0;\r\n    }\r\n  \r\n    if (scaledA < scaledB) return -1;\r\n    if (scaledA > scaledB) return 1;\r\n    return 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if two numbers are equal\r\n   */\r\n  export function equals(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is less than second\r\n   */\r\n  export function lessThan(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === -1;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is less than or equal to second\r\n   */\r\n  export function lessThanOrEqual(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    const result = compare(a, b, options);\r\n    return result === -1 || result === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is greater than second\r\n   */\r\n  export function greaterThan(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === 1;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is greater than or equal to second\r\n   */\r\n  export function greaterThanOrEqual(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    const result = compare(a, b, options);\r\n    return result === 1 || result === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if a number is between two others (inclusive)\r\n   */\r\n  export function between(\r\n    value: bigint | string | number,\r\n    min: bigint | string | number,\r\n    max: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return greaterThanOrEqual(value, min, options) && lessThanOrEqual(value, max, options);\r\n  }\r\n  \r\n  /**\r\n   * Finds the maximum value in an array of numbers\r\n   */\r\n  export function max(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    if (values.length === 0) {\r\n      throw new ValidationError('Cannot find maximum of empty array');\r\n    }\r\n  \r\n    return values.reduce<bigint>((max, current) => {\r\n      const bigMax = toBigInt(max);\r\n      const bigCurrent = toBigInt(current);\r\n      return greaterThan(bigCurrent, bigMax, options) ? bigCurrent : bigMax;\r\n    }, toBigInt(values[0]));\r\n  }\r\n  \r\n  /**\r\n   * Finds the minimum value in an array of numbers\r\n   */\r\n  export function min(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    if (values.length === 0) {\r\n      throw new ValidationError('Cannot find minimum of empty array');\r\n    }\r\n  \r\n    return values.reduce<bigint>((min, current) => {\r\n      const bigMin = toBigInt(min);\r\n      const bigCurrent = toBigInt(current);\r\n      return lessThan(bigCurrent, bigMin, options) ? bigCurrent : bigMin;\r\n    }, toBigInt(values[0]));\r\n  }\r\n  \r\n  /**\r\n   * Clamps a value between minimum and maximum bounds\r\n   */\r\n  export function clamp(\r\n    value: bigint | string | number,\r\n    min: bigint | string | number,\r\n    max: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    const bigValue = toBigInt(value);\r\n    const bigMin = toBigInt(min);\r\n    const bigMax = toBigInt(max);\r\n  \r\n    if (lessThan(bigMax, bigMin, options)) {\r\n      throw new ValidationError('Maximum bound must be greater than or equal to minimum bound');\r\n    }\r\n  \r\n    if (lessThan(bigValue, bigMin, options)) return bigMin;\r\n    if (greaterThan(bigValue, bigMax, options)) return bigMax;\r\n    return bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Checks if all values in array are equal within tolerance\r\n   */\r\n  export function allEqual(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    const first = toBigInt(values[0]);\r\n    return values.every(value => equals(value, first, options));\r\n  }\r\n  \r\n  /**\r\n   * Checks if values are in ascending order\r\n   */\r\n  export function isAscending(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    for (let i = 1; i < values.length; i++) {\r\n      if (values[i] === undefined || values[i - 1] === undefined || !greaterThanOrEqual(values[i]!, values[i - 1]!, options)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Checks if values are in descending order\r\n   */\r\n  export function isDescending(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    for (let i = 1; i < values.length; i++) {\r\n      if (values[i] === undefined || values[i - 1] === undefined || !lessThanOrEqual(values[i]!, values[i - 1]!, options)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Creates a comparator function for sorting\r\n   */\r\n  export function createComparator(\r\n    options: ComparisonOptions = {}\r\n  ): (a: bigint | string | number, b: bigint | string | number) => number {\r\n    return (a, b) => compare(a, b, options);\r\n  }\r\n  \r\n  export default {\r\n    compare,\r\n    equals,\r\n    lessThan,\r\n    lessThanOrEqual,\r\n    greaterThan,\r\n    greaterThanOrEqual,\r\n    between,\r\n    max,\r\n    min,\r\n    clamp,\r\n    allEqual,\r\n    isAscending,\r\n    isDescending,\r\n    createComparator\r\n  };","/**\r\n * Conversion operations module for Hypernum library\r\n * Provides functions for converting numbers between different formats and bases\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for conversion operations\r\n   */\r\n  export interface ConversionOptions {\r\n    /** Precision for decimal operations */\r\n    precision?: number;\r\n    /** Rounding mode for decimal operations */\r\n    roundingMode?: RoundingMode;\r\n    /** Whether to use uppercase for hex/base-N output */\r\n    uppercase?: boolean;\r\n    /** Whether to add prefix for base-N output (0x, 0b, etc.) */\r\n    prefix?: boolean;\r\n    /** Minimum number of digits (pad with zeros) */\r\n    minDigits?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ConversionOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    uppercase: false,\r\n    prefix: false,\r\n    minDigits: 1\r\n  };\r\n  \r\n  /**\r\n   * Converts number to binary string representation\r\n   */\r\n  export function toBinary(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let binary = bigValue.toString(2);\r\n    \r\n    // Pad with zeros if needed\r\n    while (binary.length < opts.minDigits) {\r\n      binary = '0' + binary;\r\n    }\r\n    \r\n    return opts.prefix ? '0b' + binary : binary;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to octal string representation\r\n   */\r\n  export function toOctal(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let octal = bigValue.toString(8);\r\n    \r\n    while (octal.length < opts.minDigits) {\r\n      octal = '0' + octal;\r\n    }\r\n    \r\n    return opts.prefix ? '0o' + octal : octal;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to hexadecimal string representation\r\n   */\r\n  export function toHexadecimal(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let hex = bigValue.toString(16);\r\n    \r\n    if (opts.uppercase) {\r\n      hex = hex.toUpperCase();\r\n    }\r\n    \r\n    while (hex.length < opts.minDigits) {\r\n      hex = '0' + hex;\r\n    }\r\n    \r\n    return opts.prefix ? '0x' + hex : hex;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to string in specified base\r\n   */\r\n  export function toBase(\r\n    value: bigint | string | number,\r\n    base: number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    if (base < 2 || base > 36) {\r\n      throw new ValidationError('Base must be between 2 and 36');\r\n    }\r\n    \r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let result = bigValue.toString(base);\r\n    \r\n    if (opts.uppercase) {\r\n      result = result.toUpperCase();\r\n    }\r\n    \r\n    while (result.length < opts.minDigits) {\r\n      result = '0' + result;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Converts string from specified base to bigint\r\n   */\r\n  export function fromBase(\r\n    value: string,\r\n    base: number\r\n  ): bigint {\r\n    if (base < 2 || base > 36) {\r\n      throw new ValidationError('Base must be between 2 and 36');\r\n    }\r\n    \r\n    // Remove base prefixes if present\r\n    const cleanValue = value.toLowerCase()\r\n      .replace(/^0x/, '')  // hex\r\n      .replace(/^0b/, '')  // binary\r\n      .replace(/^0o/, ''); // octal\r\n    \r\n    try {\r\n      return BigInt(`${base}n${cleanValue}`);\r\n    } catch (error) {\r\n      throw new ValidationError(`Invalid number format for base ${base}: ${value}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Converts decimal string to fraction representation\r\n   */\r\n  export function toFraction(\r\n    value: string,\r\n  ): [bigint, bigint] {\r\n    \r\n    // Split into integer and decimal parts\r\n    const [intPart, decPart = ''] = value.split('.');\r\n    \r\n    if (!decPart) {\r\n      return [toBigInt(intPart), 1n];\r\n    }\r\n    \r\n    // Convert decimal to fraction\r\n    const numerator = toBigInt(intPart + decPart);\r\n    const denominator = 10n ** BigInt(decPart.length);\r\n    \r\n    // Simplify fraction\r\n    const gcd = calculateGCD(numerator, denominator);\r\n    \r\n    return [numerator / gcd, denominator / gcd];\r\n  }\r\n  \r\n  /**\r\n   * Converts fraction to decimal string with specified precision\r\n   */\r\n  export function fromFraction(\r\n    numerator: bigint | string | number,\r\n    denominator: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigNumerator = toBigInt(numerator);\r\n    const bigDenominator = toBigInt(denominator);\r\n    \r\n    if (bigDenominator === 0n) {\r\n      throw new ValidationError('Denominator cannot be zero');\r\n    }\r\n    \r\n    const quotient = bigNumerator / bigDenominator;\r\n    const remainder = bigNumerator % bigDenominator;\r\n    \r\n    if (remainder === 0n || opts.precision === 0) {\r\n      return quotient.toString();\r\n    }\r\n    \r\n    // Calculate decimal part\r\n    const scaleFactor = 10n ** BigInt(opts.precision);\r\n    const scaledRemainder = (remainder * scaleFactor) / bigDenominator;\r\n    \r\n    return `${quotient}.${scaledRemainder.toString().padStart(opts.precision, '0')}`;\r\n  }\r\n  \r\n  /**\r\n   * Converts scientific notation to decimal string\r\n   */\r\n  export function fromScientific(\r\n    value: string,\r\n  ): string {\r\n    \r\n    // Parse scientific notation format\r\n    const match = value.match(/^(-?\\d+\\.?\\d*)[eE]([+-]?\\d+)$/);\r\n    if (!match) {\r\n      throw new ValidationError('Invalid scientific notation format');\r\n    }\r\n    \r\n    const [, significand, exponent] = match;\r\n    const exp = parseInt(exponent || '0', 10);\r\n    \r\n    // Convert to regular decimal\r\n    if (exp >= 0) {\r\n      if (significand === undefined) {\r\n        throw new ValidationError('Invalid scientific notation format');\r\n      }\r\n      return (BigInt(significand.replace('.', '')) * (10n ** BigInt(exp))).toString();\r\n    } else {\r\n      const absExp = Math.abs(exp);\r\n      if (significand === undefined) {\r\n        throw new ValidationError('Invalid scientific notation format');\r\n      }\r\n      const scaledValue = BigInt(significand.replace('.', ''));\r\n      return (scaledValue / (10n ** BigInt(absExp))).toString();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Converts decimal to scientific notation\r\n   */\r\n  export function toScientific(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return '0e0';\r\n    }\r\n    \r\n    const str = bigValue.toString();\r\n    const firstDigit = str[0] === '-' ? str[1] : str[0];\r\n    const exponent = str.length - (str[0] === '-' ? 2 : 1);\r\n    \r\n    let result = firstDigit;\r\n    if (str.length > 1) {\r\n      const restDigits = str.slice(str[0] === '-' ? 2 : 1);\r\n      if (opts.precision > 0) {\r\n        result += '.' + restDigits.slice(0, opts.precision);\r\n      }\r\n    }\r\n    \r\n    if (str[0] === '-') {\r\n      result = '-' + result;\r\n    }\r\n    \r\n    return `${result}e${exponent}`;\r\n  }\r\n  \r\n  /**\r\n   * Calculates Greatest Common Divisor (helper function)\r\n   */\r\n  function calculateGCD(a: bigint, b: bigint): bigint {\r\n    a = a < 0n ? -a : a;\r\n    b = b < 0n ? -b : b;\r\n    \r\n    while (b !== 0n) {\r\n      const temp = b;\r\n      b = a % b;\r\n      a = temp;\r\n    }\r\n    \r\n    return a;\r\n  }\r\n  \r\n\r\n  /**\r\n * Converts Roman numeral to number\r\n */\r\nexport function fromRoman(value: string): bigint {\r\n    const romanValues = new Map<string, number>([\r\n      ['I', 1],\r\n      ['V', 5],\r\n      ['X', 10],\r\n      ['L', 50],\r\n      ['C', 100],\r\n      ['D', 500],\r\n      ['M', 1000]\r\n    ]);\r\n  \r\n    let result = 0;\r\n    let prevValue = 0;\r\n  \r\n    // Process from right to left\r\n    for (let i = value.length - 1; i >= 0; i--) {\r\n      const char = value[i]?.toUpperCase() ?? '';\r\n      const current = romanValues.get(char);\r\n  \r\n      if (current === undefined) {\r\n        throw new ValidationError(`Invalid Roman numeral character: ${char}`);\r\n      }\r\n  \r\n      if (current >= prevValue) {\r\n        result += current;\r\n      } else {\r\n        result -= current;\r\n      }\r\n  \r\n      prevValue = current;\r\n    }\r\n  \r\n    return BigInt(result);\r\n  }\r\n  \r\n  /**\r\n   * Converts number to Roman numeral\r\n   */\r\n  export function toRoman(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const num = Number(toBigInt(value));\r\n  \r\n    if (num <= 0 || num > 3999) {\r\n      throw new ValidationError('Number must be between 1 and 3999 for Roman numerals');\r\n    }\r\n  \r\n    // Define symbol pairs with proper typing\r\n    type RomanPair = [string, string];\r\n    type RomanSingle = [string];\r\n    type RomanSymbol = RomanPair | RomanSingle;\r\n  \r\n    const romanSymbols: RomanSymbol[] = [\r\n      ['I', 'V'], // ones\r\n      ['X', 'L'], // tens\r\n      ['C', 'D'], // hundreds\r\n      ['M']       // thousands\r\n    ];\r\n  \r\n    let result = '';\r\n    let position = 0;\r\n    let remaining = num;\r\n  \r\n    while (remaining > 0) {\r\n      const digit = remaining % 10;\r\n      const symbols = romanSymbols[position];\r\n  \r\n      if (!symbols) {\r\n        break; // Safety check for position overflow\r\n      }\r\n  \r\n      const unit = symbols[0];\r\n      const five = symbols[1] ?? '';\r\n      const next = position < 3 ? romanSymbols[position + 1]?.[0] ?? '' : '';\r\n  \r\n      let digitStr = '';\r\n      if (digit === 9 && next) {\r\n        digitStr = unit + next;\r\n      } else if (digit >= 5 && five) {\r\n        digitStr = five + unit.repeat(digit - 5);\r\n      } else if (digit === 4 && five) {\r\n        digitStr = unit + five;\r\n      } else {\r\n        digitStr = unit.repeat(digit);\r\n      }\r\n  \r\n      result = digitStr + result;\r\n      remaining = Math.floor(remaining / 10);\r\n      position++;\r\n    }\r\n  \r\n    return opts.uppercase ? result : result.toLowerCase();\r\n  }\r\n  export default {\r\n    toBinary,\r\n    toOctal,\r\n    toHexadecimal,\r\n    toBase,\r\n    fromBase,\r\n    toFraction,\r\n    fromFraction,\r\n    fromScientific,\r\n    toScientific,\r\n    fromRoman,\r\n    toRoman\r\n  };","/**\r\n * Factorial operations module for Hypernum library\r\n * Provides efficient implementations for factorial and related computations\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    OverflowError,\r\n    validateNonNegative\r\n  } from '../utils/validation';\r\n  \r\n  /**\r\n   * Options for factorial operations\r\n   */\r\n  export interface FactorialOptions {\r\n    /** Maximum allowed computation value */\r\n    maxValue?: number;\r\n    /** Whether to check for overflow */\r\n    checkOverflow?: boolean;\r\n    /** Cache computed values */\r\n    useCache?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<FactorialOptions> = {\r\n    maxValue: 1000,\r\n    checkOverflow: true,\r\n    useCache: true\r\n  };\r\n  \r\n  // Cache for factorial values\r\n  const factorialCache = new Map<bigint, bigint>();\r\n  \r\n  /**\r\n   * Calculates factorial of a number (n!)\r\n   */\r\n  export function factorial(\r\n    value: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n  \r\n    validateNonNegative(n);\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Factorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    // Handle base cases\r\n    if (n <= 1n) {\r\n      return 1n;\r\n    }\r\n  \r\n    // Check cache\r\n    if (opts.useCache && factorialCache.has(n)) {\r\n      return factorialCache.get(n)!;\r\n    }\r\n  \r\n    // Calculate factorial\r\n    let result = 1n;\r\n    for (let i = 2n; i <= n; i++) {\r\n      result *= i;\r\n    }\r\n  \r\n    // Cache result\r\n    if (opts.useCache) {\r\n      factorialCache.set(n, result);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates binomial coefficient (n choose k)\r\n   */\r\n  export function binomial(\r\n    n: bigint | string | number,\r\n    k: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigN = toBigInt(n);\r\n    const bigK = toBigInt(k);\r\n  \r\n    validateNonNegative(bigN);\r\n    validateNonNegative(bigK);\r\n  \r\n    if (bigK > bigN) {\r\n      throw new ValidationError('K cannot be greater than N in binomial coefficient');\r\n    }\r\n  \r\n    // Optimize for k > n/2 by using symmetry\r\n    if (bigK > bigN / 2n) {\r\n      return binomial(bigN, bigN - bigK, opts);\r\n    }\r\n  \r\n    // Use multiplicative formula instead of factorial for efficiency\r\n    let result = 1n;\r\n    for (let i = 0n; i < bigK; i++) {\r\n      result = (result * (bigN - i)) / (i + 1n);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates subfactorial (derangement number)\r\n   * Number of permutations of n elements with no fixed points\r\n   */\r\n  export function subfactorial(\r\n    value: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n  \r\n    validateNonNegative(n);\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Subfactorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    // Handle base cases\r\n    if (n === 0n) return 1n;\r\n    if (n === 1n) return 0n;\r\n  \r\n    // Use recursive formula !n = n * !(n-1) + (-1)^n\r\n    let result = 0n;\r\n    const nFact = factorial(n, opts);\r\n  \r\n    for (let k = 0n; k <= n; k++) {\r\n      const term = factorial(n - k, opts) * (k % 2n === 0n ? 1n : -1n);\r\n      result += term;\r\n    }\r\n  \r\n    return nFact - result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates rising factorial (Pochhammer symbol)\r\n   * x^(n) = x(x+1)(x+2)...(x+n-1)\r\n   */\r\n  export function risingFactorial(\r\n    x: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigX = toBigInt(x);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigN);\r\n  \r\n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Rising factorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    let result = 1n;\r\n    for (let i = 0n; i < bigN; i++) {\r\n      result *= (bigX + i);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates falling factorial\r\n   * x_(n) = x(x-1)(x-2)...(x-n+1)\r\n   */\r\n  export function fallingFactorial(\r\n    x: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigX = toBigInt(x);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigN);\r\n  \r\n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Falling factorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    let result = 1n;\r\n    for (let i = 0n; i < bigN; i++) {\r\n      result *= (bigX - i);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates multifactorial (n!!)\r\n   * Product of numbers from 1 to n that leave the same remainder as n when divided by k\r\n   */\r\n  export function multiFactorial(\r\n    value: bigint | string | number,\r\n    k: bigint | string | number = 2n,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n    const bigK = toBigInt(k);\r\n  \r\n    validateNonNegative(n);\r\n    if (bigK <= 0n) {\r\n      throw new ValidationError('K must be positive in multifactorial');\r\n    }\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Multifactorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    let result = 1n;\r\n    let current = n;\r\n  \r\n    while (current > 0n) {\r\n      result *= current;\r\n      current -= bigK;\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates primorial (product of primes up to n)\r\n   */\r\n  export function primorial(\r\n    value: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n  \r\n    validateNonNegative(n);\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Primorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    if (n <= 1n) return 1n;\r\n  \r\n    // Generate primes up to n using Sieve of Eratosthenes\r\n    const num = Number(n);\r\n    const sieve = new Array(num + 1).fill(true);\r\n    sieve[0] = sieve[1] = false;\r\n  \r\n    for (let i = 2; i * i <= num; i++) {\r\n      if (sieve[i]) {\r\n        for (let j = i * i; j <= num; j += i) {\r\n          sieve[j] = false;\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Calculate product of all primes up to n\r\n    let result = 1n;\r\n    for (let i = 2; i <= num; i++) {\r\n      if (sieve[i]) {\r\n        result *= BigInt(i);\r\n      }\r\n    }\r\n  \r\n    return result;\r\n  }\r\n\r\n  \r\n  \r\n  export default {\r\n    factorial,\r\n    binomial,\r\n    subfactorial,\r\n    risingFactorial,\r\n    fallingFactorial,\r\n    multiFactorial,\r\n    primorial\r\n  };","/**\r\n * Hypernum - A TypeScript/JavaScript library for large number operations\r\n */\r\n\r\nimport { HypernumConfig, mergeConfig, validateConfig } from './core';\r\nimport { Hypernum } from './core/hypernum';\r\nimport { RoundingMode } from './utils/precision';\r\n\r\n// Package version\r\nconst VERSION: string = '0.1.0';\r\n\r\n// Core exports\r\nexport { Hypernum } from './core/hypernum';\r\nexport * from './core/constants';\r\nexport * from './core/common';\r\nexport * from './core/config';\r\n\r\n// Re-export errors with explicit names to avoid conflicts\r\nexport { \r\n  HypernumError,\r\n  ComputationLimitError,\r\n  DataStructureError,\r\n  DivisionByZeroError,\r\n  FormatError,\r\n  HeapPropertyError,\r\n  IndexError,\r\n  PrecisionError,\r\n  RomanNumeralError,\r\n  TreeError,\r\n  UnderflowError\r\n} from './core/errors';\r\n\r\n// Data structures with explicit imports and exports\r\nexport { AckermannStructure } from './structures/ackermann';\r\nexport { BigArray, type BigArrayOptions } from './structures/big-array';\r\nexport { NumberTree } from './structures/number-tree';\r\nexport { PowerTower } from './structures/power-tower';\r\nexport { MinHeap, MaxHeap, type Comparator } from './storage/';\r\n\r\n// Operations with explicit exports\r\nexport {\r\n  add,\r\n  subtract,\r\n  multiply,\r\n  divide,\r\n  remainder,\r\n  abs,\r\n  sign,\r\n  gcd,\r\n  lcm\r\n} from './operations/arithmetic';\r\n\r\nexport {\r\n  and,\r\n  or,\r\n  xor,\r\n  not,\r\n  leftShift,\r\n  rightShift,\r\n  unsignedRightShift,\r\n  rotateLeft,\r\n  rotateRight,\r\n  popCount,\r\n  trailingZeros,\r\n  leadingZeros,\r\n  getBit,\r\n  setBit,\r\n  clearBit,\r\n  toggleBit\r\n} from './operations/bitwise';\r\n\r\nexport {\r\n  compare,\r\n  equals,\r\n  lessThan,\r\n  lessThanOrEqual,\r\n  greaterThan,\r\n  greaterThanOrEqual,\r\n  between,\r\n  max,\r\n  min,\r\n  clamp,\r\n  allEqual,\r\n  isAscending,\r\n  isDescending,\r\n  createComparator\r\n} from './operations/comparison';\r\n\r\nexport {\r\n  toBinary,\r\n  toOctal,\r\n  toHexadecimal,\r\n  toBase,\r\n  fromBase,\r\n  toFraction,\r\n  fromFraction,\r\n  fromScientific,\r\n  toScientific,\r\n  fromRoman,\r\n  toRoman\r\n} from './operations/conversion';\r\n\r\nexport {\r\n  factorial,\r\n  binomial,\r\n  subfactorial,\r\n  risingFactorial,\r\n  fallingFactorial,\r\n  multiFactorial,\r\n  primorial\r\n} from './operations/factorial';\r\n\r\nexport {\r\n  power,\r\n  sqrt,\r\n  nthRoot,\r\n  tetration,\r\n  superRoot\r\n} from './operations/power';\r\n\r\n// Utils with explicit exports\r\nexport {\r\n  toBigInt,\r\n  validateNonNegative,\r\n  validatePositive,\r\n  checkAdditionOverflow,\r\n  checkMultiplicationOverflow,\r\n  checkPowerOverflow\r\n} from './utils/validation';\r\n\r\nexport {\r\n  formatBigInt,\r\n  parseBigIntString,\r\n  normalizeNumberString\r\n} from './utils/formatting';\r\n\r\nexport {\r\n  RoundingMode,\r\n  round,\r\n  scaleByPowerOfTen,\r\n  scaledDivision,\r\n  normalizePrecision\r\n} from './utils/precision';\r\n\r\n/**\r\n * Creates a new Hypernum instance with custom configuration\r\n */\r\nexport function createHypernum(config?: Partial<HypernumConfig>): Hypernum {\r\n  const mergedConfig = mergeConfig(config || {});\r\n  validateConfig(mergedConfig);\r\n  \r\n  const instanceConfig = {\r\n    precision: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.defaultPrecision \r\n      : mergedConfig.precision ?? 0,\r\n    roundingMode: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.defaultRoundingMode \r\n      : (mergedConfig.roundingMode as RoundingMode) ?? RoundingMode.HALF_EVEN,\r\n    checkOverflow: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.checkOverflow \r\n      : mergedConfig.checkOverflow ?? true,\r\n    maxSteps: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.maxComputationSteps \r\n      : mergedConfig.maxSteps ?? 1000,\r\n    debug: 'debug' in mergedConfig && typeof mergedConfig.debug === 'object' \r\n      ? mergedConfig.debug.verbose \r\n      : false\r\n  };\r\n  \r\n  return new Hypernum(instanceConfig);\r\n}\r\n\r\n// Default instance\r\nexport const defaultHypernum = createHypernum();\r\n\r\n// Export version\r\nexport { VERSION };\r\n\r\n// Default export\r\nexport default Hypernum;"],"names":["Error","constructor","message","super","this","name","OverflowError","toBigInt","value","isBigInt","test","isValidNumberString","ValidationError","BigInt","isNaN","isFinite","isValidNumber","Number","isInteger","checkAdditionOverflow","a","b","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","checkMultiplicationOverflow","maxValue","minValue","checkPowerOverflow","base","exponent","validateNonNegative","RoundingMode","scaleByPowerOfTen","power","round","precision","mode","HALF_EVEN","scale","scaled","remainder","FLOOR","CEIL","DOWN","UP","HALF_UP","HALF_DOWN","normalizePrecision","precisionA","precisionB","targetPrecision","Math","max","scaledDivision","numerator","denominator","roundingMode","scaledNumerator","DEFAULT_BASIC_CONFIG","checkOverflow","maxSteps","debug","DEFAULT_FULL_CONFIG","arithmetic","defaultPrecision","defaultRoundingMode","maxComputationSteps","autoPrecision","enabled","maxPrecision","minPrecision","constants","cache","algorithm","dataStructures","array","initialCapacity","growthFactor","maxSize","tree","maxDepth","autoBalance","nodeLimit","heap","growthPolicy","validatePropertyOnOperation","ttl","evictionPolicy","persistToDisk","compressionEnabled","formatting","notation","grouping","groupSize","decimalSeparator","groupSeparator","uppercase","scientific","minExponent","maxSignificantDigits","exponentSeparator","engineering","useSIPrefixes","localization","locale","useLocaleGrouping","performance","enableTracking","samplingRate","thresholds","warnThresholdMs","errorThresholdMs","maxMemoryBytes","metrics","timing","memory","verbose","trackPerformance","logLevel","features","experimentalFeatures","useWasm","workerThreads","sharedArrayBuffer","bigIntTypedArrays","isFullConfig","config","isBasicConfig","validateConfig","validateFullConfig","undefined","validateBasicConfig","mergeConfig","custom","fullConfig","MAX_COMPUTATION_STEPS","ZERO","ONE","TWO","TEN","NEGATIVE_ONE","MAX_POWER_BASE","MAX_POWER_EXPONENT","MAX_TETRATION_HEIGHT","MAX_FACTORIAL_INPUT","ERROR_MESSAGES","OVERFLOW","UNDERFLOW","NEGATIVE_ROOT","NEGATIVE_EXPONENT","DIVISION_BY_ZERO","INVALID_PRECISION","INVALID_BASE","INVALID_ROMAN","COMPUTATION_LIMIT","NEGATIVE_INDEX","TREE_DEPTH_EXCEEDED","INVALID_HEAP_PROPERTY","FEATURES","OVERFLOW_CHECKING","AUTOMATIC_PRECISION","MEMOIZATION","TREE_BALANCING","DEBUG_MODE","DEFAULT_OPTIONS","HypernumError","Object","setPrototypeOf","prototype","UnderflowError","DivisionByZeroError","PrecisionError","ComputationLimitError","DataStructureError","HeapPropertyError","TreeError","IndexError","FormatError","RomanNumeralError","add","options","opts","bigA","bigB","scaledA","scaledB","subtract","multiply","result","divide","bigNumerator","bigDenominator","abs","bigValue","gcd","temp","lcm","maxBits","strict","validateShift","shift","and","or","xor","not","leftShift","bigShift","unsignedRightShift","baseValue","exponentValue","bigBase","bigExponent","steps","sqrt","lastGuess","guess","nthRoot","n","bigN","nMinus1","tetration","height","bigHeight","i","Heap","comparator","compare","size","length","isEmpty","peek","push","siftUp","pop","root","last","siftDown","clear","heapify","MinHeap","MaxHeap","forEach","item","getParentIndex","index","floor","getLeftChildIndex","getRightChildIndex","swap","j","parentIndex","smallest","left","right","largest","AckermannStructure","nodes","Map","maxComputedM","maxComputedN","getNodeKey","m","computeAckermann","key","existing","get","inner","innerNum","error","RangeError","addNode","has","node","set","prevMKey","prevNKey","prevM","nextM","prevN","nextN","buildRange","mRange","nRange","getComputationPath","path","current","nextValue","safeNextValue","reverse","analyzeGrowthRate","growth","prevValue","increase","multiplier","getLargestValue","getValue","BigArray","capacity","data","Array","segmentTree","fill","getSize","getCapacity","resize","newCapacity","newData","rebuildSegmentTree","updateSegmentTree","success","oldValue","buildSegmentTree","start","end","mid","leftNode","rightNode","currentNode","queryRange","querySegmentTree","queryStart","queryEnd","leftResult","rightResult","toHeap","isMin","sort","ascending","toArray","slice","NumberNode","parent","sum","updateStats","getBalance","getStats","min","findMin","findMax","NumberTree","getRoot","insert","newValue","insertNode","find","compareResult","balance","rotateLeft","rotateRight","rightChild","rightLeftChild","leftChild","leftRightChild","remove","searchValue","removeNode","successor","traverse","order","depth","skipSubtrees","getTreeStats","getNthValue","findNth","position","leftSize","getRange","startValue","endValue","collectRange","maxHeight","PowerTower","head","tail","createNode","evaluated","previous","next","validateHeight","validateValue","computePower","build","evaluate","targetHeight","currentHeight","getHeight","isComputable","safeOptions","safeTower","getState","state","getMaxFeasibleHeight","Infinity","toString","formatBigInt","isNegative","absValue","formatScientific","coefficient","formatEngineering","formatCompact","formatStandard","str","unshift","join","len","digitsBeforePoint","suffixes","suffixIndex","suffix","decimalPart","padStart","Hypernum","structures","arrays","trees","heaps","arithmetic.add","arithmetic.subtract","arithmetic.multiply","arithmetic.divide","mod","arithmetic.remainder","power.power","power.sqrt","power.nthRoot","bitwise.and","bitwise.or","bitwise.xor","bitwise.not","arithmetic.gcd","arithmetic.lcm","createArray","id","getArray","createTree","getTree","createHeap","isMinHeap","compareValues","getHeap","createAckermannStructure","format","validation.toBigInt","formatting.formatBigInt","validate","updateConfig","newConfig","assign","getConfig","dispose","tolerance","diff","toleranceValue","equals","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","prefix","minDigits","useCache","factorialCache","factorial","createHypernum","mergedConfig","instanceConfig","defaultHypernum","symbol","WARN_THRESHOLD_MS","ERROR_THRESHOLD_MS","MAX_ARRAY_SIZE","MAX_TREE_SIZE","values","first","every","binomial","k","bigK","bigMin","bigMax","bigPosition","x","bigX","cleanValue","toLowerCase","replace","quotient","romanValues","char","toUpperCase","match","significand","exp","parseInt","absExp","count","msb","reduce","bigCurrent","includes","split","parseFloat","pow","cleanStr","RegExp","suffixMap","num","sieve","rotation","bigRotation","rightPart","nFact","binary","intPart","decPart","calculateGCD","hex","octal","romanSymbols","remaining","digit","symbols","unit","five","digitStr","repeat","firstDigit","restDigits"],"mappings":"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"}