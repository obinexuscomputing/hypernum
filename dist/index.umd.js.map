{"version":3,"file":"index.umd.js","sources":["../src/utils/validation.ts","../src/utils/precision.ts","../src/core/config.ts","../src/core/constants.ts","../src/core/errors.ts","../src/operations/arithmetic.ts","../src/operations/bitwise.ts","../src/operations/power.ts","../src/storage/Heap.ts","../src/structures/Ackermann.ts","../src/structures/NumberTree.ts","../src/structures/BigArray.ts","../src/structures/PowerTower.ts","../src/utils/formatting.ts","../src/core/hypernum.ts","../src/operations/comparison.ts","../src/operations/conversion.ts","../src/operations/factorial.ts","../src/index.ts"],"sourcesContent":["/**\r\n * Validation utilities for Hypernum library\r\n * Provides type checking and validation functions for large number operations\r\n */\r\n\r\n// Custom error types for validation\r\nexport class ValidationError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'ValidationError';\r\n    }\r\n  }\r\n  \r\n  export class OverflowError extends Error {\r\n    constructor(message: string) {\r\n      super(message);\r\n      this.name = 'OverflowError';\r\n    }\r\n  }\r\n  \r\n  // Type guards\r\n  export const isBigInt = (value: unknown): value is bigint => {\r\n    return typeof value === 'bigint';\r\n  };\r\n  \r\n  export const isValidNumberString = (value: string): boolean => {\r\n    return /^-?\\d+$/.test(value);\r\n  };\r\n  \r\n  export const isValidNumber = (value: unknown): value is number => {\r\n    return typeof value === 'number' && !isNaN(value) && isFinite(value);\r\n  };\r\n  \r\n  // Type conversions with validation\r\n  export const toBigInt = (value: unknown): bigint => {\r\n    if (isBigInt(value)) {\r\n      return value;\r\n    }\r\n    \r\n    if (typeof value === 'string') {\r\n      if (!isValidNumberString(value)) {\r\n        throw new ValidationError(`Invalid number string: ${value}`);\r\n      }\r\n      return BigInt(value);\r\n    }\r\n    \r\n    if (isValidNumber(value)) {\r\n      if (!Number.isInteger(value)) {\r\n        throw new ValidationError('Cannot convert non-integer number to BigInt');\r\n      }\r\n      return BigInt(value);\r\n    }\r\n    \r\n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`);\r\n  };\r\n  \r\n  // Range validation\r\n  export const validateRange = (value: bigint, min?: bigint, max?: bigint): void => {\r\n    if (min !== undefined && value < min) {\r\n      throw new ValidationError(`Value ${value} is below minimum ${min}`);\r\n    }\r\n    if (max !== undefined && value > max) {\r\n      throw new ValidationError(`Value ${value} exceeds maximum ${max}`);\r\n    }\r\n  };\r\n  \r\n  // Operation safety checks\r\n  export const checkAdditionOverflow = (a: bigint, b: bigint): void => {\r\n    // Check if addition would overflow\r\n    if (b > 0 && a > BigInt(Number.MAX_SAFE_INTEGER) - b) {\r\n      throw new OverflowError('Addition would overflow');\r\n    }\r\n    if (b < 0 && a < BigInt(Number.MIN_SAFE_INTEGER) - b) {\r\n      throw new OverflowError('Addition would underflow');\r\n    }\r\n  };\r\n  \r\n  export const checkMultiplicationOverflow = (a: bigint, b: bigint): void => {\r\n    // Check if multiplication would overflow\r\n    if (a !== BigInt(0) && b !== BigInt(0)) {\r\n      const maxValue = BigInt(Number.MAX_SAFE_INTEGER);\r\n      const minValue = BigInt(Number.MIN_SAFE_INTEGER);\r\n      \r\n      if (a > maxValue / b || a < minValue / b) {\r\n        throw new OverflowError('Multiplication would overflow');\r\n      }\r\n    }\r\n  };\r\n  \r\n  export const checkPowerOverflow = (base: bigint, exponent: bigint): void => {\r\n    // Basic overflow checks for exponentiation\r\n    if (exponent < BigInt(0)) {\r\n      throw new ValidationError('Negative exponents not supported for integers');\r\n    }\r\n    \r\n    if (base === BigInt(0) && exponent === BigInt(0)) {\r\n      throw new ValidationError('Zero raised to zero is undefined');\r\n    }\r\n    \r\n    if (exponent > BigInt(1000)) {\r\n      throw new OverflowError('Exponent too large, computation would overflow');\r\n    }\r\n  };\r\n  \r\n  // Array and data structure validation\r\n  export const validateArrayLength = (length: number): void => {\r\n    if (!Number.isInteger(length) || length < 0) {\r\n      throw new ValidationError('Array length must be a non-negative integer');\r\n    }\r\n    if (length > Number.MAX_SAFE_INTEGER) {\r\n      throw new ValidationError('Array length exceeds maximum safe integer');\r\n    }\r\n  };\r\n  \r\n  export const validateArrayIndex = (index: number, length: number): void => {\r\n    if (!Number.isInteger(index)) {\r\n      throw new ValidationError('Array index must be an integer');\r\n    }\r\n    if (index < 0 || index >= length) {\r\n      throw new ValidationError('Array index out of bounds');\r\n    }\r\n  };\r\n  \r\n  // Tree validation\r\n  export const validateTreeNode = (value: unknown): void => {\r\n    try {\r\n      toBigInt(value);\r\n    } catch (error) {\r\n      throw new ValidationError('Invalid tree node value');\r\n    }\r\n  };\r\n  \r\n  // Heap validation\r\n  export const validateHeapProperty = <T>(\r\n    value: T,\r\n    parent: T | undefined,\r\n    comparator: (a: T, b: T) => -1 | 0 | 1,\r\n    isMinHeap: boolean\r\n  ): void => {\r\n    if (!parent) return;\r\n    \r\n    const comparison = comparator(value, parent);\r\n    if (isMinHeap && comparison < 0) {\r\n      throw new ValidationError('Min heap property violated');\r\n    }\r\n    if (!isMinHeap && comparison > 0) {\r\n      throw new ValidationError('Max heap property violated');\r\n    }\r\n  };\r\n  \r\n  // Ackermann function validation\r\n  export const validateAckermannInput = (m: number, n: number): void => {\r\n    if (!Number.isInteger(m) || !Number.isInteger(n)) {\r\n      throw new ValidationError('Ackermann inputs must be integers');\r\n    }\r\n    if (m < 0 || n < 0) {\r\n      throw new ValidationError('Ackermann inputs must be non-negative');\r\n    }\r\n    if (m > 4) {\r\n      throw new ValidationError('First Ackermann parameter too large for computation');\r\n    }\r\n  };\r\n  \r\n  // General numeric validation utilities\r\n  export const isInRange = (value: bigint, min: bigint, max: bigint): boolean => {\r\n    return value >= min && value <= max;\r\n  };\r\n  \r\n  export const isPowerOfTwo = (value: bigint): boolean => {\r\n    return value > BigInt(0) && (value & (value - BigInt(1))) === BigInt(0);\r\n  };\r\n  \r\n  export const validatePositive = (value: bigint): void => {\r\n    if (value <= BigInt(0)) {\r\n      throw new ValidationError('Value must be positive');\r\n    }\r\n  };\r\n  \r\n  export const validateNonNegative = (value: bigint): void => {\r\n    if (value < BigInt(0)) {\r\n      throw new ValidationError('Value must be non-negative');\r\n    }\r\n  };","/**\r\n * Precision utilities for Hypernum library\r\n * Provides functions for handling decimal precision and rounding operations\r\n */\r\n\r\nimport { ValidationError } from './validation';\r\n\r\n/**\r\n * Rounding modes for decimal operations\r\n */\r\nexport enum RoundingMode {\r\n  FLOOR = 'FLOOR',           // Round towards negative infinity\r\n  CEIL = 'CEIL',             // Round towards positive infinity\r\n  DOWN = 'DOWN',             // Round towards zero\r\n  UP = 'UP',                 // Round away from zero\r\n  HALF_EVEN = 'HALF_EVEN',   // Round to nearest even number when tied (Banker's rounding)\r\n  HALF_UP = 'HALF_UP',       // Round up when tied\r\n  HALF_DOWN = 'HALF_DOWN',   // Round down when tied\r\n}\r\n\r\n/**\r\n * Scale a bigint by a power of 10\r\n */\r\nexport const scaleByPowerOfTen = (value: bigint, power: number): bigint => {\r\n  if (power === 0) return value;\r\n  if (power > 0) {\r\n    return value * (BigInt(10) ** BigInt(power));\r\n  }\r\n  return value / (BigInt(10) ** BigInt(-power));\r\n};\r\n\r\n/**\r\n * Round a number according to specified mode and precision\r\n */\r\nexport const round = (\r\n  value: bigint,\r\n  precision: number = 0,\r\n  mode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  if (precision === 0) {\r\n    return value;\r\n  }\r\n\r\n  const scale = BigInt(10) ** BigInt(precision);\r\n  const scaled = value / scale;\r\n  const remainder = value % scale;\r\n\r\n  switch (mode) {\r\n    case RoundingMode.FLOOR:\r\n      return scaled * scale;\r\n\r\n    case RoundingMode.CEIL:\r\n      return remainder > 0n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.DOWN:\r\n      return value >= 0n ? scaled * scale : (scaled - 1n) * scale;\r\n\r\n    case RoundingMode.UP:\r\n      return value >= 0n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_UP:\r\n      return remainder >= scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_DOWN:\r\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    case RoundingMode.HALF_EVEN:\r\n      if (remainder === scale / 2n) {\r\n        return scaled % 2n === 0n ? scaled * scale : (scaled + 1n) * scale;\r\n      }\r\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\r\n\r\n    default:\r\n      throw new ValidationError('Invalid rounding mode');\r\n  }\r\n};\r\n\r\n/**\r\n * Calculate precision required to represent a number without loss\r\n */\r\nexport const calculateRequiredPrecision = (value: bigint): number => {\r\n  if (value === 0n) return 0;\r\n  \r\n  const str = value.toString();\r\n  const nonZeroIndex = str.split('').reverse().findIndex(char => char !== '0');\r\n  return nonZeroIndex === -1 ? 0 : nonZeroIndex;\r\n};\r\n\r\n/**\r\n * Normalize two numbers to the same precision\r\n */\r\nexport const normalizePrecision = (\r\n  a: bigint,\r\n  b: bigint,\r\n  precisionA: number,\r\n  precisionB: number\r\n): [bigint, bigint] => {\r\n  const targetPrecision = Math.max(precisionA, precisionB);\r\n  \r\n  const scaledA = scaleByPowerOfTen(a, targetPrecision - precisionA);\r\n  const scaledB = scaleByPowerOfTen(b, targetPrecision - precisionB);\r\n  \r\n  return [scaledA, scaledB];\r\n};\r\n\r\n/**\r\n * Scale a division operation to achieve desired precision\r\n */\r\nexport const scaledDivision = (\r\n  numerator: bigint,\r\n  denominator: bigint,\r\n  precision: number,\r\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (denominator === 0n) {\r\n    throw new ValidationError('Division by zero');\r\n  }\r\n\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  // Scale up numerator to handle desired precision\r\n  const scaledNumerator = scaleByPowerOfTen(numerator, precision);\r\n  const quotient = scaledNumerator / denominator;\r\n  \r\n  return round(quotient, 0, roundingMode);\r\n};\r\n\r\n/**\r\n * Calculate the number of significant digits\r\n */\r\nexport const significantDigits = (value: bigint): number => {\r\n  const nonZeroPattern = /[1-9]/;\r\n  const str = value.toString();\r\n  const firstSignificant = str.search(nonZeroPattern);\r\n  if (firstSignificant === -1) return 0;\r\n  \r\n  const lastSignificant = str.split('').reverse().findIndex(char => char !== '0');\r\n  return str.length - firstSignificant - (lastSignificant === -1 ? 0 : lastSignificant);\r\n};\r\n\r\n/**\r\n * Truncate to specified number of significant digits\r\n */\r\nexport const truncateToSignificantDigits = (\r\n  value: bigint,\r\n  digits: number,\r\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\r\n): bigint => {\r\n  if (digits <= 0) {\r\n    throw new ValidationError('Number of significant digits must be positive');\r\n  }\r\n\r\n  const currentDigits = significantDigits(value);\r\n  \r\n  if (currentDigits <= digits) {\r\n    return value;\r\n  }\r\n\r\n  const scale = currentDigits - digits;\r\n  return round(value, scale, roundingMode);\r\n};\r\n\r\n/**\r\n * Check if two numbers are equal within a specified precision\r\n */\r\nexport const equalWithinPrecision = (\r\n  a: bigint,\r\n  b: bigint,\r\n  precision: number\r\n): boolean => {\r\n  const diff = a - b;\r\n  const tolerance = BigInt(10) ** BigInt(precision);\r\n  return diff.toString().length <= tolerance.toString().length;\r\n};\r\n\r\n/**\r\n * Get the fractional part of a number at a given precision\r\n */\r\nexport const getFractionalPart = (\r\n  value: bigint,\r\n  precision: number\r\n): bigint => {\r\n  if (precision <= 0) return 0n;\r\n  \r\n  const scale = BigInt(10) ** BigInt(precision);\r\n  return value % scale;\r\n};\r\n\r\n/**\r\n * Format a number with exact precision (no rounding)\r\n */\r\nexport const toExactPrecision = (value: bigint, precision: number): string => {\r\n  if (precision < 0) {\r\n    throw new ValidationError('Precision must be non-negative');\r\n  }\r\n\r\n  let str = value.toString();\r\n  const isNegative = str.startsWith('-');\r\n  if (isNegative) {\r\n    str = str.slice(1);\r\n  }\r\n\r\n  while (str.length <= precision) {\r\n    str = '0' + str;\r\n  }\r\n\r\n  const integerPart = str.slice(0, -precision) || '0';\r\n  const fractionalPart = str.slice(-precision);\r\n\r\n  return `${isNegative ? '-' : ''}${integerPart}.${fractionalPart}`;\r\n};","/**\r\n * Configuration type definitions for Hypernum library\r\n * Defines all configuration options and their default values\r\n */\r\n\r\nimport { RoundingMode } from '../utils/precision';\r\nimport { \r\n  FormatOptions,\r\n  DebugConfig,\r\n  CacheConfig,\r\n  MathConstantsConfig\r\n} from './common';\r\n\r\n/**\r\n * Basic configuration options for simple usage\r\n */\r\nexport interface BasicConfig {\r\n  /** Decimal precision for operations */\r\n  precision?: number;\r\n  /** Rounding mode for decimal operations */\r\n  roundingMode?: RoundingMode;\r\n  /** Whether to check for overflow */\r\n  checkOverflow?: boolean;\r\n  /** Maximum allowed computation steps */\r\n  maxSteps?: number;\r\n  /** Enable debug mode */\r\n  debug?: boolean;\r\n}\r\n\r\n/**\r\n * Configuration for arithmetic operations\r\n */\r\nexport interface ArithmeticConfig {\r\n  /** Default precision for decimal operations */\r\n  defaultPrecision: number;\r\n  /** Default rounding mode */\r\n  defaultRoundingMode: RoundingMode;\r\n  /** Whether to check for overflow by default */\r\n  checkOverflow: boolean;\r\n  /** Maximum steps for iterative calculations */\r\n  maxComputationSteps: number;\r\n  /** Configure automatic precision adjustment */\r\n  autoPrecision: {\r\n    enabled: boolean;\r\n    maxPrecision: number;\r\n    minPrecision: number;\r\n  };\r\n  /** Constants calculation configuration */\r\n  constants: MathConstantsConfig;\r\n}\r\n\r\n/**\r\n * Configuration for data structures\r\n */\r\nexport interface DataStructuresConfig {\r\n  /** Array configuration */\r\n  array: {\r\n    initialCapacity: number;\r\n    growthFactor: number;\r\n    maxSize: number;\r\n  };\r\n  /** Tree configuration */\r\n  tree: {\r\n    maxDepth: number;\r\n    autoBalance: boolean;\r\n    nodeLimit: number;\r\n  };\r\n  /** Heap configuration */\r\n  heap: {\r\n    initialCapacity: number;\r\n    growthPolicy: 'double' | 'linear' | 'fibonacci';\r\n    validatePropertyOnOperation: boolean;\r\n  };\r\n  /** Cache configuration */\r\n  cache: CacheConfig & {\r\n    enabled: boolean;\r\n    persistToDisk: boolean;\r\n    compressionEnabled: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration for number formatting\r\n */\r\nexport interface FormattingConfig extends FormatOptions {\r\n  /** Scientific notation configuration */\r\n  scientific: {\r\n    /** Minimum exponent to trigger scientific notation */\r\n    minExponent: number;\r\n    /** Maximum significant digits */\r\n    maxSignificantDigits: number;\r\n    /** Exponent separator character */\r\n    exponentSeparator: string;\r\n  };\r\n  /** Engineering notation configuration */\r\n  engineering: {\r\n    /** Use SI prefixes */\r\n    useSIPrefixes: boolean;\r\n    /** Custom unit definitions */\r\n    customUnits?: Map<number, string>;\r\n  };\r\n  /** Localization settings */\r\n  localization: {\r\n    /** Locale identifier */\r\n    locale: string;\r\n    /** Custom number formatting */\r\n    numberFormat?: Intl.NumberFormatOptions;\r\n    /** Use locale-specific grouping */\r\n    useLocaleGrouping: boolean;\r\n  };\r\n}\r\n\r\n/**\r\n * Configuration for performance monitoring\r\n */\r\nexport interface PerformanceConfig {\r\n  /** Enable performance tracking */\r\n  enableTracking: boolean;\r\n  /** Sampling rate for metrics (0-1) */\r\n  samplingRate: number;\r\n  /** Performance thresholds */\r\n  thresholds: {\r\n    /** Warning threshold in milliseconds */\r\n    warnThresholdMs: number;\r\n    /** Error threshold in milliseconds */\r\n    errorThresholdMs: number;\r\n    /** Maximum allowed memory usage in bytes */\r\n    maxMemoryBytes: number;\r\n  };\r\n  /** Metrics collection configuration */\r\n  metrics: {\r\n    /** Enable detailed operation timing */\r\n    timing: boolean;\r\n    /** Track memory usage */\r\n    memory: boolean;\r\n    /** Track cache performance */\r\n    cache: boolean;\r\n    /** Custom metrics to track */\r\n    custom?: Map<string, (operation: any) => number>;\r\n  };\r\n}\r\n\r\n/**\r\n * Feature flags for optional functionality\r\n */\r\nexport interface FeatureFlags {\r\n  /** Enable experimental features */\r\n  experimentalFeatures: boolean;\r\n  /** Use WebAssembly implementations when available */\r\n  useWasm: boolean;\r\n  /** Enable worker thread support */\r\n  workerThreads: boolean;\r\n  /** Enable SharedArrayBuffer support */\r\n  sharedArrayBuffer: boolean;\r\n  /** Enable BigInt64Array support */\r\n  bigIntTypedArrays: boolean;\r\n}\r\n\r\n/**\r\n * Full configuration interface with all options\r\n */\r\nexport interface FullConfig {\r\n  /** Arithmetic operation configuration */\r\n  arithmetic: ArithmeticConfig;\r\n  /** Data structure configuration */\r\n  dataStructures: DataStructuresConfig;\r\n  /** Formatting configuration */\r\n  formatting: FormattingConfig;\r\n  /** Performance configuration */\r\n  performance: PerformanceConfig;\r\n  /** Debug configuration */\r\n  debug: DebugConfig;\r\n  /** Feature flags */\r\n  features: FeatureFlags;\r\n  /** Custom configuration options */\r\n  custom?: Map<string, any>;\r\n}\r\n\r\n/**\r\n * Converts FullConfig to BasicConfig if necessary\r\n */\r\nexport function convertToBasicConfig(config: HypernumConfig): BasicConfig {\r\n  if (isBasicConfig(config)) {\r\n    return config;\r\n  }\r\n  return {\r\n    precision: config.arithmetic.defaultPrecision,\r\n    roundingMode: config.arithmetic.defaultRoundingMode,\r\n    checkOverflow: config.arithmetic.checkOverflow,\r\n    maxSteps: config.arithmetic.maxComputationSteps,\r\n    debug: config.debug.verbose\r\n  };\r\n}\r\n\r\n/**\r\n * Combined configuration type that can be either basic or full\r\n */\r\nexport type HypernumConfig = BasicConfig | FullConfig;\r\n\r\n/**\r\n * Default configuration values for basic config\r\n */\r\nexport const DEFAULT_BASIC_CONFIG: Required<BasicConfig> = {\r\n  precision: 0,\r\n  roundingMode: RoundingMode.HALF_EVEN,\r\n  checkOverflow: true,\r\n  maxSteps: 1000,\r\n  debug: false\r\n};\r\n\r\n/**\r\n * Full default configuration values\r\n */\r\nexport const DEFAULT_FULL_CONFIG: FullConfig = {\r\n  arithmetic: {\r\n    defaultPrecision: 0,\r\n    defaultRoundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true,\r\n    maxComputationSteps: 1000,\r\n    autoPrecision: {\r\n      enabled: true,\r\n      maxPrecision: 100,\r\n      minPrecision: 0\r\n    },\r\n    constants: {\r\n      precision: 50,\r\n      cache: true,\r\n      algorithm: 'series'\r\n    }\r\n  },\r\n  dataStructures: {\r\n    array: {\r\n      initialCapacity: 16,\r\n      growthFactor: 2,\r\n      maxSize: 1_000_000\r\n    },\r\n    tree: {\r\n      maxDepth: 1000,\r\n      autoBalance: true,\r\n      nodeLimit: 1_000_000\r\n    },\r\n    heap: {\r\n      initialCapacity: 16,\r\n      growthPolicy: 'double',\r\n      validatePropertyOnOperation: true\r\n    },\r\n    cache: {\r\n      enabled: true,\r\n      maxSize: 1000,\r\n      ttl: 3600000, // 1 hour\r\n      evictionPolicy: 'LRU',\r\n      persistToDisk: false,\r\n      compressionEnabled: false\r\n    }\r\n  },\r\n  formatting: {\r\n    notation: 'standard',\r\n    precision: 0,\r\n    grouping: true,\r\n    groupSize: 3,\r\n    decimalSeparator: '.',\r\n    groupSeparator: ',',\r\n    uppercase: false,\r\n    scientific: {\r\n      minExponent: 6,\r\n      maxSignificantDigits: 6,\r\n      exponentSeparator: 'e'\r\n    },\r\n    engineering: {\r\n      useSIPrefixes: true\r\n    },\r\n    localization: {\r\n      locale: 'en-US',\r\n      useLocaleGrouping: false\r\n    }\r\n  },\r\n  performance: {\r\n    enableTracking: false,\r\n    samplingRate: 0.1,\r\n    thresholds: {\r\n      warnThresholdMs: 100,\r\n      errorThresholdMs: 1000,\r\n      maxMemoryBytes: 1024 * 1024 * 1024 // 1GB\r\n    },\r\n    metrics: {\r\n      timing: true,\r\n      memory: true,\r\n      cache: true\r\n    }\r\n  },\r\n  debug: {\r\n    verbose: false,\r\n    trackPerformance: false,\r\n    logLevel: 'error'\r\n  },\r\n  features: {\r\n    experimentalFeatures: false,\r\n    useWasm: false,\r\n    workerThreads: false,\r\n    sharedArrayBuffer: false,\r\n    bigIntTypedArrays: true\r\n  }\r\n};\r\n\r\n/**\r\n * Type guard to check if config is a full configuration\r\n */\r\nexport function isFullConfig(config: HypernumConfig): config is FullConfig {\r\n  return 'arithmetic' in config && 'dataStructures' in config;\r\n}\r\n\r\n/**\r\n * Type guard to check if config is a basic configuration\r\n */\r\nexport function isBasicConfig(config: HypernumConfig): config is BasicConfig {\r\n  return !isFullConfig(config);\r\n}\r\n\r\n/**\r\n * Validates configuration values\r\n */\r\nexport function validateConfig(config: HypernumConfig): void {\r\n  if (isFullConfig(config)) {\r\n    validateFullConfig(config);\r\n  } else {\r\n    validateBasicConfig(config);\r\n  }\r\n}\r\n\r\n/**\r\n * Validates basic configuration values\r\n */\r\nfunction validateBasicConfig(config: BasicConfig): void {\r\n  if (config.precision !== undefined && config.precision < 0) {\r\n    throw new Error('Precision cannot be negative');\r\n  }\r\n  if (config.maxSteps !== undefined && config.maxSteps <= 0) {\r\n    throw new Error('Maximum steps must be positive');\r\n  }\r\n  if (config.debug !== undefined && typeof config.debug !== 'boolean') {\r\n    throw new Error('Debug flag must be a boolean');\r\n  }\r\n}\r\n\r\n/**\r\n * Validates full configuration values\r\n */\r\nfunction validateFullConfig(config: FullConfig): void {\r\n  if (config.arithmetic.defaultPrecision < 0) {\r\n    throw new Error('Default precision cannot be negative');\r\n  }\r\n  if (config.arithmetic.maxComputationSteps <= 0) {\r\n    throw new Error('Max computation steps must be positive');\r\n  }\r\n  if (config.dataStructures.array.initialCapacity <= 0) {\r\n    throw new Error('Initial capacity must be positive');\r\n  }\r\n  if (config.dataStructures.array.growthFactor <= 1) {\r\n    throw new Error('Growth factor must be greater than 1');\r\n  }\r\n  if (config.performance.samplingRate < 0 || config.performance.samplingRate > 1) {\r\n    throw new Error('Sampling rate must be between 0 and 1');\r\n  }\r\n}\r\n\r\n/**\r\n * Merges configuration with appropriate defaults\r\n */\r\nexport function mergeConfig(custom: Partial<HypernumConfig> = {}): HypernumConfig {\r\n  if (isFullConfig(custom  as FullConfig)) {\r\n    const fullConfig = custom as FullConfig;\r\n    return {\r\n      ...DEFAULT_FULL_CONFIG,\r\n      ...fullConfig,\r\n      arithmetic: { ...DEFAULT_FULL_CONFIG.arithmetic, ...fullConfig.arithmetic },\r\n      dataStructures: { ...DEFAULT_FULL_CONFIG.dataStructures, ...fullConfig.dataStructures },\r\n      formatting: { ...DEFAULT_FULL_CONFIG.formatting, ...fullConfig.formatting },\r\n      performance: { ...DEFAULT_FULL_CONFIG.performance, ...fullConfig.performance },\r\n      debug: { ...DEFAULT_FULL_CONFIG.debug, ...fullConfig.debug },\r\n      features: { ...DEFAULT_FULL_CONFIG.features, ...fullConfig.features }\r\n    };\r\n  }\r\n  \r\n  const basicConfig: BasicConfig = {\r\n    precision: (custom as Partial<BasicConfig>).precision ?? DEFAULT_BASIC_CONFIG.precision,\r\n    roundingMode: (custom as Partial<BasicConfig>).roundingMode ?? DEFAULT_BASIC_CONFIG.roundingMode,\r\n    checkOverflow: (custom as Partial<BasicConfig>).checkOverflow ?? DEFAULT_BASIC_CONFIG.checkOverflow,\r\n    maxSteps: (custom as Partial<BasicConfig>).maxSteps ?? DEFAULT_BASIC_CONFIG.maxSteps,\r\n    debug: (custom as Partial<BasicConfig>).debug ?? DEFAULT_BASIC_CONFIG.debug\r\n  };\r\n\r\n  return basicConfig;\r\n}","/**\r\n * Core constants for Hypernum library\r\n * Defines fundamental values and limits used across the library\r\n */\r\n\r\n// Numerical limits\r\nexport const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\r\nexport const MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\r\nexport const MAX_PRECISION = 100;\r\nexport const MAX_COMPUTATION_STEPS = 1000;\r\nexport const MAX_BITS = 1024;\r\n\r\n// Commonly used values\r\nexport const ZERO = BigInt(0);\r\nexport const ONE = BigInt(1);\r\nexport const TWO = BigInt(2);\r\nexport const TEN = BigInt(10);\r\nexport const NEGATIVE_ONE = BigInt(-1);\r\n\r\n// Power operation limits\r\nexport const MAX_POWER_BASE = BigInt(2) ** BigInt(53);\r\nexport const MAX_POWER_EXPONENT = BigInt(1000);\r\nexport const MAX_TETRATION_HEIGHT = BigInt(4);\r\nexport const MAX_FACTORIAL_INPUT = BigInt(1000);\r\n\r\n// Tree and heap configuration\r\nexport const DEFAULT_TREE_MAX_DEPTH = 1000;\r\nexport const DEFAULT_HEAP_INITIAL_CAPACITY = 16;\r\nexport const DEFAULT_ARRAY_GROWTH_FACTOR = 2;\r\nexport const MIN_ARRAY_CAPACITY = 16;\r\n\r\n// Formatting configuration\r\nexport const DEFAULT_DECIMAL_SEPARATOR = '.';\r\nexport const DEFAULT_GROUP_SEPARATOR = ',';\r\nexport const DEFAULT_GROUP_SIZE = 3;\r\nexport const MAX_GROUP_SIZE = 10;\r\n\r\n// Roman numeral limits\r\nexport const MIN_ROMAN_VALUE = 1;\r\nexport const MAX_ROMAN_VALUE = 3999;\r\n\r\n// Ackermann function limits\r\nexport const MAX_ACKERMANN_M = 4;\r\nexport const MAX_ACKERMANN_N = 1000;\r\n\r\n// Cache configuration\r\nexport const DEFAULT_CACHE_SIZE = 1000;\r\nexport const MAX_CACHE_SIZE = 10000;\r\n\r\n// Error messages\r\nexport const ERROR_MESSAGES = {\r\n  OVERFLOW: 'Operation would result in overflow',\r\n  UNDERFLOW: 'Operation would result in underflow',\r\n  NEGATIVE_ROOT: 'Cannot compute root of negative number',\r\n  NEGATIVE_EXPONENT: 'Negative exponents not supported for integers',\r\n  DIVISION_BY_ZERO: 'Division by zero',\r\n  INVALID_PRECISION: 'Precision must be non-negative and not exceed MAX_PRECISION',\r\n  INVALID_BASE: 'Base must be a positive integer',\r\n  INVALID_ROMAN: 'Invalid Roman numeral',\r\n  COMPUTATION_LIMIT: 'Computation exceeded maximum allowed steps',\r\n  NEGATIVE_INDEX: 'Array index cannot be negative',\r\n  TREE_DEPTH_EXCEEDED: 'Maximum tree depth exceeded',\r\n  INVALID_HEAP_PROPERTY: 'Heap property violation detected'\r\n} as const;\r\n\r\n// Feature flags for optional functionality\r\nexport const FEATURES = {\r\n  OVERFLOW_CHECKING: true,\r\n  AUTOMATIC_PRECISION: true,\r\n  MEMOIZATION: true,\r\n  TREE_BALANCING: true,\r\n  DEBUG_MODE: false\r\n} as const;\r\n\r\n// Default options for various operations\r\nexport const DEFAULT_OPTIONS = {\r\n  precision: 0,\r\n  roundingMode: 'HALF_EVEN',\r\n  checkOverflow: true,\r\n  maxSteps: MAX_COMPUTATION_STEPS,\r\n  grouping: true,\r\n  uppercase: false,\r\n  cache: true\r\n} as const;\r\n\r\n// Units for number formatting (powers of 1000)\r\nexport const NUMBER_UNITS = [\r\n  { value: 1n, symbol: '' },\r\n  { value: 1000n, symbol: 'K' },\r\n  { value: 1000000n, symbol: 'M' },\r\n  { value: 1000000000n, symbol: 'B' },\r\n  { value: 1000000000000n, symbol: 'T' },\r\n  { value: 1000000000000000n, symbol: 'Q' }\r\n] as const;\r\n\r\n// Performance monitoring thresholds\r\nexport const PERFORMANCE = {\r\n  WARN_THRESHOLD_MS: 100,\r\n  ERROR_THRESHOLD_MS: 1000,\r\n  MAX_ARRAY_SIZE: 1000000,\r\n  MAX_TREE_SIZE: 1000000\r\n} as const;","/**\r\n * Custom error types for Hypernum library\r\n * Provides specific error classes for different types of errors that can occur\r\n * during mathematical operations and data structure manipulations\r\n */\r\n\r\nimport { ERROR_MESSAGES } from './constants';\r\n\r\n/**\r\n * Base error class for Hypernum library\r\n * All other error classes inherit from this\r\n */\r\nexport class HypernumError extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'HypernumError';\r\n    Object.setPrototypeOf(this, HypernumError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for validation failures\r\n */\r\nexport class ValidationError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'ValidationError';\r\n    Object.setPrototypeOf(this, ValidationError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for arithmetic overflow conditions\r\n */\r\nexport class OverflowError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.OVERFLOW) {\r\n    super(message);\r\n    this.name = 'OverflowError';\r\n    Object.setPrototypeOf(this, OverflowError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for arithmetic underflow conditions\r\n */\r\nexport class UnderflowError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.UNDERFLOW) {\r\n    super(message);\r\n    this.name = 'UnderflowError';\r\n    Object.setPrototypeOf(this, UnderflowError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for division by zero\r\n */\r\nexport class DivisionByZeroError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.DIVISION_BY_ZERO) {\r\n    super(message);\r\n    this.name = 'DivisionByZeroError';\r\n    Object.setPrototypeOf(this, DivisionByZeroError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for precision-related issues\r\n */\r\nexport class PrecisionError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_PRECISION) {\r\n    super(message);\r\n    this.name = 'PrecisionError';\r\n    Object.setPrototypeOf(this, PrecisionError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for computation limits exceeded\r\n */\r\nexport class ComputationLimitError extends HypernumError {\r\n  constructor(message: string = ERROR_MESSAGES.COMPUTATION_LIMIT) {\r\n    super(message);\r\n    this.name = 'ComputationLimitError';\r\n    Object.setPrototypeOf(this, ComputationLimitError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid operations on data structures\r\n */\r\nexport class DataStructureError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'DataStructureError';\r\n    Object.setPrototypeOf(this, DataStructureError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for heap property violations\r\n */\r\nexport class HeapPropertyError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_HEAP_PROPERTY) {\r\n    super(message);\r\n    this.name = 'HeapPropertyError';\r\n    Object.setPrototypeOf(this, HeapPropertyError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for tree-related issues\r\n */\r\nexport class TreeError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.TREE_DEPTH_EXCEEDED) {\r\n    super(message);\r\n    this.name = 'TreeError';\r\n    Object.setPrototypeOf(this, TreeError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for array index out of bounds\r\n */\r\nexport class IndexError extends DataStructureError {\r\n  constructor(message: string = ERROR_MESSAGES.NEGATIVE_INDEX) {\r\n    super(message);\r\n    this.name = 'IndexError';\r\n    Object.setPrototypeOf(this, IndexError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid number format or conversion\r\n */\r\nexport class FormatError extends HypernumError {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = 'FormatError';\r\n    Object.setPrototypeOf(this, FormatError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Error for invalid Roman numeral operations\r\n */\r\nexport class RomanNumeralError extends FormatError {\r\n  constructor(message: string = ERROR_MESSAGES.INVALID_ROMAN) {\r\n    super(message);\r\n    this.name = 'RomanNumeralError';\r\n    Object.setPrototypeOf(this, RomanNumeralError.prototype);\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard to check if an error is a Hypernum error\r\n */\r\nexport function isHypernumError(error: unknown): error is HypernumError {\r\n  return error instanceof HypernumError;\r\n}\r\n\r\n/**\r\n * Helper function to wrap unknown errors into HypernumError\r\n */\r\nexport function wrapError(error: unknown): HypernumError {\r\n  if (isHypernumError(error)) {\r\n    return error;\r\n  }\r\n  if (error instanceof Error) {\r\n    return new HypernumError(error.message);\r\n  }\r\n  return new HypernumError('An unknown error occurred');\r\n}\r\n\r\n/**\r\n * Helper function to create an appropriate error from a message and optional type\r\n */\r\nexport function createError(message: string, type?: string): HypernumError {\r\n  switch (type) {\r\n    case 'validation':\r\n      return new ValidationError(message);\r\n    case 'overflow':\r\n      return new OverflowError(message);\r\n    case 'underflow':\r\n      return new UnderflowError(message);\r\n    case 'division':\r\n      return new DivisionByZeroError(message);\r\n    case 'precision':\r\n      return new PrecisionError(message);\r\n    case 'computation':\r\n      return new ComputationLimitError(message);\r\n    case 'heap':\r\n      return new HeapPropertyError(message);\r\n    case 'tree':\r\n      return new TreeError(message);\r\n    case 'index':\r\n      return new IndexError(message);\r\n    case 'format':\r\n      return new FormatError(message);\r\n    case 'roman':\r\n      return new RomanNumeralError(message);\r\n    default:\r\n      return new HypernumError(message);\r\n  }\r\n}","/**\r\n * Arithmetic operations module for Hypernum library\r\n * Provides high-precision arithmetic operations with BigInt support\r\n */\r\n\r\nimport {\r\n    validateNonNegative,\r\n    toBigInt,\r\n    checkAdditionOverflow,\r\n    checkMultiplicationOverflow,\r\n    checkPowerOverflow,\r\n    ValidationError,\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    round,\r\n    scaledDivision,\r\n    normalizePrecision,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for arithmetic operations\r\n   */\r\n  export interface ArithmeticOptions {\r\n    precision?: number;\r\n    roundingMode?: RoundingMode;\r\n    checkOverflow?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ArithmeticOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true\r\n  };\r\n  \r\n  /**\r\n   * Adds two numbers with optional precision and overflow checking\r\n   */\r\n  export function add(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkAdditionOverflow(bigA, bigB);\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA + bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA + scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Subtracts two numbers with optional precision and overflow checking\r\n   */\r\n  export function subtract(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkAdditionOverflow(bigA, -bigB);\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA - bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA - scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Multiplies two numbers with optional precision and overflow checking\r\n   */\r\n  export function multiply(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkMultiplicationOverflow(bigA, bigB);\r\n    }\r\n  \r\n    const result = bigA * bigB;\r\n    if (opts.precision === 0) {\r\n      return result;\r\n    }\r\n  \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Divides two numbers with specified precision and rounding\r\n   */\r\n  export function divide(\r\n    numerator: bigint | string | number,\r\n    denominator: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigNumerator = toBigInt(numerator);\r\n    const bigDenominator = toBigInt(denominator);\r\n  \r\n    if (bigDenominator === BigInt(0)) {\r\n      throw new ValidationError('Division by zero');\r\n    }\r\n  \r\n    return scaledDivision(\r\n      bigNumerator,\r\n      bigDenominator,\r\n      opts.precision,\r\n      opts.roundingMode\r\n    );\r\n  }\r\n  \r\n  /**\r\n   * Calculates remainder with optional precision\r\n   */\r\n  export function remainder(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (bigB === BigInt(0)) {\r\n      throw new ValidationError('Division by zero in remainder operation');\r\n    }\r\n  \r\n    if (opts.precision === 0) {\r\n      return bigA % bigB;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    const result = scaledA % scaledB;\r\n    \r\n    return round(result, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Raises a number to a power with optional precision\r\n   */\r\n  export function power(\r\n    base: bigint | string | number,\r\n    exponent: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(base);\r\n    const bigExponent = toBigInt(exponent);\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkPowerOverflow(bigBase, bigExponent);\r\n    }\r\n  \r\n    validateNonNegative(bigExponent);\r\n  \r\n    if (bigExponent === BigInt(0)) {\r\n      return BigInt(1);\r\n    }\r\n  \r\n    if (bigExponent === BigInt(1)) {\r\n      return bigBase;\r\n    }\r\n  \r\n    let result = bigBase;\r\n    let remaining = bigExponent - BigInt(1);\r\n  \r\n    while (remaining > BigInt(0)) {\r\n      if (opts.checkOverflow) {\r\n        checkMultiplicationOverflow(result, bigBase);\r\n      }\r\n      result *= bigBase;\r\n      remaining--;\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates the square root with specified precision\r\n   */\r\n  export function sqrt(\r\n    value: bigint | string | number,\r\n    options: ArithmeticOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    validateNonNegative(bigValue);\r\n  \r\n    if (bigValue === BigInt(0)) {\r\n      return BigInt(0);\r\n    }\r\n  \r\n    // Scale up for precision\r\n    const scaleFactor = BigInt(10) ** BigInt(opts.precision * 2);\r\n    const scaled = bigValue * scaleFactor;\r\n  \r\n    // Newton's method for square root\r\n    let x = scaled;\r\n    let y = (x + scaled / x) >> BigInt(1);\r\n  \r\n    while (y < x) {\r\n      x = y;\r\n      y = (x + scaled / x) >> BigInt(1);\r\n    }\r\n  \r\n    return round(x, opts.precision, opts.roundingMode);\r\n  }\r\n  \r\n  /**\r\n   * Calculates the absolute value\r\n   */\r\n  export function abs(value: bigint | string | number): bigint {\r\n    const bigValue = toBigInt(value);\r\n    return bigValue < BigInt(0) ? -bigValue : bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Returns the sign of a number (-1, 0, or 1)\r\n   */\r\n  export function sign(value: bigint | string | number): bigint {\r\n    const bigValue = toBigInt(value);\r\n    if (bigValue < BigInt(0)) return BigInt(-1);\r\n    if (bigValue > BigInt(0)) return BigInt(1);\r\n    return BigInt(0);\r\n  }\r\n  \r\n  /**\r\n   * Calculates the greatest common divisor of two numbers\r\n   */\r\n  export function gcd(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    let bigA = abs(toBigInt(a));\r\n    let bigB = abs(toBigInt(b));\r\n  \r\n    while (bigB !== BigInt(0)) {\r\n      const temp = bigB;\r\n      bigB = bigA % bigB;\r\n      bigA = temp;\r\n    }\r\n  \r\n    return bigA;\r\n  }\r\n  \r\n  /**\r\n   * Calculates the least common multiple of two numbers\r\n   */\r\n  export function lcm(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = abs(toBigInt(a));\r\n    const bigB = abs(toBigInt(b));\r\n    \r\n    if (bigA === BigInt(0) || bigB === BigInt(0)) {\r\n      return BigInt(0);\r\n    }\r\n  \r\n    return abs(bigA * bigB) / gcd(bigA, bigB);\r\n  }\r\n  \r\n  // /**\r\n  //  * Calculates factorial of a number\r\n  //  */\r\n  // export function factorial(value: bigint | string | number): bigint {\r\n  //   const bigValue = toBigInt(value);\r\n  //   validateNonNegative(bigValue);\r\n  \r\n  //   if (bigValue > BigInt(1000)) {\r\n  //     throw new OverflowError('Factorial input too large');\r\n  //   }\r\n  \r\n  //   if (bigValue <= BigInt(1)) {\r\n  //     return BigInt(1);\r\n  //   }\r\n  \r\n  //   let result = BigInt(1);\r\n  //   let current = BigInt(2);\r\n  \r\n  //   while (current <= bigValue) {\r\n  //     result *= current;\r\n  //     current++;\r\n  //   }\r\n  \r\n  //   return result;\r\n  // }\r\n  \r\n  export default {\r\n    add,\r\n    subtract,\r\n    multiply,\r\n    divide,\r\n    remainder,\r\n    power,\r\n    sqrt,\r\n    abs,\r\n    sign,\r\n    gcd,\r\n    lcm, \r\n    // factorial\r\n  };","/**\r\n * Bitwise operations module for Hypernum library\r\n * Provides functions for bit-level manipulations of large numbers\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    validateNonNegative\r\n  } from '../utils/validation';\r\n  \r\n  /**\r\n   * Options for bitwise operations\r\n   */\r\n  export interface BitwiseOptions {\r\n    /** Maximum bits to consider in operations */\r\n    maxBits?: number;\r\n    /** Whether to throw on overflow */\r\n    strict?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<BitwiseOptions> = {\r\n    maxBits: 1024,\r\n    strict: true\r\n  };\r\n  \r\n  /**\r\n   * Validates shift amount is within reasonable bounds\r\n   */\r\n  function validateShift(shift: bigint, options: Required<BitwiseOptions>): void {\r\n    if (shift < 0n) {\r\n      throw new ValidationError('Shift amount cannot be negative');\r\n    }\r\n    if (options.strict && shift >= BigInt(options.maxBits)) {\r\n      throw new ValidationError(`Shift amount exceeds maximum of ${options.maxBits} bits`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise AND operation\r\n   */\r\n  export function and(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n\r\n    return bigA & bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise OR operation\r\n   */\r\n  export function or(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n    \r\n    return bigA | bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise XOR operation\r\n   */\r\n  export function xor(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number\r\n  ): bigint {\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n    \r\n    return bigA ^ bigB;\r\n  }\r\n  \r\n  /**\r\n   * Performs bitwise NOT operation\r\n   */\r\n  export function not(\r\n    value: bigint | string | number\r\n  ): bigint {\r\n    const bigValue = toBigInt(value);\r\n    \r\n    return ~bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Performs left shift operation\r\n   */\r\n  export function leftShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    return bigValue << bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Performs right shift operation\r\n   */\r\n  export function rightShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    return bigValue >> bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Performs unsigned right shift operation\r\n   * Note: BigInt doesn't have >>> operator, so we implement it manually\r\n   */\r\n  export function unsignedRightShift(\r\n    value: bigint | string | number,\r\n    shift: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigShift = toBigInt(shift);\r\n    \r\n    validateShift(bigShift, opts);\r\n    \r\n    if (bigValue >= 0n) {\r\n      return bigValue >> bigShift;\r\n    }\r\n    \r\n    // Handle negative numbers by first converting to positive\r\n    const mask = (1n << BigInt(opts.maxBits)) - 1n;\r\n    return (bigValue & mask) >> bigShift;\r\n  }\r\n  \r\n  /**\r\n   * Rotates bits left by specified amount\r\n   */\r\n  export function rotateLeft(\r\n    value: bigint | string | number,\r\n    rotation: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    let bigRotation = toBigInt(rotation);\r\n    \r\n    validateNonNegative(bigRotation);\r\n    \r\n    // Normalize rotation to be within maxBits\r\n    if (bigRotation >= BigInt(opts.maxBits)) {\r\n      bigRotation = bigRotation % BigInt(opts.maxBits);\r\n    }\r\n    \r\n    if (bigRotation === 0n) {\r\n      return bigValue;\r\n    }\r\n    \r\n    const leftPart = leftShift(bigValue, bigRotation, opts);\r\n    const rightPart = unsignedRightShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\r\n    \r\n    return leftPart | rightPart;\r\n  }\r\n  \r\n  /**\r\n   * Rotates bits right by specified amount\r\n   */\r\n  export function rotateRight(\r\n    value: bigint | string | number,\r\n    rotation: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    let bigRotation = toBigInt(rotation);\r\n    \r\n    validateNonNegative(bigRotation);\r\n    \r\n    // Normalize rotation to be within maxBits\r\n    if (bigRotation >= BigInt(opts.maxBits)) {\r\n      bigRotation = bigRotation % BigInt(opts.maxBits);\r\n    }\r\n    \r\n    if (bigRotation === 0n) {\r\n      return bigValue;\r\n    }\r\n    \r\n    const rightPart = unsignedRightShift(bigValue, bigRotation, opts);\r\n    const leftPart = leftShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\r\n    \r\n    return leftPart | rightPart;\r\n  }\r\n  \r\n  /**\r\n   * Counts number of set bits (1s)\r\n   */\r\n  export function popCount(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    let count = 0n;\r\n    while (bigValue !== 0n) {\r\n      count += bigValue & 1n;\r\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns number of trailing zero bits\r\n   */\r\n  export function trailingZeros(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return BigInt(opts.maxBits);\r\n    }\r\n    \r\n    let count = 0n;\r\n    while ((bigValue & 1n) === 0n) {\r\n      count++;\r\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns number of leading zero bits\r\n   */\r\n  export function leadingZeros(\r\n    value: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    let bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return BigInt(opts.maxBits);\r\n    }\r\n    \r\n    let count = 0n;\r\n    const msb = 1n << BigInt(opts.maxBits - 1);\r\n    \r\n    while ((bigValue & msb) === 0n && count < BigInt(opts.maxBits)) {\r\n      count++;\r\n      bigValue = leftShift(bigValue, 1n, opts);\r\n    }\r\n    \r\n    return count;\r\n  }\r\n  \r\n  /**\r\n   * Returns bit at specified position\r\n   */\r\n  export function getBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): boolean {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return (bigValue & (1n << bigPosition)) !== 0n;\r\n  }\r\n  \r\n  /**\r\n   * Sets bit at specified position\r\n   */\r\n  export function setBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue | (1n << bigPosition);\r\n  }\r\n  \r\n  /**\r\n   * Clears bit at specified position\r\n   */\r\n  export function clearBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue & ~(1n << bigPosition);\r\n  }\r\n  \r\n  /**\r\n   * Toggles bit at specified position\r\n   */\r\n  export function toggleBit(\r\n    value: bigint | string | number,\r\n    position: bigint | string | number,\r\n    options: BitwiseOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigPosition = toBigInt(position);\r\n    \r\n    validateNonNegative(bigPosition);\r\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\r\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\r\n    }\r\n    \r\n    return bigValue ^ (1n << bigPosition);\r\n  }\r\n  \r\n  export default {\r\n    and,\r\n    or,\r\n    xor,\r\n    not,\r\n    leftShift,\r\n    rightShift,\r\n    unsignedRightShift,\r\n    rotateLeft,\r\n    rotateRight,\r\n    popCount,\r\n    trailingZeros,\r\n    leadingZeros,\r\n    getBit,\r\n    setBit,\r\n    clearBit,\r\n    toggleBit\r\n  };","/**\r\n * Power operations module for Hypernum library\r\n * Provides efficient implementations for exponentiation and related operations\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    OverflowError,\r\n    validateNonNegative,\r\n    checkPowerOverflow\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    round,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for power operations\r\n   */\r\n  export interface PowerOptions {\r\n    /** Precision for decimal operations */\r\n    precision?: number;\r\n    /** Rounding mode for decimal operations */\r\n    roundingMode?: RoundingMode;\r\n    /** Whether to check for overflow */\r\n    checkOverflow?: boolean;\r\n    /** Maximum allowed computation steps */\r\n    maxSteps?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<PowerOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    checkOverflow: true,\r\n    maxSteps: 1000\r\n  };\r\n  \r\n  /**\r\n   * Raises a number to an integer power using binary exponentiation\r\n   */\r\n  export function power(\r\n    baseValue: bigint | string | number,\r\n    exponentValue: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(baseValue);\r\n    const bigExponent = toBigInt(exponentValue);\r\n  \r\n    // Handle special cases\r\n    if (bigExponent === 0n) {\r\n      return 1n;\r\n    }\r\n    if (bigExponent === 1n) {\r\n      return bigBase;\r\n    }\r\n    if (bigBase === 0n && bigExponent < 0n) {\r\n      throw new ValidationError('Zero cannot be raised to a negative power');\r\n    }\r\n    if (bigBase === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigBase === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigBase === -1n) {\r\n      return bigExponent % 2n === 0n ? 1n : -1n;\r\n    }\r\n  \r\n    // Validate inputs\r\n    if (bigExponent < 0n) {\r\n      throw new ValidationError('Negative exponents not supported for integer power');\r\n    }\r\n  \r\n    if (opts.checkOverflow) {\r\n      checkPowerOverflow(bigBase, bigExponent);\r\n    }\r\n  \r\n    // Binary exponentiation algorithm\r\n    let result = 1n;\r\n    let base = bigBase;\r\n    let exponent = bigExponent;\r\n    let steps = 0;\r\n  \r\n    while (exponent > 0n) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Power operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      if (exponent & 1n) {\r\n        result *= base;\r\n      }\r\n      base *= base;\r\n      exponent >>= 1n;\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates square root using Newton's method\r\n   */\r\n  export function sqrt(\r\n    value: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n  \r\n    validateNonNegative(bigValue);\r\n  \r\n    if (bigValue === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n  \r\n    // Newton's method for square root\r\n    let guess = bigValue >> 1n;\r\n    let lastGuess: bigint;\r\n    let steps = 0;\r\n  \r\n    do {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Square root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      lastGuess = guess;\r\n      guess = (guess + bigValue / guess) >> 1n;\r\n    } while (guess < lastGuess);\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(lastGuess, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return lastGuess;\r\n  }\r\n  \r\n  /**\r\n   * Calculates nth root using Newton's method\r\n   */\r\n  export function nthRoot(\r\n    value: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigValue);\r\n    if (bigN <= 0n) {\r\n      throw new ValidationError('Root index must be positive');\r\n    }\r\n  \r\n    if (bigValue === 0n) {\r\n      return 0n;\r\n    }\r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigN === 1n) {\r\n      return bigValue;\r\n    }\r\n    if (bigN === 2n) {\r\n      return sqrt(bigValue, opts);\r\n    }\r\n  \r\n    // Newton's method for nth root\r\n    let guess = bigValue >> 1n;\r\n    let lastGuess: bigint;\r\n    let steps = 0;\r\n  \r\n    const nMinus1 = bigN - 1n;\r\n  \r\n    do {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Nth root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      lastGuess = guess;\r\n      const powered = power(guess, nMinus1, opts);\r\n      guess = ((nMinus1 * guess) + (bigValue / powered)) / bigN;\r\n    } while (guess < lastGuess);\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(lastGuess, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return lastGuess;\r\n  }\r\n  \r\n  /**\r\n   * Calculates tetration (repeated exponentiation)\r\n   * an = a^(a^(a^...)) (n times)\r\n   */\r\n  export function tetration(\r\n    base: bigint | string | number,\r\n    height: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigBase = toBigInt(base);\r\n    const bigHeight = toBigInt(height);\r\n  \r\n    validateNonNegative(bigHeight);\r\n  \r\n    if (bigHeight === 0n) {\r\n      return 1n;\r\n    }\r\n    if (bigHeight === 1n) {\r\n      return bigBase;\r\n    }\r\n    if (bigBase === 0n) {\r\n      return bigHeight % 2n === 0n ? 1n : 0n;\r\n    }\r\n    if (bigBase === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigBase === 2n && bigHeight > 4n) {\r\n      throw new OverflowError('Tetration would overflow for base 2 and height > 4');\r\n    }\r\n  \r\n    let result = bigBase;\r\n    let steps = 0;\r\n  \r\n    for (let i = 1n; i < bigHeight; i++) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Tetration operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      result = power(bigBase, result, opts);\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(result, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates super-root (inverse tetration)\r\n   * Finds x where xn = value\r\n   */\r\n  export function superRoot(\r\n    value: bigint | string | number,\r\n    height: bigint | string | number,\r\n    options: PowerOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    const bigHeight = toBigInt(height);\r\n  \r\n    validateNonNegative(bigHeight);\r\n    if (bigHeight === 0n) {\r\n      throw new ValidationError('Height cannot be zero for super-root');\r\n    }\r\n    if (bigValue < 1n) {\r\n      throw new ValidationError('Value must be at least 1 for super-root');\r\n    }\r\n  \r\n    if (bigValue === 1n) {\r\n      return 1n;\r\n    }\r\n    if (bigHeight === 1n) {\r\n      return bigValue;\r\n    }\r\n  \r\n    // Binary search for super-root\r\n    let left = 1n;\r\n    let right = bigValue;\r\n    let steps = 0;\r\n  \r\n    while (left <= right) {\r\n      if (steps++ > opts.maxSteps) {\r\n        throw new OverflowError('Super-root operation exceeded maximum computation steps');\r\n      }\r\n  \r\n      const mid = (left + right) >> 1n;\r\n      try {\r\n        const test = tetration(mid, bigHeight, opts);\r\n        if (test === bigValue) {\r\n          return mid;\r\n        }\r\n        if (test < bigValue) {\r\n          left = mid + 1n;\r\n        } else {\r\n          right = mid - 1n;\r\n        }\r\n      } catch (error) {\r\n        right = mid - 1n;\r\n      }\r\n    }\r\n  \r\n    if (opts.precision > 0) {\r\n      return round(right, opts.precision, opts.roundingMode);\r\n    }\r\n  \r\n    return right;\r\n  }\r\n  \r\n  export default {\r\n    power,\r\n    sqrt,\r\n    nthRoot,\r\n    tetration,\r\n    superRoot\r\n  };","/**\r\n * Represents the result of a comparison operation\r\n * -1: first value is less than second value\r\n *  0: values are equal\r\n *  1: first value is greater than second value\r\n */\r\nexport type ComparisonResult = -1 | 0 | 1;\r\n\r\n/**\r\n * Generic comparator function type for heap elements\r\n */\r\nexport type Comparator<T> = (a: T, b: T) => ComparisonResult;\r\n\r\n/**\r\n * Abstract base heap class implementing common heap operations\r\n */\r\nabstract class Heap<T> {\r\n  protected heap: T[];\r\n  protected readonly compare: Comparator<T>;\r\n\r\n  constructor(comparator: Comparator<T>) {\r\n    this.heap = [];\r\n    this.compare = comparator;\r\n  }\r\n\r\n  /**\r\n   * Gets the size of the heap\r\n   */\r\n  public size(): number {\r\n    return this.heap.length;\r\n  }\r\n\r\n  /**\r\n   * Checks if the heap is empty\r\n   */\r\n  public isEmpty(): boolean {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  /**\r\n   * Peeks at the root element without removing it\r\n   */\r\n  public peek(): T | undefined {\r\n    return this.heap[0];\r\n  }\r\n\r\n  /**\r\n   * Inserts a new element into the heap\r\n   */\r\n  public push(value: T): void {\r\n    this.heap.push(value);\r\n    this.siftUp(this.heap.length - 1);\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the root element\r\n   */\r\n  public pop(): T | undefined {\r\n    if (this.isEmpty()) {\r\n      return undefined;\r\n    }\r\n\r\n    const root = this.heap[0];\r\n    const last = this.heap.pop()!;\r\n\r\n    if (!this.isEmpty()) {\r\n      this.heap[0] = last;\r\n      this.siftDown(0);\r\n    }\r\n\r\n    return root;\r\n  }\r\n\r\n  /**\r\n   * Removes all elements from the heap\r\n   */\r\n  public clear(): void {\r\n    this.heap = [];\r\n  }\r\n\r\n  /**\r\n   * Creates a heap from an array of elements\r\n   */\r\n  public static heapify<T extends {}>(array: T[], comparator: Comparator<T>): Heap<T> {\r\n    const heap = this instanceof MinHeap ? new MinHeap(comparator) : new MaxHeap(comparator);\r\n    array.forEach(item => heap.push(item));\r\n    return heap;\r\n  }\r\n\r\n  /**\r\n   * Gets the parent index of a node\r\n   */\r\n  protected getParentIndex(index: number): number {\r\n    return Math.floor((index - 1) / 2);\r\n  }\r\n\r\n  /**\r\n   * Gets the left child index of a node\r\n   */\r\n  protected getLeftChildIndex(index: number): number {\r\n    return 2 * index + 1;\r\n  }\r\n\r\n  /**\r\n   * Gets the right child index of a node\r\n   */\r\n  protected getRightChildIndex(index: number): number {\r\n    return 2 * index + 2;\r\n  }\r\n\r\n  /**\r\n   * Swaps two elements in the heap\r\n   */\r\n  protected swap(i: number, j: number): void {\r\n    const temp = this.heap[i]!;\r\n    this.heap[i] = this.heap[j]!;\r\n    this.heap[j] = temp;\r\n  }\r\n\r\n  /**\r\n   * Moves an element up the heap until heap property is satisfied\r\n   */\r\n  protected abstract siftUp(index: number): void;\r\n\r\n  /**\r\n   * Moves an element down the heap until heap property is satisfied\r\n   */\r\n  protected abstract siftDown(index: number): void;\r\n}\r\n\r\n/**\r\n * MinHeap implementation where the root is the smallest element\r\n */\r\nexport class MinHeap<T> extends Heap<T> {\r\n  constructor(comparator: Comparator<T>) {\r\n    super(comparator);\r\n  }\r\n\r\n  protected siftUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = this.getParentIndex(index);\r\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) >= 0) {\r\n        break;\r\n      }\r\n      this.swap(index, parentIndex);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  protected siftDown(index: number): void {\r\n    const size = this.heap.length;\r\n    \r\n    while (true) {\r\n      let smallest = index;\r\n      const left = this.getLeftChildIndex(index);\r\n      const right = this.getRightChildIndex(index);\r\n\r\n      if (left < size && this.compare(this.heap[left]!, this.heap[smallest]!) < 0) {\r\n        smallest = left;\r\n      }\r\n\r\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right] as T, this.heap[smallest] as T) < 0) {\r\n        smallest = right;\r\n      }\r\n\r\n      if (smallest === index) {\r\n        break;\r\n      }\r\n\r\n      this.swap(index, smallest);\r\n      index = smallest;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * MaxHeap implementation where the root is the largest element\r\n */\r\nexport class MaxHeap<T> extends Heap<T> {\r\n  constructor(comparator: Comparator<T>) {\r\n    super(comparator);\r\n  }\r\n\r\n  protected siftUp(index: number): void {\r\n    while (index > 0) {\r\n      const parentIndex = this.getParentIndex(index);\r\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) <= 0) {\r\n        break;\r\n      }\r\n      this.swap(index, parentIndex);\r\n      index = parentIndex;\r\n    }\r\n  }\r\n\r\n  protected siftDown(index: number): void {\r\n    const size = this.heap.length;\r\n    \r\n    while (true) {\r\n      let largest = index;\r\n      const left = this.getLeftChildIndex(index);\r\n      const right = this.getRightChildIndex(index);\r\n\r\n      if (left < size && this.heap[left] !== undefined && this.compare(this.heap[left]!, this.heap[largest]!) > 0) {\r\n        largest = left;\r\n      }\r\n\r\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right]!, this.heap[largest]!) > 0) {\r\n        largest = right;\r\n      }\r\n\r\n      if (largest === index) {\r\n        break;\r\n      }\r\n\r\n      this.swap(index, largest);\r\n      index = largest;\r\n    }\r\n  }\r\n}\r\n\r\n// Type Guards\r\nexport const isMinHeap = <T>(heap: Heap<T>): heap is MinHeap<T> => {\r\n  return heap instanceof MinHeap;\r\n};\r\n\r\nexport const isMaxHeap = <T>(heap: Heap<T>): heap is MaxHeap<T> => {\r\n  return heap instanceof MaxHeap;\r\n};\r\n\r\n/**\r\n * Custom comparator for large numbers\r\n */\r\nexport function createLargeNumberComparator(): (a: bigint, b: bigint) => number {\r\n  return (a, b) => {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n  };\r\n}","import { MaxHeap, createLargeNumberComparator, Comparator } from \"../storage/Heap\";\r\n\r\n  /**\r\n   * Interface representing an Ackermann node in the computation structure\r\n   */\r\n  interface IAckermannNode {\r\n    m: number;\r\n    n: number;\r\n    value: bigint;\r\n    prevM?: IAckermannNode;  // Link to A(m-1, n)\r\n    prevN?: IAckermannNode;  // Link to A(m, n-1)\r\n    nextM?: IAckermannNode;  // Link to A(m+1, n)\r\n    nextN?: IAckermannNode;  // Link to A(m, n+1)\r\n  }\r\n  \r\n  /**\r\n   * Type for Ackermann computation path step\r\n   */\r\n  type ComputationStep = {\r\n    m: number;\r\n    n: number;\r\n    value: bigint;\r\n  };\r\n  \r\n  /**\r\n   * Type for growth rate analysis\r\n   */\r\n  type GrowthAnalysis = {\r\n    value: bigint;\r\n    increase: bigint;\r\n    multiplier: bigint;\r\n  };\r\n  \r\n  /**\r\n   * Class representing the Ackermann function computation structure\r\n   * Implements caching and relationship tracking between values\r\n   */\r\n  export class AckermannStructure {\r\n    private nodes: Map<string, IAckermannNode>;\r\n    private maxComputedM: number;\r\n    private maxComputedN: number;\r\n    private heap: MaxHeap<bigint>;\r\n  \r\n    constructor() {\r\n      this.nodes = new Map();\r\n      this.maxComputedM = -1;\r\n      this.maxComputedN = -1;\r\n      this.heap = new MaxHeap<bigint>(createLargeNumberComparator() as Comparator<bigint>);\r\n    }\r\n  \r\n    /**\r\n     * Generates a unique key for node storage\r\n     */\r\n    private static getNodeKey(m: number, n: number): string {\r\n      return `${m},${n}`;\r\n    }\r\n  \r\n    /**\r\n     * Computes the Ackermann function value\r\n     * Uses recursion with memoization\r\n     */\r\n    private computeAckermann(m: number, n: number): bigint {\r\n      // Handle invalid inputs\r\n      if (m < 0 || n < 0) {\r\n        throw new Error('Ackermann function undefined for negative numbers');\r\n      }\r\n  \r\n      // Check if already computed\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      const existing = this.nodes.get(key);\r\n      if (existing) {\r\n        return existing.value;\r\n      }\r\n  \r\n      // Compute based on Ackermann function definition\r\n      let value: bigint;\r\n      try {\r\n        if (m === 0) {\r\n          value = BigInt(n + 1);\r\n        } else if (n === 0) {\r\n          value = this.computeAckermann(m - 1, 1);\r\n        } else {\r\n          const inner = this.computeAckermann(m, n - 1);\r\n          // Convert bigint to number for recursion, being careful about size\r\n          const innerNum = inner <= BigInt(Number.MAX_SAFE_INTEGER) \r\n            ? Number(inner) \r\n            : Number.MAX_SAFE_INTEGER;\r\n          value = this.computeAckermann(m - 1, innerNum);\r\n        }\r\n      } catch (error) {\r\n        // Handle stack overflow or computation limits\r\n        if (error instanceof RangeError) {\r\n          return BigInt(Number.MAX_SAFE_INTEGER);\r\n        }\r\n        throw error;\r\n      }\r\n  \r\n      return value;\r\n    }\r\n  \r\n    /**\r\n     * Adds a new node to the structure\r\n     */\r\n    public addNode(m: number, n: number): IAckermannNode {\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      if (this.nodes.has(key)) {\r\n        return this.nodes.get(key)!;\r\n      }\r\n  \r\n      // Create new node\r\n      const value = this.computeAckermann(m, n);\r\n      const node: IAckermannNode = { m, n, value };\r\n      this.nodes.set(key, node);\r\n  \r\n      // Link to existing nodes\r\n      const prevMKey = AckermannStructure.getNodeKey(m - 1, n);\r\n      const prevNKey = AckermannStructure.getNodeKey(m, n - 1);\r\n  \r\n      if (this.nodes.has(prevMKey)) {\r\n        const prevM = this.nodes.get(prevMKey)!;\r\n        node.prevM = prevM;\r\n        prevM.nextM = node;\r\n      }\r\n  \r\n      if (this.nodes.has(prevNKey)) {\r\n        const prevN = this.nodes.get(prevNKey)!;\r\n        node.prevN = prevN;\r\n        prevN.nextN = node;\r\n      }\r\n  \r\n      // Update tracking\r\n      this.maxComputedM = Math.max(this.maxComputedM, m);\r\n      this.maxComputedN = Math.max(this.maxComputedN, n);\r\n      this.heap.push(value);\r\n  \r\n      return node;\r\n    }\r\n  \r\n    /**\r\n     * Builds nodes for a range of m and n values\r\n     */\r\n    public buildRange(mRange: number, nRange: number): void {\r\n      for (let m = 0; m <= mRange; m++) {\r\n        for (let n = 0; n <= nRange; n++) {\r\n          this.addNode(m, n);\r\n        }\r\n      }\r\n    }\r\n  \r\n    /**\r\n     * Gets the computation path to reach A(m,n)\r\n     */\r\n    public getComputationPath(m: number, n: number): ComputationStep[] {\r\n      const path: ComputationStep[] = [];\r\n      const key = AckermannStructure.getNodeKey(m, n);\r\n      let current = this.nodes.get(key);\r\n  \r\n      while (current) {\r\n        path.push({\r\n          m: current.m,\r\n          n: current.n,\r\n          value: current.value\r\n        });\r\n  \r\n        // Follow computation path backwards\r\n        if (current.m === 0) {\r\n          break;\r\n        } else if (current.n === 0) {\r\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, 1));\r\n        } else {\r\n          const prevN = this.nodes.get(AckermannStructure.getNodeKey(current.m, current.n - 1));\r\n          if (prevN) {\r\n            path.push({\r\n              m: prevN.m,\r\n              n: prevN.n,\r\n              value: prevN.value\r\n            });\r\n          }\r\n          // Convert bigint to number safely for the next lookup\r\n          const nextValue = prevN?.value ?? BigInt(0);\r\n          const safeNextValue = nextValue <= BigInt(Number.MAX_SAFE_INTEGER)\r\n            ? Number(nextValue)\r\n            : Number.MAX_SAFE_INTEGER;\r\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, safeNextValue));\r\n        }\r\n      }\r\n  \r\n      return path.reverse();\r\n    }\r\n  \r\n    /**\r\n     * Analyzes growth rate for a fixed m value\r\n     */\r\n    public analyzeGrowthRate(m: number): Map<number, GrowthAnalysis> {\r\n      const growth = new Map<number, GrowthAnalysis>();\r\n      let prevValue = BigInt(1);\r\n  \r\n      for (let n = 0; n <= this.maxComputedN; n++) {\r\n        const key = AckermannStructure.getNodeKey(m, n);\r\n        const node = this.nodes.get(key);\r\n        if (!node || node.value >= BigInt(Number.MAX_SAFE_INTEGER)) {\r\n          break;\r\n        }\r\n  \r\n        growth.set(n, {\r\n          value: node.value,\r\n          increase: node.value - prevValue,\r\n          multiplier: prevValue === BigInt(0) ? BigInt(0) : node.value / prevValue\r\n        });\r\n  \r\n        prevValue = node.value;\r\n      }\r\n  \r\n      return growth;\r\n    }\r\n  \r\n    /**\r\n     * Gets the largest computed value\r\n     */\r\n    public getLargestValue(): bigint {\r\n      return this.heap.peek() ?? BigInt(0);\r\n    }\r\n  \r\n    /**\r\n     * Gets a specific Ackermann value if it exists\r\n     */\r\n    public getValue(m: number, n: number): bigint | undefined {\r\n      return this.nodes.get(AckermannStructure.getNodeKey(m, n))?.value;\r\n    }\r\n  }\r\n  \r\n  export default AckermannStructure;","import { Comparator } from '../storage/Heap';\r\n/**\r\n * Interface for tree node statistics\r\n */\r\ninterface NodeStats {\r\n  height: number;\r\n  size: number;\r\n  sum: bigint;\r\n  min: bigint;\r\n  max: bigint;\r\n}\r\n\r\n/**\r\n * Interface for tree traversal configuration\r\n */\r\ninterface TraversalConfig {\r\n  includeStats?: boolean;\r\n  skipSubtrees?: boolean;\r\n  maxDepth?: number;\r\n}\r\n\r\n/**\r\n * Class representing a node in the number tree\r\n */\r\nclass NumberNode {\r\n  value: bigint;\r\n  left: NumberNode | null;\r\n  right: NumberNode | null;\r\n  parent: NumberNode | null;\r\n  height: number;\r\n  size: number;\r\n  sum: bigint;\r\n\r\n  constructor(value: bigint | string | number) {\r\n    this.value = typeof value === 'bigint' ? value : BigInt(value);\r\n    this.left = null;\r\n    this.right = null;\r\n    this.parent = null;\r\n    this.height = 1;\r\n    this.size = 1;\r\n    this.sum = this.value;\r\n  }\r\n\r\n  /**\r\n   * Updates node statistics based on children\r\n   */\r\n  updateStats(): void {\r\n    this.height = 1 + Math.max(\r\n      this.left?.height ?? 0,\r\n      this.right?.height ?? 0\r\n    );\r\n    this.size = 1 + (this.left?.size ?? 0) + (this.right?.size ?? 0);\r\n    this.sum = this.value + \r\n      (this.left?.sum ?? BigInt(0)) + \r\n      (this.right?.sum ?? BigInt(0));\r\n  }\r\n\r\n  /**\r\n   * Gets balance factor of the node\r\n   */\r\n  getBalance(): number {\r\n    return (this.left?.height ?? 0) - (this.right?.height ?? 0);\r\n  }\r\n\r\n  /**\r\n   * Gets complete statistics for the node and its subtree\r\n   */\r\n  getStats(): NodeStats {\r\n    return {\r\n      height: this.height,\r\n      size: this.size,\r\n      sum: this.sum,\r\n      min: this.findMin().value,\r\n      max: this.findMax().value\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Finds minimum value node in the subtree\r\n   */\r\n  findMin(): NumberNode {\r\n    let current: NumberNode = this;\r\n    while (current.left) {\r\n      current = current.left;\r\n    }\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Finds maximum value node in the subtree\r\n   */\r\n  findMax(): NumberNode {\r\n    let current: NumberNode = this;\r\n    while (current.right) {\r\n      current = current.right;\r\n    }\r\n    return current;\r\n  }\r\n}\r\n\r\n/**\r\n * AVL Tree implementation specialized for handling large numbers\r\n */\r\nexport class NumberTree {\r\n  private root: NumberNode | null;\r\n  private readonly comparator: Comparator<bigint>;\r\n\r\n  constructor(comparator?: Comparator<bigint>) {\r\n    this.root = null;\r\n    this.comparator = comparator ?? ((a: bigint, b: bigint): -1 | 0 | 1 => {\r\n      if (a < b) return -1;\r\n      if (a > b) return 1;\r\n      return 0;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the root node if it exists\r\n   */\r\n  public getRoot(): NumberNode | null {\r\n    return this.root;\r\n  }\r\n\r\n  /**\r\n   * Inserts a new value into the tree\r\n   */\r\n  public insert(value: bigint | string | number): NumberNode {\r\n    const newValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    this.root = this.insertNode(this.root, newValue);\r\n    return this.find(newValue)!;\r\n  }\r\n\r\n  /**\r\n   * Recursively inserts a new node\r\n   */\r\n  private insertNode(node: NumberNode | null, value: bigint): NumberNode {\r\n    if (!node) {\r\n      return new NumberNode(value);\r\n    }\r\n\r\n    const compareResult = this.comparator(value, node.value);\r\n    if (compareResult < 0) {\r\n      node.left = this.insertNode(node.left, value);\r\n      node.left.parent = node;\r\n    } else if (compareResult > 0) {\r\n      node.right = this.insertNode(node.right, value);\r\n      node.right.parent = node;\r\n    } else {\r\n      return node; // Duplicate value, return existing node\r\n    }\r\n\r\n    node.updateStats();\r\n    return this.balance(node);\r\n  }\r\n\r\n  /**\r\n   * Balances a node using AVL rotations\r\n   */\r\n  private balance(node: NumberNode): NumberNode {\r\n    const balance = node.getBalance();\r\n\r\n    // Left heavy\r\n    if (balance > 1) {\r\n      if (node.left && node.left.getBalance() < 0) {\r\n        node.left = this.rotateLeft(node.left);\r\n      }\r\n      return this.rotateRight(node);\r\n    }\r\n\r\n    // Right heavy\r\n    if (balance < -1) {\r\n      if (node.right && node.right.getBalance() > 0) {\r\n        node.right = this.rotateRight(node.right);\r\n      }\r\n      return this.rotateLeft(node);\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  /**\r\n   * Performs left rotation\r\n   */\r\n  private rotateLeft(node: NumberNode): NumberNode {\r\n    const rightChild = node.right!;\r\n    const rightLeftChild = rightChild.left;\r\n\r\n    rightChild.left = node;\r\n    node.right = rightLeftChild;\r\n\r\n    if (rightLeftChild) {\r\n      rightLeftChild.parent = node;\r\n    }\r\n    rightChild.parent = node.parent;\r\n    node.parent = rightChild;\r\n\r\n    node.updateStats();\r\n    rightChild.updateStats();\r\n\r\n    return rightChild;\r\n  }\r\n\r\n  /**\r\n   * Performs right rotation\r\n   */\r\n  private rotateRight(node: NumberNode): NumberNode {\r\n    const leftChild = node.left!;\r\n    const leftRightChild = leftChild.right;\r\n\r\n    leftChild.right = node;\r\n    node.left = leftRightChild;\r\n\r\n    if (leftRightChild) {\r\n      leftRightChild.parent = node;\r\n    }\r\n    leftChild.parent = node.parent;\r\n    node.parent = leftChild;\r\n\r\n    node.updateStats();\r\n    leftChild.updateStats();\r\n\r\n    return leftChild;\r\n  }\r\n\r\n  /**\r\n   * Removes a value from the tree\r\n   */\r\n  public remove(value: bigint | string | number): boolean {\r\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    const nodeToRemove = this.find(searchValue);\r\n    \r\n    if (!nodeToRemove) {\r\n      return false;\r\n    }\r\n\r\n    this.root = this.removeNode(this.root, searchValue);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Recursively removes a node\r\n   */\r\n  private removeNode(node: NumberNode | null, value: bigint): NumberNode | null {\r\n    if (!node) {\r\n      return null;\r\n    }\r\n\r\n    const compareResult = this.comparator(value, node.value);\r\n    if (compareResult < 0) {\r\n      node.left = this.removeNode(node.left, value);\r\n      if (node.left) {\r\n        node.left.parent = node;\r\n      }\r\n    } else if (compareResult > 0) {\r\n      node.right = this.removeNode(node.right, value);\r\n      if (node.right) {\r\n        node.right.parent = node;\r\n      }\r\n    } else {\r\n      // Node to delete found\r\n      if (!node.left) {\r\n        return node.right;\r\n      }\r\n      if (!node.right) {\r\n        return node.left;\r\n      }\r\n\r\n      // Node has two children\r\n      const successor = node.right.findMin();\r\n      node.value = successor.value;\r\n      node.right = this.removeNode(node.right, successor.value);\r\n      if (node.right) {\r\n        node.right.parent = node;\r\n      }\r\n    }\r\n\r\n    node.updateStats();\r\n    return this.balance(node);\r\n  }\r\n\r\n  /**\r\n   * Finds a node by value\r\n   */\r\n  public find(value: bigint | string | number): NumberNode | null {\r\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\r\n    let current = this.root;\r\n\r\n    while (current) {\r\n      const compareResult = this.comparator(searchValue, current.value);\r\n      if (compareResult === 0) {\r\n        return current;\r\n      }\r\n      current = compareResult < 0 ? current.left : current.right;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Traverses the tree in specified order and returns values\r\n   */\r\n  public traverse(order: 'inOrder' | 'preOrder' | 'postOrder' = 'inOrder', \r\n                 config: TraversalConfig = {}): bigint[] {\r\n    const result: bigint[] = [];\r\n    \r\n    const traverse = (node: NumberNode | null, depth: number = 0): void => {\r\n      if (!node || (config.maxDepth !== undefined && depth >= config.maxDepth)) {\r\n        return;\r\n      }\r\n\r\n      if (order === 'preOrder') {\r\n        result.push(node.value);\r\n      }\r\n\r\n      if (!config.skipSubtrees) {\r\n        traverse(node.left, depth + 1);\r\n      }\r\n\r\n      if (order === 'inOrder') {\r\n        result.push(node.value);\r\n      }\r\n\r\n      if (!config.skipSubtrees) {\r\n        traverse(node.right, depth + 1);\r\n      }\r\n\r\n      if (order === 'postOrder') {\r\n        result.push(node.value);\r\n      }\r\n    };\r\n\r\n    traverse(this.root);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Gets overall tree statistics\r\n   */\r\n  public getTreeStats(): NodeStats | null {\r\n    return this.root?.getStats() ?? null;\r\n  }\r\n\r\n  /**\r\n   * Gets the nth smallest value in the tree\r\n   */\r\n  public getNthValue(n: number): bigint | null {\r\n    if (!this.root || n < 1 || n > this.root.size) {\r\n      return null;\r\n    }\r\n\r\n    const findNth = (node: NumberNode | null, position: number): bigint | null => {\r\n      if (!node) {\r\n        return null;\r\n      }\r\n\r\n      const leftSize = node.left?.size ?? 0;\r\n      \r\n      if (position === leftSize + 1) {\r\n        return node.value;\r\n      }\r\n      \r\n      if (position <= leftSize) {\r\n        return findNth(node.left, position);\r\n      }\r\n      \r\n      return findNth(node.right, position - leftSize - 1);\r\n    };\r\n\r\n    return findNth(this.root, n);\r\n  }\r\n\r\n  /**\r\n   * Gets a range of values between start and end (inclusive)\r\n   */\r\n  public getRange(start: bigint | string | number, \r\n                 end: bigint | string | number): bigint[] {\r\n    const startValue = typeof start === 'bigint' ? start : BigInt(start);\r\n    const endValue = typeof end === 'bigint' ? end : BigInt(end);\r\n    const result: bigint[] = [];\r\n\r\n    const collectRange = (node: NumberNode | null): void => {\r\n      if (!node) {\r\n        return;\r\n      }\r\n\r\n      if (this.comparator(node.value, startValue) >= 0 && \r\n          this.comparator(node.value, endValue) <= 0) {\r\n        collectRange(node.left);\r\n        result.push(node.value);\r\n        collectRange(node.right);\r\n      } else if (this.comparator(node.value, startValue) > 0) {\r\n        collectRange(node.left);\r\n      } else {\r\n        collectRange(node.right);\r\n      }\r\n    };\r\n\r\n    collectRange(this.root);\r\n    return result;\r\n  }\r\n}\r\n\r\nexport default NumberTree;","import { Comparator, MinHeap, MaxHeap } from '../storage/Heap';\r\n\r\n/**\r\n * Interface for segment tree node operations\r\n */\r\nexport interface SegmentTreeNode<T> {  value: T;\r\n  lazy?: T;\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\n/**\r\n * Type for BigArray operation result\r\n */\r\nexport type OperationResult<T> = {\r\n  success: boolean;\r\n  value?: T;\r\n  error?: string;\r\n};\r\n\r\n/**\r\n * Options for BigArray initialization\r\n */\r\nexport interface BigArrayOptions<T> {\r\n  initialCapacity?: number;\r\n  growthFactor?: number;\r\n  comparator?: Comparator<T>;\r\n}\r\n\r\n/**\r\n * A specialized array implementation for handling large numbers and providing\r\n * efficient operations with segment tree support\r\n */\r\nexport class BigArray<T> {\r\n  private data: T[];\r\n  private segmentTree: Array<SegmentTreeNode<T> | null>;\r\n  private readonly growthFactor: number;\r\n  private readonly comparator: Comparator<T>;\r\n  private size: number;\r\n  private capacity: number;\r\n\r\n  constructor(options: BigArrayOptions<T> = {}) {\r\n    const {\r\n      initialCapacity = 16,\r\n      growthFactor = 2,\r\n      comparator = ((a: T, b: T): -1 | 0 | 1 => {\r\n        if (a < b) return -1;\r\n        if (a > b) return 1;\r\n        return 0;\r\n      }) as Comparator<T>\r\n    } = options;\r\n\r\n    this.capacity = initialCapacity;\r\n    this.growthFactor = growthFactor;\r\n    this.comparator = comparator;\r\n    this.size = 0;\r\n    this.data = new Array(this.capacity);\r\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\r\n  }\r\n\r\n  /**\r\n   * Gets the current size of the array\r\n   */\r\n  public getSize(): number {\r\n    return this.size;\r\n  }\r\n\r\n  /**\r\n   * Gets the current capacity of the array\r\n   */\r\n  public getCapacity(): number {\r\n    return this.capacity;\r\n  }\r\n\r\n  /**\r\n   * Resizes the internal array when needed\r\n   */\r\n  private resize(newCapacity: number): void {\r\n    const newData = new Array(newCapacity);\r\n    for (let i = 0; i < this.size; i++) {\r\n      newData[i] = this.data[i];\r\n    }\r\n    this.data = newData;\r\n    this.capacity = newCapacity;\r\n    this.rebuildSegmentTree();\r\n  }\r\n\r\n  /**\r\n   * Appends an element to the end of the array\r\n   */\r\n  public push(value: T): OperationResult<number> {\r\n    try {\r\n      if (this.size >= this.capacity) {\r\n        this.resize(this.capacity * this.growthFactor);\r\n      }\r\n      this.data[this.size] = value;\r\n      this.updateSegmentTree(0, this.size, value);\r\n      this.size++;\r\n      return { success: true, value: this.size - 1 };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Unknown error during push'\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes and returns the last element\r\n   */\r\n  public pop(): OperationResult<T> {\r\n    if (this.size === 0) {\r\n      return { success: false, error: 'Array is empty' };\r\n    }\r\n\r\n    const value = this.data[this.size - 1];\r\n    this.size--;\r\n    \r\n    // Shrink array if it's too sparse\r\n    if (this.size < this.capacity / (this.growthFactor * 2)) {\r\n      this.resize(Math.max(16, Math.floor(this.capacity / this.growthFactor)));\r\n    }\r\n\r\n    return { success: true, value };\r\n  }\r\n\r\n  /**\r\n   * Gets element at specified index\r\n   */\r\n  public get(index: number): OperationResult<T> {\r\n    if (index < 0 || index >= this.size) {\r\n      return { success: false, error: 'Index out of bounds' };\r\n    }\r\n    return { success: true, value: this.data[index] };\r\n  }\r\n\r\n  /**\r\n   * Sets element at specified index\r\n   */\r\n  public set(index: number, value: T): OperationResult<T> {\r\n    if (index < 0 || index >= this.size) {\r\n      return { success: false, error: 'Index out of bounds' };\r\n    }\r\n    \r\n    const oldValue = this.data[index];\r\n    this.data[index] = value;\r\n    this.updateSegmentTree(0, index, value);\r\n    \r\n    return { success: true, value: oldValue };\r\n  }\r\n\r\n  /**\r\n   * Rebuilds the segment tree after major changes\r\n   */\r\n  private rebuildSegmentTree(): void {\r\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\r\n    if (this.size > 0) {\r\n      this.buildSegmentTree(0, 0, this.size - 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Builds a segment tree node recursively\r\n   */\r\n  private buildSegmentTree(node: number, start: number, end: number): void {\r\n    if (start === end) {\r\n      this.segmentTree[node] = {\r\n        value: this.data[start] as T,\r\n        start,\r\n        end\r\n      };\r\n      return;\r\n    }\r\n\r\n    const mid = Math.floor((start + end) / 2);\r\n    this.buildSegmentTree(2 * node + 1, start, mid);\r\n    this.buildSegmentTree(2 * node + 2, mid + 1, end);\r\n\r\n    const leftNode = this.segmentTree[2 * node + 1];\r\n    const rightNode = this.segmentTree[2 * node + 2];\r\n\r\n    if (leftNode && rightNode) {\r\n      this.segmentTree[node] = {\r\n        value: this.comparator(leftNode.value, rightNode.value) >= 0 \r\n          ? leftNode.value \r\n          : rightNode.value,\r\n        start,\r\n        end\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates the segment tree after a value change\r\n   */\r\n  private updateSegmentTree(node: number, index: number, value: T): void {\r\n    if (!this.segmentTree[node]) {\r\n      return;\r\n    }\r\n\r\n    const currentNode = this.segmentTree[node]!;\r\n    if (currentNode.start === currentNode.end) {\r\n      currentNode.value = value;\r\n      return;\r\n    }\r\n\r\n    const mid = Math.floor((currentNode.start + currentNode.end) / 2);\r\n    if (index <= mid) {\r\n      this.updateSegmentTree(2 * node + 1, index, value);\r\n    } else {\r\n      this.updateSegmentTree(2 * node + 2, index, value);\r\n    }\r\n\r\n    const leftNode = this.segmentTree[2 * node + 1];\r\n    const rightNode = this.segmentTree[2 * node + 2];\r\n\r\n    if (leftNode && rightNode) {\r\n      currentNode.value = this.comparator(leftNode.value, rightNode.value) >= 0 \r\n        ? leftNode.value \r\n        : rightNode.value;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Queries the maximum value in a range\r\n   */\r\n  public queryRange(start: number, end: number): OperationResult<T> {\r\n    if (start < 0 || end >= this.size || start > end) {\r\n      return { success: false, error: 'Invalid range' };\r\n    }\r\n\r\n    const result = this.querySegmentTree(0, start, end);\r\n    return result \r\n      ? { success: true, value: result }\r\n      : { success: false, error: 'Range query failed' };\r\n  }\r\n\r\n  /**\r\n   * Recursively queries the segment tree\r\n   */\r\n  private querySegmentTree(node: number, queryStart: number, queryEnd: number): T | null {\r\n    const currentNode = this.segmentTree[node];\r\n    if (!currentNode) {\r\n      return null;\r\n    }\r\n\r\n    if (queryStart <= currentNode.start && queryEnd >= currentNode.end) {\r\n      return currentNode.value;\r\n    }\r\n\r\n    if (queryEnd < currentNode.start || queryStart > currentNode.end) {\r\n      return null;\r\n    }\r\n\r\n    const leftResult = this.querySegmentTree(2 * node + 1, queryStart, queryEnd);\r\n    const rightResult = this.querySegmentTree(2 * node + 2, queryStart, queryEnd);\r\n\r\n    if (leftResult === null) return rightResult;\r\n    if (rightResult === null) return leftResult;\r\n\r\n    return this.comparator(leftResult, rightResult) >= 0 ? leftResult : rightResult;\r\n  }\r\n\r\n  /**\r\n   * Creates a heap from the current array\r\n   */\r\n  public toHeap(isMin: boolean = true): MinHeap<T> | MaxHeap<T> {\r\n    const heap = isMin \r\n      ? new MinHeap<T>(this.comparator)\r\n      : new MaxHeap<T>(this.comparator);\r\n      \r\n    for (let i = 0; i < this.size; i++) {\r\n      if (this.data[i] !== undefined) {\r\n        if (this.data[i] !== undefined) {\r\n          heap.push(this.data[i] as T);\r\n        }\r\n      }\r\n    }\r\n    \r\n    return heap;\r\n  }\r\n\r\n  /**\r\n   * Sorts the array in-place\r\n   */\r\n  public sort(ascending: boolean = true): void {\r\n    const heap = this.toHeap(!ascending);\r\n    for (let i = this.size - 1; i >= 0; i--) {\r\n      const value = heap.pop();\r\n      if (value !== undefined) {\r\n        this.data[i] = value;\r\n      }\r\n    }\r\n    this.rebuildSegmentTree();\r\n  }\r\n\r\n  /**\r\n   * Returns array as native array\r\n   */\r\n  public toArray(): T[] {\r\n    return this.data.slice(0, this.size);\r\n  }\r\n}\r\n\r\nexport default BigArray;","import { validateNonNegative, ValidationError, OverflowError } from '../utils/validation';\r\n\r\n/**\r\n * Interface for power tower computation options\r\n */\r\ninterface PowerTowerOptions {\r\n  maxHeight?: number;\r\n  maxValue?: bigint;\r\n  checkOverflow?: boolean;\r\n  precision?: number;\r\n}\r\n\r\n/**\r\n * Interface for power tower node to track computation state\r\n */\r\ninterface PowerTowerNode {\r\n  value: bigint;\r\n  height: number;\r\n  evaluated: boolean;\r\n  previous: PowerTowerNode | null;\r\n  next: PowerTowerNode | null;\r\n}\r\n\r\n/**\r\n * Default options for power tower computations\r\n */\r\nconst DEFAULT_OPTIONS: Required<PowerTowerOptions> = {\r\n  maxHeight: 100,\r\n  maxValue: BigInt(Number.MAX_SAFE_INTEGER),\r\n  checkOverflow: true,\r\n  precision: 0\r\n};\r\n\r\n/**\r\n * Class representing a power tower (tetration) computation structure\r\n * Handles expressions of the form: ab = a^(a^(a^...)) (b times)\r\n */\r\nexport class PowerTower {\r\n  private readonly options: Required<PowerTowerOptions>;\r\n  private head: PowerTowerNode | null;\r\n  private tail: PowerTowerNode | null;\r\n  private size: number;\r\n\r\n  constructor(options: PowerTowerOptions = {}) {\r\n    this.options = { ...DEFAULT_OPTIONS, ...options };\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  /**\r\n   * Creates a new power tower node\r\n   */\r\n  private createNode(value: bigint, height: number): PowerTowerNode {\r\n    return {\r\n      value,\r\n      height,\r\n      evaluated: false,\r\n      previous: null,\r\n      next: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validates power tower height\r\n   */\r\n  private validateHeight(height: number): void {\r\n    if (height < 0) {\r\n      throw new ValidationError('Height cannot be negative');\r\n    }\r\n    if (height > this.options.maxHeight) {\r\n      throw new ValidationError(`Height exceeds maximum of ${this.options.maxHeight}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validates value for computation\r\n   */\r\n  private validateValue(value: bigint): void {\r\n    validateNonNegative(value);\r\n    if (this.options.checkOverflow && value > this.options.maxValue) {\r\n      throw new OverflowError(`Value exceeds maximum of ${this.options.maxValue}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Computes power with overflow checking\r\n   */\r\n  private computePower(base: bigint, exponent: bigint): bigint {\r\n    if (exponent === BigInt(0)) {\r\n      return BigInt(1);\r\n    }\r\n    if (exponent === BigInt(1)) {\r\n      return base;\r\n    }\r\n\r\n    let result = base;\r\n    for (let i = BigInt(1); i < exponent; i++) {\r\n      if (this.options.checkOverflow) {\r\n        // Check if next multiplication would overflow\r\n        const next = result * base;\r\n        if (next > this.options.maxValue) {\r\n          throw new OverflowError('Power computation would overflow');\r\n        }\r\n        result = next;\r\n      } else {\r\n        result *= base;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Builds a power tower of specified height with given base\r\n   */\r\n  public build(base: bigint | number | string, height: number): void {\r\n    this.validateHeight(height);\r\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\r\n    this.validateValue(baseValue);\r\n\r\n    this.clear(); // Clear existing tower\r\n\r\n    for (let i = 0; i < height; i++) {\r\n      const node = this.createNode(baseValue, i + 1);\r\n      if (!this.head) {\r\n        this.head = node;\r\n        this.tail = node;\r\n      } else {\r\n        node.previous = this.tail;\r\n        this.tail!.next = node;\r\n        this.tail = node;\r\n      }\r\n      this.size++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluates the power tower up to specified height\r\n   */\r\n  public evaluate(height?: number): bigint {\r\n    if (!this.head) {\r\n      return BigInt(1); // Empty tower evaluates to 1\r\n    }\r\n\r\n    const targetHeight = height ?? this.size;\r\n    this.validateHeight(targetHeight);\r\n\r\n    let current = this.head;\r\n    let result = current.value;\r\n    let currentHeight = 1;\r\n\r\n    try {\r\n      while (current.next && currentHeight < targetHeight) {\r\n        result = this.computePower(current.next.value, result);\r\n        current.evaluated = true;\r\n        current = current.next;\r\n        currentHeight++;\r\n      }\r\n      current.evaluated = true;\r\n      return result;\r\n    } catch (error) {\r\n      if (error instanceof OverflowError) {\r\n        // Mark nodes up to current height as evaluated\r\n        let node = this.head;\r\n        while (node !== current) {\r\n          node.evaluated = true;\r\n          node = node.next!;\r\n        }\r\n        throw error;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the current height of the power tower\r\n   */\r\n  public getHeight(): number {\r\n    return this.size;\r\n  }\r\n\r\n  /**\r\n   * Checks if the tower can be evaluated to a given height\r\n   */\r\n  public isComputable(height?: number): boolean {\r\n    try {\r\n      const targetHeight = height ?? this.size;\r\n      this.validateHeight(targetHeight);\r\n      \r\n      // Check first few levels without full computation\r\n      let current = this.head;\r\n      let currentHeight = 0;\r\n      \r\n      while (current && currentHeight < targetHeight) {\r\n        // Quick check for obvious overflow conditions\r\n        if (current.value > BigInt(4) && currentHeight > 3) {\r\n          return false;\r\n        }\r\n        current = current.next;\r\n        currentHeight++;\r\n      }\r\n      \r\n      // Try actual computation with a lower overflow threshold\r\n      const safeOptions = { ...this.options, maxValue: this.options.maxValue >> BigInt(1) };\r\n      const safeTower = new PowerTower(safeOptions);\r\n      safeTower.build(this.head!.value, targetHeight);\r\n      safeTower.evaluate();\r\n      \r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the computation state at each level\r\n   */\r\n  public getState(): { height: number; value: bigint; evaluated: boolean }[] {\r\n    const state = [];\r\n    let current = this.head;\r\n    \r\n    while (current) {\r\n      state.push({\r\n        height: current.height,\r\n        value: current.value,\r\n        evaluated: current.evaluated\r\n      });\r\n      current = current.next;\r\n    }\r\n    \r\n    return state;\r\n  }\r\n\r\n  /**\r\n   * Clears the power tower\r\n   */\r\n  public clear(): void {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.size = 0;\r\n  }\r\n\r\n  /**\r\n   * Gets the maximum computationally feasible height for a given base\r\n   */\r\n  public static getMaxFeasibleHeight(base: bigint | number | string): number {\r\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\r\n    validateNonNegative(baseValue);\r\n\r\n    if (baseValue === BigInt(0)) return 0;\r\n    if (baseValue === BigInt(1)) return Infinity;\r\n    if (baseValue === BigInt(2)) return 4; // 24 is already enormous\r\n    if (baseValue === BigInt(3)) return 3; // 33 is already astronomical\r\n    if (baseValue === BigInt(4)) return 2;\r\n    return 1; // For bases > 4, only height 1 is reliably computable\r\n  }\r\n\r\n  /**\r\n   * Creates a string representation of the power tower\r\n   */\r\n  public toString(): string {\r\n    if (!this.head) {\r\n      return \"Empty Tower\";\r\n    }\r\n\r\n    let result = this.head.value.toString();\r\n    let current = this.head;\r\n    \r\n    while (current.next) {\r\n      result = `${current.next.value}^(${result})`;\r\n      current = current.next;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n}\r\n\r\nexport default PowerTower;","/**\r\n * Formatting utilities for Hypernum library\r\n * Provides functions for formatting large numbers and converting between different representations\r\n */\r\n\r\nimport { ValidationError } from './validation';\r\n\r\n// Types for formatting options\r\nexport interface FormatOptions {\r\n  notation?: 'standard' | 'scientific' | 'engineering' | 'compact';\r\n  precision?: number;\r\n  grouping?: boolean;\r\n  groupSize?: number;\r\n  decimalSeparator?: string;\r\n  groupSeparator?: string;\r\n}\r\n\r\nexport interface ScientificNotation {\r\n  coefficient: string;\r\n  exponent: number;\r\n}\r\n\r\nexport interface ScientificNotation {\r\n  coefficient: string;\r\n  exponent: number;\r\n}\r\n\r\n// Default formatting options\r\nconst DEFAULT_OPTIONS: Required<FormatOptions> = {\r\n  notation: 'standard',\r\n  precision: 0,\r\n  grouping: true,\r\n  groupSize: 3,\r\n  decimalSeparator: '.',\r\n  groupSeparator: ',',\r\n};\r\n\r\n/**\r\n * Formats a BigInt value according to specified options\r\n */\r\nexport const formatBigInt = (value: bigint, options: FormatOptions = {}): string => {\r\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\r\n  \r\n  // Handle negative numbers\r\n  const isNegative = value < BigInt(0);\r\n  const absValue = isNegative ? -value : value;\r\n  \r\n  let result: string;\r\n  switch (opts.notation) {\r\n    case 'scientific':\r\n      result = formatScientific(absValue, opts).coefficient + 'e' + \r\n               formatScientific(absValue, opts).exponent;\r\n      break;\r\n    case 'engineering':\r\n      result = formatEngineering(absValue, opts);\r\n      break;\r\n    case 'compact':\r\n      result = formatCompact(absValue, opts);\r\n      break;\r\n    default:\r\n      result = formatStandard(absValue, opts);\r\n  }\r\n  \r\n  return isNegative ? '-' + result : result;\r\n};\r\n\r\n/**\r\n * Formats a number in standard notation with grouping\r\n */\r\nconst formatStandard = (value: bigint, options: Required<FormatOptions>): string => {\r\n  let str = value.toString();\r\n  \r\n  if (!options.grouping) {\r\n    return str;\r\n  }\r\n  \r\n  // Apply grouping from the right\r\n  const result: string[] = [];\r\n  let position = str.length;\r\n  \r\n  while (position > 0) {\r\n    const start = Math.max(0, position - options.groupSize);\r\n    result.unshift(str.slice(start, position));\r\n    position = start;\r\n  }\r\n  \r\n  return result.join(options.groupSeparator);\r\n};\r\n\r\n/**\r\n * Converts a number to scientific notation\r\n */\r\nconst formatScientific = (value: bigint, options: Required<FormatOptions>): ScientificNotation => {\r\n  if (value === BigInt(0)) {\r\n    return { coefficient: '0', exponent: 0 };\r\n  }\r\n  \r\n  const str = value.toString();\r\n  const exponent = str.length - 1;\r\n  \r\n  let coefficient = str[0] || '';\r\n  coefficient += options.decimalSeparator + str.slice(1, options.precision + 1);\r\n  \r\n  return {\r\n    coefficient: coefficient,\r\n    exponent: exponent,\r\n  };\r\n};\r\n\r\n/**\r\n * Formats a number in engineering notation (exponents divisible by 3)\r\n */\r\nconst formatEngineering = (value: bigint, options: Required<FormatOptions>): string => {\r\n  if (value === BigInt(0)) {\r\n    return '0';\r\n  }\r\n  \r\n  const str = value.toString();\r\n  const len = str.length;\r\n  const exponent = Math.floor((len - 1) / 3) * 3;\r\n  \r\n  let coefficient = '';\r\n  const digitsBeforePoint = len - exponent;\r\n  \r\n  for (let i = 0; i < Math.min(len, digitsBeforePoint + options.precision); i++) {\r\n    if (i === digitsBeforePoint && i < len) {\r\n      coefficient += options.decimalSeparator;\r\n    }\r\n    coefficient += str[i];\r\n  }\r\n  \r\n  return `${coefficient}e${exponent}`;\r\n};\r\n\r\n/**\r\n * Formats a number in compact notation (K, M, B, T)\r\n */\r\nconst formatCompact = (value: bigint, options: Required<FormatOptions>): string => {\r\n  const suffixes = ['', 'K', 'M', 'B', 'T', 'Q'];\r\n  const str = value.toString();\r\n  const len = str.length;\r\n  \r\n  if (len <= 3) {\r\n    return formatStandard(value, options);\r\n  }\r\n  \r\n  const suffixIndex = Math.min(Math.floor((len - 1) / 3), suffixes.length - 1);\r\n  const suffix = suffixes[suffixIndex];\r\n  \r\n  const scale = BigInt(10) ** BigInt(suffixIndex * 3);\r\n  const scaledValue = value / scale;\r\n  \r\n  let result = scaledValue.toString();\r\n  if (options.precision > 0) {\r\n    const remainder = value % scale;\r\n    if (remainder > BigInt(0)) {\r\n      const decimalPart = remainder.toString().padStart(3, '0').slice(0, options.precision);\r\n      result += options.decimalSeparator + decimalPart;\r\n    }\r\n  }\r\n  \r\n  return result + suffix;\r\n};\r\n\r\n/**\r\n * Parses a formatted string back to BigInt\r\n */\r\nexport const parseBigIntString = (str: string, options: FormatOptions = {}): bigint => {\r\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\r\n  \r\n  // Remove grouping separators\r\n  let cleanStr = str.replace(new RegExp(`\\\\${opts.groupSeparator}`, 'g'), '');\r\n  \r\n  // Handle scientific notation\r\n  if (cleanStr.toLowerCase().includes('e')) {\r\n    const [coefficient, exponent] = cleanStr.toLowerCase().split('e');\r\n    const base = BigInt(10);\r\n    const exp = BigInt(exponent || '0');\r\n    return BigInt(Math.floor(Number(coefficient))) * (base ** exp);\r\n  }\r\n  \r\n  // Handle suffixes\r\n  const suffixMap = new Map([\r\n    ['k', BigInt(1000)],\r\n    ['m', BigInt(1000000)],\r\n    ['b', BigInt(1000000000)],\r\n    ['t', BigInt(1000000000000)],\r\n    ['q', BigInt(1000000000000000)],\r\n  ]);\r\n  \r\n  const suffix = cleanStr.slice(-1).toLowerCase();\r\n  const multiplier = suffixMap.get(suffix);\r\n  if (multiplier) {\r\n    cleanStr = cleanStr.slice(0, -1);\r\n    const value = BigInt(Math.floor(Number(cleanStr)));\r\n    return value * multiplier;\r\n  }\r\n  \r\n  // Handle regular numbers\r\n  return BigInt(cleanStr);\r\n};\r\n\r\n/**\r\n * Normalizes a string representation for comparison\r\n */\r\nexport const normalizeNumberString = (str: string): string => {\r\n  // Remove all spaces and separators\r\n  str = str.replace(/[\\s,]/g, '');\r\n  \r\n  // Handle scientific notation\r\n  if (str.toLowerCase().includes('e')) {\r\n    const [coefficient, exponent] = str.toLowerCase().split('e');\r\n    const exp = parseInt(exponent || '0');\r\n    const coef = parseFloat(coefficient || '0');\r\n    return (coef * Math.pow(10, exp)).toString();\r\n  }\r\n  \r\n  return str;\r\n};\r\n\r\n/**\r\n * Formats a number for display in a tree structure\r\n */\r\nexport const formatTreeValue = (value: bigint, depth: number = 0): string => {\r\n  const indent = '  '.repeat(depth);\r\n  return `${indent}${formatBigInt(value, { notation: 'compact' })}`;\r\n};\r\n\r\n/**\r\n * Formats a range of numbers for display\r\n */\r\nexport const formatRange = (start: bigint, end: bigint, options: FormatOptions = {}): string => {\r\n  return `[${formatBigInt(start, options)} ... ${formatBigInt(end, options)}]`;\r\n};\r\n\r\n/**\r\n * Formats a percentage\r\n */\r\nexport const formatPercentage = (value: bigint, total: bigint, precision: number = 2): string => {\r\n  if (total === BigInt(0)) {\r\n    throw new ValidationError('Cannot calculate percentage with zero total');\r\n  }\r\n  \r\n  const percentage = (Number(value) * 100) / Number(total);\r\n  return `${percentage.toFixed(precision)}%`;\r\n};","/**\r\n * Main Hypernum class that provides a high-level interface to all library functionality\r\n */\r\n\r\n\r\nimport {\r\n  DEFAULT_OPTIONS,\r\n  FEATURES,\r\n  MAX_PRECISION,\r\n  MAX_COMPUTATION_STEPS\r\n} from './constants';\r\nimport { \r\n  HypernumError, \r\n  ValidationError, \r\n  OverflowError \r\n} from './errors';\r\n\r\n\r\n// Import all operations and structures\r\nimport * as arithmetic from '../operations/arithmetic';\r\nimport * as bitwise from '../operations/bitwise';\r\nimport * as power from '../operations/power';\r\nimport { BigArray, NumberTree, AckermannStructure } from '../structures';\r\nimport * as formatting from '../utils/formatting';\r\nimport * as validation from '../utils/validation';\r\nimport * as precision from '../utils/precision';\r\nimport { MinHeap, MaxHeap } from '@/storage';\r\n/**\r\n * Configuration options for Hypernum instance\r\n */\r\nexport interface HypernumConfig {\r\n  precision?: number;\r\n  roundingMode?: precision.RoundingMode;\r\n  checkOverflow?: boolean;\r\n  maxSteps?: number;\r\n  debug?: boolean;\r\n}\r\n\r\nexport class Hypernum {\r\n  private readonly config: Required<HypernumConfig>;\r\n  private readonly structures: {\r\n    arrays: Map<string, BigArray<bigint>>;\r\n    trees: Map<string, NumberTree>;\r\n    heaps: Map<string, MinHeap<bigint> | MaxHeap<bigint>>;\r\n  };\r\n\r\n  constructor(config: HypernumConfig = {}) {\r\n    this.config = {\r\n      precision: config.precision ?? DEFAULT_OPTIONS.precision,\r\n      roundingMode: config.roundingMode ?? DEFAULT_OPTIONS.roundingMode as precision.RoundingMode,\r\n      checkOverflow: config.checkOverflow ?? DEFAULT_OPTIONS.checkOverflow,\r\n      maxSteps: config.maxSteps ?? DEFAULT_OPTIONS.maxSteps,\r\n      debug: config.debug ?? FEATURES.DEBUG_MODE\r\n    };\r\n\r\n    // Validate configuration\r\n    if (this.config.precision < 0 || this.config.precision > MAX_PRECISION) {\r\n      throw new ValidationError(`Precision must be between 0 and ${MAX_PRECISION}`);\r\n    }\r\n    if (this.config.maxSteps < 1 || this.config.maxSteps > MAX_COMPUTATION_STEPS) {\r\n      throw new ValidationError(`Max steps must be between 1 and ${MAX_COMPUTATION_STEPS}`);\r\n    }\r\n\r\n    // Initialize data structure storage\r\n    this.structures = {\r\n      arrays: new Map(),\r\n      trees: new Map(),\r\n      heaps: new Map()\r\n    };\r\n  }\r\n\r\n  // Arithmetic Operations\r\n  public add(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.add(a, b, this.config);\r\n  }\r\n\r\n  public subtract(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.subtract(a, b, this.config);\r\n  }\r\n\r\n  public multiply(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.multiply(a, b, this.config);\r\n  }\r\n\r\n  public divide(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.divide(a, b, this.config);\r\n  }\r\n\r\n  public mod(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return arithmetic.remainder(a, b, this.config);\r\n  }\r\n\r\n  // Power Operations\r\n  public power(base: bigint | string | number, exponent: bigint | string | number): bigint {\r\n    return power.power(base, exponent, this.config);\r\n  }\r\n\r\n  public sqrt(value: bigint | string | number): bigint {\r\n    return power.sqrt(value, this.config);\r\n  }\r\n\r\n  public nthRoot(value: bigint | string | number, n: bigint | string | number): bigint {\r\n    return power.nthRoot(value, n, this.config);\r\n  }\r\n\r\n  // Bitwise Operations\r\n  public and(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return bitwise.and(a, b);\r\n  }\r\n\r\n  public or(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return bitwise.or(a, b);\r\n  }\r\n\r\n  public xor(a: bigint | string | number, b: bigint | string | number): bigint {\r\n    return bitwise.xor(a, b);\r\n  }\r\n\r\n  public not(value: bigint | string | number): bigint {\r\n    return bitwise.not(value);\r\n  }\r\n\r\n  // Data Structure Management\r\n  public createArray(id: string): BigArray<bigint> {\r\n    if (this.structures.arrays.has(id)) {\r\n      throw new ValidationError(`Array with id '${id}' already exists`);\r\n    }\r\n    const array = new BigArray<bigint>();\r\n    this.structures.arrays.set(id, array);\r\n    return array;\r\n  }\r\n\r\n  public getArray(id: string): BigArray<bigint> {\r\n    const array = this.structures.arrays.get(id);\r\n    if (!array) {\r\n      throw new ValidationError(`Array with id '${id}' not found`);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  public createTree(id: string): NumberTree {\r\n    if (this.structures.trees.has(id)) {\r\n      throw new ValidationError(`Tree with id '${id}' already exists`);\r\n    }\r\n    const tree = new NumberTree();\r\n    this.structures.trees.set(id, tree);\r\n    return tree;\r\n  }\r\n\r\n  public getTree(id: string): NumberTree {\r\n    const tree = this.structures.trees.get(id);\r\n    if (!tree) {\r\n      throw new ValidationError(`Tree with id '${id}' not found`);\r\n    }\r\n    return tree;\r\n  }\r\n\r\n  public createHeap(id: string, isMinHeap: boolean = true): MinHeap<bigint> | MaxHeap<bigint> {\r\n    if (this.structures.heaps.has(id)) {\r\n      throw new ValidationError(`Heap with id '${id}' already exists`);\r\n    }\r\n    const heap = isMinHeap ? new MinHeap<bigint>(this.compareValues) : new MaxHeap<bigint>(this.compareValues);\r\n    this.structures.heaps.set(id, heap);\r\n    return heap;\r\n  }\r\n\r\n  public getHeap(id: string): MinHeap<bigint> | MaxHeap<bigint> {\r\n    const heap = this.structures.heaps.get(id);\r\n    if (!heap) {\r\n      throw new ValidationError(`Heap with id '${id}' not found`);\r\n    }\r\n    return heap;\r\n  }\r\n\r\n  // Special Functions\r\n  public createAckermannStructure(): AckermannStructure {\r\n    return new AckermannStructure();\r\n  }\r\n\r\n  // Formatting and Validation\r\n  public format(value: bigint | string | number, options?: formatting.FormatOptions): string {\r\n    const bigValue = validation.toBigInt(value);\r\n    return formatting.formatBigInt(bigValue, options);\r\n  }\r\n\r\n  public validate(value: unknown): boolean {\r\n    try {\r\n      validation.toBigInt(value);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Configuration Management\r\n  public updateConfig(newConfig: Partial<HypernumConfig>): void {\r\n    Object.assign(this.config, newConfig);\r\n  }\r\n\r\n  public getConfig(): Readonly<Required<HypernumConfig>> {\r\n    return { ...this.config };\r\n  }\r\n\r\n  // Utility Functions\r\n  private compareValues(a: bigint, b: bigint): -1 | 0 | 1 {\r\n    if (a < b) return -1;\r\n    if (a > b) return 1;\r\n    return 0;\r\n  }\r\n\r\n  // Cleanup\r\n  public dispose(): void {\r\n    this.structures.arrays.clear();\r\n    this.structures.trees.clear();\r\n    this.structures.heaps.clear();\r\n  }\r\n}\r\n\r\n// Export additional types and utilities\r\nexport {\r\n  HypernumError,\r\n  ValidationError,\r\n  OverflowError,\r\n  precision,\r\n  formatting,\r\n  validation\r\n};\r\n\r\nexport default Hypernum;","/**\r\n * Comparison operations module for Hypernum library\r\n * Provides functions for comparing large numbers with precision support\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n    normalizePrecision,\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for comparison operations\r\n   */\r\n  export interface ComparisonOptions {\r\n    precision?: number;\r\n    roundingMode?: RoundingMode;\r\n    tolerance?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ComparisonOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    tolerance: 0\r\n  };\r\n  \r\n  /**\r\n   * Result type for comparison operations\r\n   * -1: first value is less than second value\r\n   *  0: values are equal\r\n   *  1: first value is greater than second value\r\n   */\r\n  export type ComparisonResult = -1 | 0 | 1;\r\n  \r\n  /**\r\n   * Compares two numbers with optional precision\r\n   */\r\n  export function compare(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): ComparisonResult {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigA = toBigInt(a);\r\n    const bigB = toBigInt(b);\r\n  \r\n    if (opts.precision === 0 && opts.tolerance === 0) {\r\n      if (bigA < bigB) return -1;\r\n      if (bigA > bigB) return 1;\r\n      return 0;\r\n    }\r\n  \r\n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\r\n    \r\n    if (opts.tolerance > 0) {\r\n      const diff = scaledA - scaledB;\r\n      const toleranceValue = BigInt(10) ** BigInt(opts.tolerance);\r\n      \r\n      if (diff < -toleranceValue) return -1;\r\n      if (diff > toleranceValue) return 1;\r\n      return 0;\r\n    }\r\n  \r\n    if (scaledA < scaledB) return -1;\r\n    if (scaledA > scaledB) return 1;\r\n    return 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if two numbers are equal\r\n   */\r\n  export function equals(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is less than second\r\n   */\r\n  export function lessThan(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === -1;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is less than or equal to second\r\n   */\r\n  export function lessThanOrEqual(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    const result = compare(a, b, options);\r\n    return result === -1 || result === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is greater than second\r\n   */\r\n  export function greaterThan(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return compare(a, b, options) === 1;\r\n  }\r\n  \r\n  /**\r\n   * Checks if first number is greater than or equal to second\r\n   */\r\n  export function greaterThanOrEqual(\r\n    a: bigint | string | number,\r\n    b: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    const result = compare(a, b, options);\r\n    return result === 1 || result === 0;\r\n  }\r\n  \r\n  /**\r\n   * Checks if a number is between two others (inclusive)\r\n   */\r\n  export function between(\r\n    value: bigint | string | number,\r\n    min: bigint | string | number,\r\n    max: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    return greaterThanOrEqual(value, min, options) && lessThanOrEqual(value, max, options);\r\n  }\r\n  \r\n  /**\r\n   * Finds the maximum value in an array of numbers\r\n   */\r\n  export function max(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    if (values.length === 0) {\r\n      throw new ValidationError('Cannot find maximum of empty array');\r\n    }\r\n  \r\n    return values.reduce<bigint>((max, current) => {\r\n      const bigMax = toBigInt(max);\r\n      const bigCurrent = toBigInt(current);\r\n      return greaterThan(bigCurrent, bigMax, options) ? bigCurrent : bigMax;\r\n    }, toBigInt(values[0]));\r\n  }\r\n  \r\n  /**\r\n   * Finds the minimum value in an array of numbers\r\n   */\r\n  export function min(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    if (values.length === 0) {\r\n      throw new ValidationError('Cannot find minimum of empty array');\r\n    }\r\n  \r\n    return values.reduce<bigint>((min, current) => {\r\n      const bigMin = toBigInt(min);\r\n      const bigCurrent = toBigInt(current);\r\n      return lessThan(bigCurrent, bigMin, options) ? bigCurrent : bigMin;\r\n    }, toBigInt(values[0]));\r\n  }\r\n  \r\n  /**\r\n   * Clamps a value between minimum and maximum bounds\r\n   */\r\n  export function clamp(\r\n    value: bigint | string | number,\r\n    min: bigint | string | number,\r\n    max: bigint | string | number,\r\n    options: ComparisonOptions = {}\r\n  ): bigint {\r\n    const bigValue = toBigInt(value);\r\n    const bigMin = toBigInt(min);\r\n    const bigMax = toBigInt(max);\r\n  \r\n    if (lessThan(bigMax, bigMin, options)) {\r\n      throw new ValidationError('Maximum bound must be greater than or equal to minimum bound');\r\n    }\r\n  \r\n    if (lessThan(bigValue, bigMin, options)) return bigMin;\r\n    if (greaterThan(bigValue, bigMax, options)) return bigMax;\r\n    return bigValue;\r\n  }\r\n  \r\n  /**\r\n   * Checks if all values in array are equal within tolerance\r\n   */\r\n  export function allEqual(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    const first = toBigInt(values[0]);\r\n    return values.every(value => equals(value, first, options));\r\n  }\r\n  \r\n  /**\r\n   * Checks if values are in ascending order\r\n   */\r\n  export function isAscending(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    for (let i = 1; i < values.length; i++) {\r\n      if (values[i] === undefined || values[i - 1] === undefined || !greaterThanOrEqual(values[i]!, values[i - 1]!, options)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Checks if values are in descending order\r\n   */\r\n  export function isDescending(\r\n    values: Array<bigint | string | number>,\r\n    options: ComparisonOptions = {}\r\n  ): boolean {\r\n    if (values.length <= 1) return true;\r\n  \r\n    for (let i = 1; i < values.length; i++) {\r\n      if (values[i] === undefined || values[i - 1] === undefined || !lessThanOrEqual(values[i]!, values[i - 1]!, options)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  /**\r\n   * Creates a comparator function for sorting\r\n   */\r\n  export function createComparator(\r\n    options: ComparisonOptions = {}\r\n  ): (a: bigint | string | number, b: bigint | string | number) => number {\r\n    return (a, b) => compare(a, b, options);\r\n  }\r\n  \r\n  export default {\r\n    compare,\r\n    equals,\r\n    lessThan,\r\n    lessThanOrEqual,\r\n    greaterThan,\r\n    greaterThanOrEqual,\r\n    between,\r\n    max,\r\n    min,\r\n    clamp,\r\n    allEqual,\r\n    isAscending,\r\n    isDescending,\r\n    createComparator\r\n  };","/**\r\n * Conversion operations module for Hypernum library\r\n * Provides functions for converting numbers between different formats and bases\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n  } from '../utils/validation';\r\n  \r\n  import {\r\n    RoundingMode,\r\n\r\n  } from '../utils/precision';\r\n  \r\n  /**\r\n   * Options for conversion operations\r\n   */\r\n  export interface ConversionOptions {\r\n    /** Precision for decimal operations */\r\n    precision?: number;\r\n    /** Rounding mode for decimal operations */\r\n    roundingMode?: RoundingMode;\r\n    /** Whether to use uppercase for hex/base-N output */\r\n    uppercase?: boolean;\r\n    /** Whether to add prefix for base-N output (0x, 0b, etc.) */\r\n    prefix?: boolean;\r\n    /** Minimum number of digits (pad with zeros) */\r\n    minDigits?: number;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<ConversionOptions> = {\r\n    precision: 0,\r\n    roundingMode: RoundingMode.HALF_EVEN,\r\n    uppercase: false,\r\n    prefix: false,\r\n    minDigits: 1\r\n  };\r\n  \r\n  /**\r\n   * Converts number to binary string representation\r\n   */\r\n  export function toBinary(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let binary = bigValue.toString(2);\r\n    \r\n    // Pad with zeros if needed\r\n    while (binary.length < opts.minDigits) {\r\n      binary = '0' + binary;\r\n    }\r\n    \r\n    return opts.prefix ? '0b' + binary : binary;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to octal string representation\r\n   */\r\n  export function toOctal(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let octal = bigValue.toString(8);\r\n    \r\n    while (octal.length < opts.minDigits) {\r\n      octal = '0' + octal;\r\n    }\r\n    \r\n    return opts.prefix ? '0o' + octal : octal;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to hexadecimal string representation\r\n   */\r\n  export function toHexadecimal(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let hex = bigValue.toString(16);\r\n    \r\n    if (opts.uppercase) {\r\n      hex = hex.toUpperCase();\r\n    }\r\n    \r\n    while (hex.length < opts.minDigits) {\r\n      hex = '0' + hex;\r\n    }\r\n    \r\n    return opts.prefix ? '0x' + hex : hex;\r\n  }\r\n  \r\n  /**\r\n   * Converts number to string in specified base\r\n   */\r\n  export function toBase(\r\n    value: bigint | string | number,\r\n    base: number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    if (base < 2 || base > 36) {\r\n      throw new ValidationError('Base must be between 2 and 36');\r\n    }\r\n    \r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    let result = bigValue.toString(base);\r\n    \r\n    if (opts.uppercase) {\r\n      result = result.toUpperCase();\r\n    }\r\n    \r\n    while (result.length < opts.minDigits) {\r\n      result = '0' + result;\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Converts string from specified base to bigint\r\n   */\r\n  export function fromBase(\r\n    value: string,\r\n    base: number\r\n  ): bigint {\r\n    if (base < 2 || base > 36) {\r\n      throw new ValidationError('Base must be between 2 and 36');\r\n    }\r\n    \r\n    // Remove base prefixes if present\r\n    const cleanValue = value.toLowerCase()\r\n      .replace(/^0x/, '')  // hex\r\n      .replace(/^0b/, '')  // binary\r\n      .replace(/^0o/, ''); // octal\r\n    \r\n    try {\r\n      return BigInt(`${base}n${cleanValue}`);\r\n    } catch (error) {\r\n      throw new ValidationError(`Invalid number format for base ${base}: ${value}`);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Converts decimal string to fraction representation\r\n   */\r\n  export function toFraction(\r\n    value: string,\r\n  ): [bigint, bigint] {\r\n    \r\n    // Split into integer and decimal parts\r\n    const [intPart, decPart = ''] = value.split('.');\r\n    \r\n    if (!decPart) {\r\n      return [toBigInt(intPart), 1n];\r\n    }\r\n    \r\n    // Convert decimal to fraction\r\n    const numerator = toBigInt(intPart + decPart);\r\n    const denominator = 10n ** BigInt(decPart.length);\r\n    \r\n    // Simplify fraction\r\n    const gcd = calculateGCD(numerator, denominator);\r\n    \r\n    return [numerator / gcd, denominator / gcd];\r\n  }\r\n  \r\n  /**\r\n   * Converts fraction to decimal string with specified precision\r\n   */\r\n  export function fromFraction(\r\n    numerator: bigint | string | number,\r\n    denominator: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigNumerator = toBigInt(numerator);\r\n    const bigDenominator = toBigInt(denominator);\r\n    \r\n    if (bigDenominator === 0n) {\r\n      throw new ValidationError('Denominator cannot be zero');\r\n    }\r\n    \r\n    const quotient = bigNumerator / bigDenominator;\r\n    const remainder = bigNumerator % bigDenominator;\r\n    \r\n    if (remainder === 0n || opts.precision === 0) {\r\n      return quotient.toString();\r\n    }\r\n    \r\n    // Calculate decimal part\r\n    const scaleFactor = 10n ** BigInt(opts.precision);\r\n    const scaledRemainder = (remainder * scaleFactor) / bigDenominator;\r\n    \r\n    return `${quotient}.${scaledRemainder.toString().padStart(opts.precision, '0')}`;\r\n  }\r\n  \r\n  /**\r\n   * Converts scientific notation to decimal string\r\n   */\r\n  export function fromScientific(\r\n    value: string,\r\n  ): string {\r\n    \r\n    // Parse scientific notation format\r\n    const match = value.match(/^(-?\\d+\\.?\\d*)[eE]([+-]?\\d+)$/);\r\n    if (!match) {\r\n      throw new ValidationError('Invalid scientific notation format');\r\n    }\r\n    \r\n    const [, significand, exponent] = match;\r\n    const exp = parseInt(exponent || '0', 10);\r\n    \r\n    // Convert to regular decimal\r\n    if (exp >= 0) {\r\n      if (significand === undefined) {\r\n        throw new ValidationError('Invalid scientific notation format');\r\n      }\r\n      return (BigInt(significand.replace('.', '')) * (10n ** BigInt(exp))).toString();\r\n    } else {\r\n      const absExp = Math.abs(exp);\r\n      if (significand === undefined) {\r\n        throw new ValidationError('Invalid scientific notation format');\r\n      }\r\n      const scaledValue = BigInt(significand.replace('.', ''));\r\n      return (scaledValue / (10n ** BigInt(absExp))).toString();\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Converts decimal to scientific notation\r\n   */\r\n  export function toScientific(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigValue = toBigInt(value);\r\n    \r\n    if (bigValue === 0n) {\r\n      return '0e0';\r\n    }\r\n    \r\n    const str = bigValue.toString();\r\n    const firstDigit = str[0] === '-' ? str[1] : str[0];\r\n    const exponent = str.length - (str[0] === '-' ? 2 : 1);\r\n    \r\n    let result = firstDigit;\r\n    if (str.length > 1) {\r\n      const restDigits = str.slice(str[0] === '-' ? 2 : 1);\r\n      if (opts.precision > 0) {\r\n        result += '.' + restDigits.slice(0, opts.precision);\r\n      }\r\n    }\r\n    \r\n    if (str[0] === '-') {\r\n      result = '-' + result;\r\n    }\r\n    \r\n    return `${result}e${exponent}`;\r\n  }\r\n  \r\n  /**\r\n   * Calculates Greatest Common Divisor (helper function)\r\n   */\r\n  function calculateGCD(a: bigint, b: bigint): bigint {\r\n    a = a < 0n ? -a : a;\r\n    b = b < 0n ? -b : b;\r\n    \r\n    while (b !== 0n) {\r\n      const temp = b;\r\n      b = a % b;\r\n      a = temp;\r\n    }\r\n    \r\n    return a;\r\n  }\r\n  \r\n\r\n  /**\r\n * Converts Roman numeral to number\r\n */\r\nexport function fromRoman(value: string): bigint {\r\n    const romanValues = new Map<string, number>([\r\n      ['I', 1],\r\n      ['V', 5],\r\n      ['X', 10],\r\n      ['L', 50],\r\n      ['C', 100],\r\n      ['D', 500],\r\n      ['M', 1000]\r\n    ]);\r\n  \r\n    let result = 0;\r\n    let prevValue = 0;\r\n  \r\n    // Process from right to left\r\n    for (let i = value.length - 1; i >= 0; i--) {\r\n      const char = value[i]?.toUpperCase() ?? '';\r\n      const current = romanValues.get(char);\r\n  \r\n      if (current === undefined) {\r\n        throw new ValidationError(`Invalid Roman numeral character: ${char}`);\r\n      }\r\n  \r\n      if (current >= prevValue) {\r\n        result += current;\r\n      } else {\r\n        result -= current;\r\n      }\r\n  \r\n      prevValue = current;\r\n    }\r\n  \r\n    return BigInt(result);\r\n  }\r\n  \r\n  /**\r\n   * Converts number to Roman numeral\r\n   */\r\n  export function toRoman(\r\n    value: bigint | string | number,\r\n    options: ConversionOptions = {}\r\n  ): string {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const num = Number(toBigInt(value));\r\n  \r\n    if (num <= 0 || num > 3999) {\r\n      throw new ValidationError('Number must be between 1 and 3999 for Roman numerals');\r\n    }\r\n  \r\n    // Define symbol pairs with proper typing\r\n    type RomanPair = [string, string];\r\n    type RomanSingle = [string];\r\n    type RomanSymbol = RomanPair | RomanSingle;\r\n  \r\n    const romanSymbols: RomanSymbol[] = [\r\n      ['I', 'V'], // ones\r\n      ['X', 'L'], // tens\r\n      ['C', 'D'], // hundreds\r\n      ['M']       // thousands\r\n    ];\r\n  \r\n    let result = '';\r\n    let position = 0;\r\n    let remaining = num;\r\n  \r\n    while (remaining > 0) {\r\n      const digit = remaining % 10;\r\n      const symbols = romanSymbols[position];\r\n  \r\n      if (!symbols) {\r\n        break; // Safety check for position overflow\r\n      }\r\n  \r\n      const unit = symbols[0];\r\n      const five = symbols[1] ?? '';\r\n      const next = position < 3 ? romanSymbols[position + 1]?.[0] ?? '' : '';\r\n  \r\n      let digitStr = '';\r\n      if (digit === 9 && next) {\r\n        digitStr = unit + next;\r\n      } else if (digit >= 5 && five) {\r\n        digitStr = five + unit.repeat(digit - 5);\r\n      } else if (digit === 4 && five) {\r\n        digitStr = unit + five;\r\n      } else {\r\n        digitStr = unit.repeat(digit);\r\n      }\r\n  \r\n      result = digitStr + result;\r\n      remaining = Math.floor(remaining / 10);\r\n      position++;\r\n    }\r\n  \r\n    return opts.uppercase ? result : result.toLowerCase();\r\n  }\r\n  export default {\r\n    toBinary,\r\n    toOctal,\r\n    toHexadecimal,\r\n    toBase,\r\n    fromBase,\r\n    toFraction,\r\n    fromFraction,\r\n    fromScientific,\r\n    toScientific,\r\n    fromRoman,\r\n    toRoman\r\n  };","/**\r\n * Factorial operations module for Hypernum library\r\n * Provides efficient implementations for factorial and related computations\r\n */\r\n\r\nimport {\r\n    toBigInt,\r\n    ValidationError,\r\n    OverflowError,\r\n    validateNonNegative\r\n  } from '../utils/validation';\r\n  \r\n  /**\r\n   * Options for factorial operations\r\n   */\r\n  export interface FactorialOptions {\r\n    /** Maximum allowed computation value */\r\n    maxValue?: number;\r\n    /** Whether to check for overflow */\r\n    checkOverflow?: boolean;\r\n    /** Cache computed values */\r\n    useCache?: boolean;\r\n  }\r\n  \r\n  const DEFAULT_OPTIONS: Required<FactorialOptions> = {\r\n    maxValue: 1000,\r\n    checkOverflow: true,\r\n    useCache: true\r\n  };\r\n  \r\n  // Cache for factorial values\r\n  const factorialCache = new Map<bigint, bigint>();\r\n  \r\n  /**\r\n   * Calculates factorial of a number (n!)\r\n   */\r\n  export function factorial(\r\n    value: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n  \r\n    validateNonNegative(n);\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Factorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    // Handle base cases\r\n    if (n <= 1n) {\r\n      return 1n;\r\n    }\r\n  \r\n    // Check cache\r\n    if (opts.useCache && factorialCache.has(n)) {\r\n      return factorialCache.get(n)!;\r\n    }\r\n  \r\n    // Calculate factorial\r\n    let result = 1n;\r\n    for (let i = 2n; i <= n; i++) {\r\n      result *= i;\r\n    }\r\n  \r\n    // Cache result\r\n    if (opts.useCache) {\r\n      factorialCache.set(n, result);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates binomial coefficient (n choose k)\r\n   */\r\n  export function binomial(\r\n    n: bigint | string | number,\r\n    k: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigN = toBigInt(n);\r\n    const bigK = toBigInt(k);\r\n  \r\n    validateNonNegative(bigN);\r\n    validateNonNegative(bigK);\r\n  \r\n    if (bigK > bigN) {\r\n      throw new ValidationError('K cannot be greater than N in binomial coefficient');\r\n    }\r\n  \r\n    // Optimize for k > n/2 by using symmetry\r\n    if (bigK > bigN / 2n) {\r\n      return binomial(bigN, bigN - bigK, opts);\r\n    }\r\n  \r\n    // Use multiplicative formula instead of factorial for efficiency\r\n    let result = 1n;\r\n    for (let i = 0n; i < bigK; i++) {\r\n      result = (result * (bigN - i)) / (i + 1n);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates subfactorial (derangement number)\r\n   * Number of permutations of n elements with no fixed points\r\n   */\r\n  export function subfactorial(\r\n    value: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n  \r\n    validateNonNegative(n);\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Subfactorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    // Handle base cases\r\n    if (n === 0n) return 1n;\r\n    if (n === 1n) return 0n;\r\n  \r\n    // Use recursive formula !n = n * !(n-1) + (-1)^n\r\n    let result = 0n;\r\n    const nFact = factorial(n, opts);\r\n  \r\n    for (let k = 0n; k <= n; k++) {\r\n      const term = factorial(n - k, opts) * (k % 2n === 0n ? 1n : -1n);\r\n      result += term;\r\n    }\r\n  \r\n    return nFact - result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates rising factorial (Pochhammer symbol)\r\n   * x^(n) = x(x+1)(x+2)...(x+n-1)\r\n   */\r\n  export function risingFactorial(\r\n    x: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigX = toBigInt(x);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigN);\r\n  \r\n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Rising factorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    let result = 1n;\r\n    for (let i = 0n; i < bigN; i++) {\r\n      result *= (bigX + i);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates falling factorial\r\n   * x_(n) = x(x-1)(x-2)...(x-n+1)\r\n   */\r\n  export function fallingFactorial(\r\n    x: bigint | string | number,\r\n    n: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const bigX = toBigInt(x);\r\n    const bigN = toBigInt(n);\r\n  \r\n    validateNonNegative(bigN);\r\n  \r\n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Falling factorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    let result = 1n;\r\n    for (let i = 0n; i < bigN; i++) {\r\n      result *= (bigX - i);\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates multifactorial (n!!)\r\n   * Product of numbers from 1 to n that leave the same remainder as n when divided by k\r\n   */\r\n  export function multiFactorial(\r\n    value: bigint | string | number,\r\n    k: bigint | string | number = 2n,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n    const bigK = toBigInt(k);\r\n  \r\n    validateNonNegative(n);\r\n    if (bigK <= 0n) {\r\n      throw new ValidationError('K must be positive in multifactorial');\r\n    }\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Multifactorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    let result = 1n;\r\n    let current = n;\r\n  \r\n    while (current > 0n) {\r\n      result *= current;\r\n      current -= bigK;\r\n    }\r\n  \r\n    return result;\r\n  }\r\n  \r\n  /**\r\n   * Calculates primorial (product of primes up to n)\r\n   */\r\n  export function primorial(\r\n    value: bigint | string | number,\r\n    options: FactorialOptions = {}\r\n  ): bigint {\r\n    const opts = { ...DEFAULT_OPTIONS, ...options };\r\n    const n = toBigInt(value);\r\n  \r\n    validateNonNegative(n);\r\n  \r\n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\r\n      throw new OverflowError(`Primorial input too large: maximum allowed is ${opts.maxValue}`);\r\n    }\r\n  \r\n    if (n <= 1n) return 1n;\r\n  \r\n    // Generate primes up to n using Sieve of Eratosthenes\r\n    const num = Number(n);\r\n    const sieve = new Array(num + 1).fill(true);\r\n    sieve[0] = sieve[1] = false;\r\n  \r\n    for (let i = 2; i * i <= num; i++) {\r\n      if (sieve[i]) {\r\n        for (let j = i * i; j <= num; j += i) {\r\n          sieve[j] = false;\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Calculate product of all primes up to n\r\n    let result = 1n;\r\n    for (let i = 2; i <= num; i++) {\r\n      if (sieve[i]) {\r\n        result *= BigInt(i);\r\n      }\r\n    }\r\n  \r\n    return result;\r\n  }\r\n\r\n  \r\n  \r\n  export default {\r\n    factorial,\r\n    binomial,\r\n    subfactorial,\r\n    risingFactorial,\r\n    fallingFactorial,\r\n    multiFactorial,\r\n    primorial\r\n  };","/**\r\n * Hypernum - A TypeScript/JavaScript library for large number operations\r\n * Provides comprehensive tools for handling large numbers and complex mathematical operations\r\n */\r\n\r\nimport { HypernumConfig, mergeConfig, validateConfig } from './core';\r\nimport { Hypernum } from './core/hypernum';\r\n\r\n// Package version\r\nconst VERSION: string = '0.1.0';\r\n\r\n// Core exports\r\nexport { Hypernum } from './core/hypernum';\r\nexport * from './core/constants';\r\nexport * from './core/common';\r\nexport * from './core/config';\r\n\r\n// Re-export errors with explicit names to avoid conflicts\r\nexport { \r\n  HypernumError,\r\n  ComputationLimitError,\r\n  DataStructureError,\r\n  DivisionByZeroError,\r\n  FormatError,\r\n  HeapPropertyError,\r\n  IndexError,\r\n  PrecisionError,\r\n  RomanNumeralError,\r\n  TreeError,\r\n  UnderflowError\r\n} from './core/errors';\r\n\r\n// Data structures with explicit exports\r\nexport { AckermannStructure } from './structures/Ackermann';\r\nexport { BigArray } from './structures/BigArray';\r\nexport { NumberTree } from './structures/NumberTree';\r\nexport { PowerTower } from './structures/PowerTower';\r\nexport { MinHeap, MaxHeap } from './storage/Heap';\r\nexport type { Comparator } from './storage/Heap';\r\n\r\n// Operations with explicit exports to avoid conflicts\r\nexport {\r\n  add,\r\n  subtract,\r\n  multiply,\r\n  divide,\r\n  remainder,\r\n  abs,\r\n  sign,\r\n  gcd,\r\n  lcm\r\n} from './operations/arithmetic';\r\n\r\nexport {\r\n  and,\r\n  or,\r\n  xor,\r\n  not,\r\n  leftShift,\r\n  rightShift,\r\n  unsignedRightShift,\r\n  rotateLeft,\r\n  rotateRight,\r\n  popCount,\r\n  trailingZeros,\r\n  leadingZeros,\r\n  getBit,\r\n  setBit,\r\n  clearBit,\r\n  toggleBit\r\n} from './operations/bitwise';\r\n\r\nexport {\r\n  compare,\r\n  equals,\r\n  lessThan,\r\n  lessThanOrEqual,\r\n  greaterThan,\r\n  greaterThanOrEqual,\r\n  between,\r\n  max,\r\n  min,\r\n  clamp,\r\n  allEqual,\r\n  isAscending,\r\n  isDescending,\r\n  createComparator\r\n} from './operations/comparison';\r\n\r\nexport {\r\n  toBinary,\r\n  toOctal,\r\n  toHexadecimal,\r\n  toBase,\r\n  fromBase,\r\n  toFraction,\r\n  fromFraction,\r\n  fromScientific,\r\n  toScientific,\r\n  fromRoman,\r\n  toRoman\r\n} from './operations/conversion';\r\n\r\nexport {\r\n  factorial,\r\n  binomial,\r\n  subfactorial,\r\n  risingFactorial,\r\n  fallingFactorial,\r\n  multiFactorial,\r\n  primorial\r\n} from './operations/factorial';\r\n\r\nexport {\r\n  power,\r\n  sqrt,\r\n  nthRoot,\r\n  tetration,\r\n  superRoot\r\n} from './operations/power';\r\n\r\n// Utils with explicit exports\r\nexport {\r\n  toBigInt,\r\n  validateNonNegative,\r\n  validatePositive,\r\n  checkAdditionOverflow,\r\n  checkMultiplicationOverflow,\r\n  checkPowerOverflow\r\n} from './utils/validation';\r\n\r\nexport {\r\n  formatBigInt,\r\n  parseBigIntString,\r\n  normalizeNumberString\r\n} from './utils/formatting';\r\n\r\nexport {\r\n  RoundingMode,\r\n  round,\r\n  scaleByPowerOfTen,\r\n  scaledDivision,\r\n  normalizePrecision\r\n} from './utils/precision';\r\n\r\n/**\r\n * Creates a new Hypernum instance with custom configuration\r\n */\r\nexport function createHypernum(config?: Partial<HypernumConfig>): Hypernum {\r\n  const mergedConfig = mergeConfig(config || {});\r\n  validateConfig(mergedConfig);\r\n  \r\n  // Extract the basic config properties based on whether it's a BasicConfig or FullConfig\r\n  const instanceConfig = {\r\n    precision: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.defaultPrecision \r\n      : mergedConfig.precision,\r\n    roundingMode: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.defaultRoundingMode \r\n      : mergedConfig.roundingMode,\r\n    checkOverflow: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.checkOverflow \r\n      : mergedConfig.checkOverflow,\r\n    maxSteps: 'arithmetic' in mergedConfig \r\n      ? mergedConfig.arithmetic.maxComputationSteps \r\n      : mergedConfig.maxSteps,\r\n    debug: typeof mergedConfig.debug === 'object' \r\n      ? mergedConfig.debug.verbose \r\n      : !!mergedConfig.debug\r\n  };\r\n  \r\n  return new Hypernum(instanceConfig);\r\n}\r\n\r\n// Default instance\r\nexport const defaultHypernum = createHypernum();\r\n\r\n// Export version\r\nexport { VERSION };\r\n\r\n// Default export\r\nexport default Hypernum;"],"names":["Error","constructor","message","super","this","name","OverflowError","toBigInt","value","isBigInt","test","isValidNumberString","ValidationError","BigInt","isNaN","isFinite","isValidNumber","Number","isInteger","checkAdditionOverflow","a","b","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","checkMultiplicationOverflow","maxValue","minValue","checkPowerOverflow","base","exponent","validateNonNegative","RoundingMode","scaleByPowerOfTen","power","round","precision","mode","HALF_EVEN","scale","scaled","remainder","FLOOR","CEIL","DOWN","UP","HALF_UP","HALF_DOWN","normalizePrecision","precisionA","precisionB","targetPrecision","Math","max","scaledDivision","numerator","denominator","roundingMode","scaledNumerator","DEFAULT_BASIC_CONFIG","checkOverflow","maxSteps","debug","DEFAULT_FULL_CONFIG","arithmetic","defaultPrecision","defaultRoundingMode","maxComputationSteps","autoPrecision","enabled","maxPrecision","minPrecision","constants","cache","algorithm","dataStructures","array","initialCapacity","growthFactor","maxSize","tree","maxDepth","autoBalance","nodeLimit","heap","growthPolicy","validatePropertyOnOperation","ttl","evictionPolicy","persistToDisk","compressionEnabled","formatting","notation","grouping","groupSize","decimalSeparator","groupSeparator","uppercase","scientific","minExponent","maxSignificantDigits","exponentSeparator","engineering","useSIPrefixes","localization","locale","useLocaleGrouping","performance","enableTracking","samplingRate","thresholds","warnThresholdMs","errorThresholdMs","maxMemoryBytes","metrics","timing","memory","verbose","trackPerformance","logLevel","features","experimentalFeatures","useWasm","workerThreads","sharedArrayBuffer","bigIntTypedArrays","isFullConfig","config","isBasicConfig","validateConfig","validateFullConfig","undefined","validateBasicConfig","mergeConfig","custom","fullConfig","MAX_COMPUTATION_STEPS","ZERO","ONE","TWO","TEN","NEGATIVE_ONE","MAX_POWER_BASE","MAX_POWER_EXPONENT","MAX_TETRATION_HEIGHT","MAX_FACTORIAL_INPUT","ERROR_MESSAGES","OVERFLOW","UNDERFLOW","NEGATIVE_ROOT","NEGATIVE_EXPONENT","DIVISION_BY_ZERO","INVALID_PRECISION","INVALID_BASE","INVALID_ROMAN","COMPUTATION_LIMIT","NEGATIVE_INDEX","TREE_DEPTH_EXCEEDED","INVALID_HEAP_PROPERTY","FEATURES","OVERFLOW_CHECKING","AUTOMATIC_PRECISION","MEMOIZATION","TREE_BALANCING","DEBUG_MODE","DEFAULT_OPTIONS","HypernumError","Object","setPrototypeOf","prototype","UnderflowError","DivisionByZeroError","PrecisionError","ComputationLimitError","DataStructureError","HeapPropertyError","TreeError","IndexError","FormatError","RomanNumeralError","add","options","opts","bigA","bigB","scaledA","scaledB","subtract","multiply","result","divide","bigNumerator","bigDenominator","abs","bigValue","gcd","temp","maxBits","strict","validateShift","shift","and","or","xor","not","leftShift","bigShift","unsignedRightShift","baseValue","exponentValue","bigBase","bigExponent","steps","sqrt","lastGuess","guess","nthRoot","n","bigN","nMinus1","tetration","height","bigHeight","i","Heap","comparator","compare","size","length","isEmpty","peek","push","siftUp","pop","root","last","siftDown","clear","heapify","MinHeap","MaxHeap","forEach","item","getParentIndex","index","floor","getLeftChildIndex","getRightChildIndex","swap","j","parentIndex","smallest","left","right","largest","AckermannStructure","nodes","Map","maxComputedM","maxComputedN","getNodeKey","m","computeAckermann","key","existing","get","inner","innerNum","error","RangeError","addNode","has","node","set","prevMKey","prevNKey","prevM","nextM","prevN","nextN","buildRange","mRange","nRange","getComputationPath","path","current","nextValue","safeNextValue","reverse","analyzeGrowthRate","growth","prevValue","increase","multiplier","getLargestValue","getValue","NumberNode","parent","sum","updateStats","getBalance","getStats","min","findMin","findMax","NumberTree","getRoot","insert","newValue","insertNode","find","compareResult","balance","rotateLeft","rotateRight","rightChild","rightLeftChild","leftChild","leftRightChild","remove","searchValue","removeNode","successor","traverse","order","depth","skipSubtrees","getTreeStats","getNthValue","findNth","position","leftSize","getRange","start","end","startValue","endValue","collectRange","BigArray","capacity","data","Array","segmentTree","fill","getSize","getCapacity","resize","newCapacity","newData","rebuildSegmentTree","updateSegmentTree","success","oldValue","buildSegmentTree","mid","leftNode","rightNode","currentNode","queryRange","querySegmentTree","queryStart","queryEnd","leftResult","rightResult","toHeap","isMin","sort","ascending","toArray","slice","maxHeight","PowerTower","head","tail","createNode","evaluated","previous","next","validateHeight","validateValue","computePower","build","evaluate","targetHeight","currentHeight","getHeight","isComputable","safeOptions","safeTower","getState","state","getMaxFeasibleHeight","Infinity","toString","formatBigInt","isNegative","absValue","formatScientific","coefficient","formatEngineering","formatCompact","formatStandard","str","unshift","join","len","digitsBeforePoint","suffixes","suffixIndex","suffix","decimalPart","padStart","Hypernum","structures","arrays","trees","heaps","arithmetic.add","arithmetic.subtract","arithmetic.multiply","arithmetic.divide","mod","arithmetic.remainder","power.power","power.sqrt","power.nthRoot","bitwise.and","bitwise.or","bitwise.xor","bitwise.not","createArray","id","getArray","createTree","getTree","createHeap","isMinHeap","compareValues","getHeap","createAckermannStructure","format","validation.toBigInt","formatting.formatBigInt","validate","updateConfig","newConfig","assign","getConfig","dispose","tolerance","diff","toleranceValue","equals","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","prefix","minDigits","useCache","factorialCache","factorial","createHypernum","mergedConfig","instanceConfig","defaultHypernum","symbol","WARN_THRESHOLD_MS","ERROR_THRESHOLD_MS","MAX_ARRAY_SIZE","MAX_TREE_SIZE","values","first","every","binomial","k","bigK","bigMin","bigMax","bigPosition","x","bigX","cleanValue","toLowerCase","replace","quotient","romanValues","char","toUpperCase","match","significand","exp","parseInt","absExp","count","msb","reduce","bigCurrent","includes","split","parseFloat","pow","cleanStr","RegExp","suffixMap","num","sieve","rotation","bigRotation","rightPart","nFact","binary","intPart","decPart","calculateGCD","hex","octal","romanSymbols","remaining","digit","symbols","unit","five","digitStr","repeat","firstDigit","restDigits"],"mappings":"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"}