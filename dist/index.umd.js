/**
 * @obinexuscomputing/hypernum v0.1.0
 * A JavaScript/TypeScript library for large number operations with BigInt compatibility
 * @license ISC
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Hypernum={})}(this,(function(t){"use strict";let e=class extends Error{constructor(t){super(t),this.name="ValidationError"}};class n extends Error{constructor(t){super(t),this.name="OverflowError"}}const r=t=>{if((t=>"bigint"==typeof t)(t))return t;if("string"==typeof t){if(!(t=>/^-?\d+$/.test(t))(t))throw new e(`Invalid number string: ${t}`);return BigInt(t)}if((t=>"number"==typeof t&&!isNaN(t)&&isFinite(t))(t)){if(!Number.isInteger(t))throw new e("Cannot convert non-integer number to BigInt");return BigInt(t)}throw new e(`Cannot convert ${typeof t} to BigInt`)},i=(t,e)=>{if(e>0&&t>BigInt(Number.MAX_SAFE_INTEGER)-e)throw new n("Addition would overflow");if(e<0&&t<BigInt(Number.MIN_SAFE_INTEGER)-e)throw new n("Addition would underflow")},o=(t,e)=>{if(t!==BigInt(0)&&e!==BigInt(0)){const r=BigInt(Number.MAX_SAFE_INTEGER),i=BigInt(Number.MIN_SAFE_INTEGER);if(t>r/e||t<i/e)throw new n("Multiplication would overflow")}},s=(t,r)=>{if(r<BigInt(0))throw new e("Negative exponents not supported for integers");if(t===BigInt(0)&&r===BigInt(0))throw new e("Zero raised to zero is undefined");if(r>BigInt(1e3))throw new n("Exponent too large, computation would overflow")},a=t=>{if(t<BigInt(0))throw new e("Value must be non-negative")};var u;t.RoundingMode=void 0,(u=t.RoundingMode||(t.RoundingMode={})).FLOOR="FLOOR",u.CEIL="CEIL",u.DOWN="DOWN",u.UP="UP",u.HALF_EVEN="HALF_EVEN",u.HALF_UP="HALF_UP",u.HALF_DOWN="HALF_DOWN";const c=(t,e)=>0===e?t:e>0?t*BigInt(10)**BigInt(e):t/BigInt(10)**BigInt(-e),h=(n,r=0,i=t.RoundingMode.HALF_EVEN)=>{if(r<0)throw new e("Precision must be non-negative");if(0===r)return n;const o=BigInt(10)**BigInt(r),s=n/o,a=n%o;switch(i){case t.RoundingMode.FLOOR:return s*o;case t.RoundingMode.CEIL:return a>0n?(s+1n)*o:s*o;case t.RoundingMode.DOWN:return n>=0n?s*o:(s-1n)*o;case t.RoundingMode.UP:return n>=0n?(s+1n)*o:s*o;case t.RoundingMode.HALF_UP:return a>=o/2n?(s+1n)*o:s*o;case t.RoundingMode.HALF_DOWN:return a>o/2n?(s+1n)*o:s*o;case t.RoundingMode.HALF_EVEN:return a===o/2n?s%2n===0n?s*o:(s+1n)*o:a>o/2n?(s+1n)*o:s*o;default:throw new e("Invalid rounding mode")}},l=(t,e,n,r)=>{const i=Math.max(n,r);return[c(t,i-n),c(e,i-r)]},f=(n,r,i,o=t.RoundingMode.HALF_EVEN)=>{if(0n===r)throw new e("Division by zero");if(i<0)throw new e("Precision must be non-negative");const s=c(n,i);return h(s/r,0,o)};const g={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxSteps:1e3,debug:!1},p={arithmetic:{defaultPrecision:0,defaultRoundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxComputationSteps:1e3,autoPrecision:{enabled:!0,maxPrecision:100,minPrecision:0},constants:{precision:50,cache:!0,algorithm:"series"}},dataStructures:{array:{initialCapacity:16,growthFactor:2,maxSize:1e6},tree:{maxDepth:1e3,autoBalance:!0,nodeLimit:1e6},heap:{initialCapacity:16,growthPolicy:"double",validatePropertyOnOperation:!0},cache:{enabled:!0,maxSize:1e3,ttl:36e5,evictionPolicy:"LRU",persistToDisk:!1,compressionEnabled:!1}},formatting:{notation:"standard",precision:0,grouping:!0,groupSize:3,decimalSeparator:".",groupSeparator:",",uppercase:!1,scientific:{minExponent:6,maxSignificantDigits:6,exponentSeparator:"e"},engineering:{useSIPrefixes:!0},localization:{locale:"en-US",useLocaleGrouping:!1}},performance:{enableTracking:!1,samplingRate:.1,thresholds:{warnThresholdMs:100,errorThresholdMs:1e3,maxMemoryBytes:1073741824},metrics:{timing:!0,memory:!0,cache:!0}},debug:{verbose:!1,trackPerformance:!1,logLevel:"error"},features:{experimentalFeatures:!1,useWasm:!1,workerThreads:!1,sharedArrayBuffer:!1,bigIntTypedArrays:!0}};function d(t){return"arithmetic"in t&&"dataStructures"in t}function m(t){return!d(t)}function w(t){d(t)?function(t){if(t.arithmetic.defaultPrecision<0)throw new Error("Default precision cannot be negative");if(t.arithmetic.maxComputationSteps<=0)throw new Error("Max computation steps must be positive");if(t.dataStructures.array.initialCapacity<=0)throw new Error("Initial capacity must be positive");if(t.dataStructures.array.growthFactor<=1)throw new Error("Growth factor must be greater than 1");if(t.performance.samplingRate<0||t.performance.samplingRate>1)throw new Error("Sampling rate must be between 0 and 1")}(t):function(t){if(void 0!==t.precision&&t.precision<0)throw new Error("Precision cannot be negative");if(void 0!==t.maxSteps&&t.maxSteps<=0)throw new Error("Maximum steps must be positive");if(void 0!==t.debug&&"boolean"!=typeof t.debug)throw new Error("Debug flag must be a boolean")}(t)}function I(t={}){if(d(t)){const e=t;return{...p,...e,arithmetic:{...p.arithmetic,...e.arithmetic},dataStructures:{...p.dataStructures,...e.dataStructures},formatting:{...p.formatting,...e.formatting},performance:{...p.performance,...e.performance},debug:{...p.debug,...e.debug},features:{...p.features,...e.features}}}return{precision:t.precision??g.precision,roundingMode:t.roundingMode??g.roundingMode,checkOverflow:t.checkOverflow??g.checkOverflow,maxSteps:t.maxSteps??g.maxSteps,debug:t.debug??g.debug}}const E=BigInt(Number.MAX_SAFE_INTEGER),v=BigInt(Number.MIN_SAFE_INTEGER),x=1e3,B=BigInt(0),b=BigInt(1),S=BigInt(2),N=BigInt(10),A=BigInt(-1),M=BigInt(2)**BigInt(53),y=BigInt(1e3),O=BigInt(4),_=BigInt(1e3),R={OVERFLOW:"Operation would result in overflow",UNDERFLOW:"Operation would result in underflow",NEGATIVE_ROOT:"Cannot compute root of negative number",NEGATIVE_EXPONENT:"Negative exponents not supported for integers",DIVISION_BY_ZERO:"Division by zero",INVALID_PRECISION:"Precision must be non-negative and not exceed MAX_PRECISION",INVALID_BASE:"Base must be a positive integer",INVALID_ROMAN:"Invalid Roman numeral",COMPUTATION_LIMIT:"Computation exceeded maximum allowed steps",NEGATIVE_INDEX:"Array index cannot be negative",TREE_DEPTH_EXCEEDED:"Maximum tree depth exceeded",INVALID_HEAP_PROPERTY:"Heap property violation detected"},T={OVERFLOW_CHECKING:!0,AUTOMATIC_PRECISION:!0,MEMOIZATION:!0,TREE_BALANCING:!0,DEBUG_MODE:!1},C={precision:0,roundingMode:"HALF_EVEN",checkOverflow:!0,maxSteps:x,grouping:!0,uppercase:!1,cache:!0};class P extends Error{constructor(t){super(t),this.name="HypernumError",Object.setPrototypeOf(this,P.prototype)}}class L extends P{constructor(t){super(t),this.name="ValidationError",Object.setPrototypeOf(this,L.prototype)}}class F extends P{constructor(t=R.UNDERFLOW){super(t),this.name="UnderflowError",Object.setPrototypeOf(this,F.prototype)}}class D extends P{constructor(t=R.DIVISION_BY_ZERO){super(t),this.name="DivisionByZeroError",Object.setPrototypeOf(this,D.prototype)}}class V extends P{constructor(t=R.INVALID_PRECISION){super(t),this.name="PrecisionError",Object.setPrototypeOf(this,V.prototype)}}class H extends P{constructor(t=R.COMPUTATION_LIMIT){super(t),this.name="ComputationLimitError",Object.setPrototypeOf(this,H.prototype)}}class k extends P{constructor(t){super(t),this.name="DataStructureError",Object.setPrototypeOf(this,k.prototype)}}class z extends k{constructor(t=R.INVALID_HEAP_PROPERTY){super(t),this.name="HeapPropertyError",Object.setPrototypeOf(this,z.prototype)}}class U extends k{constructor(t=R.TREE_DEPTH_EXCEEDED){super(t),this.name="TreeError",Object.setPrototypeOf(this,U.prototype)}}class $ extends k{constructor(t=R.NEGATIVE_INDEX){super(t),this.name="IndexError",Object.setPrototypeOf(this,$.prototype)}}class G extends P{constructor(t){super(t),this.name="FormatError",Object.setPrototypeOf(this,G.prototype)}}class X extends G{constructor(t=R.INVALID_ROMAN){super(t),this.name="RomanNumeralError",Object.setPrototypeOf(this,X.prototype)}}const K={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0};function j(t,e,n={}){const o={...K,...n},s=r(t),a=r(e);if(o.checkOverflow&&i(s,a),0===o.precision)return s+a;const[u,c]=l(s,a,o.precision,o.precision);return h(u+c,o.precision,o.roundingMode)}function W(t,e,n={}){const o={...K,...n},s=r(t),a=r(e);if(o.checkOverflow&&i(s,-a),0===o.precision)return s-a;const[u,c]=l(s,a,o.precision,o.precision);return h(u-c,o.precision,o.roundingMode)}function Z(t,e,n={}){const i={...K,...n},s=r(t),a=r(e);i.checkOverflow&&o(s,a);const u=s*a;return 0===i.precision?u:h(u,i.precision,i.roundingMode)}function q(t,n,i={}){const o={...K,...i},s=r(t),a=r(n);if(a===BigInt(0))throw new e("Division by zero");return f(s,a,o.precision,o.roundingMode)}function Y(t,n,i={}){const o={...K,...i},s=r(t),a=r(n);if(a===BigInt(0))throw new e("Division by zero in remainder operation");if(0===o.precision)return s%a;const[u,c]=l(s,a,o.precision,o.precision);return h(u%c,o.precision,o.roundingMode)}function Q(t){const e=r(t);return e<BigInt(0)?-e:e}function J(t,e){let n=Q(r(t)),i=Q(r(e));for(;i!==BigInt(0);){const t=i;i=n%i,n=t}return n}const tt={maxBits:1024,strict:!0};function et(t,n){if(t<0n)throw new e("Shift amount cannot be negative");if(n.strict&&t>=BigInt(n.maxBits))throw new e(`Shift amount exceeds maximum of ${n.maxBits} bits`)}function nt(t,e){return r(t)&r(e)}function rt(t,e){return r(t)|r(e)}function it(t,e){return r(t)^r(e)}function ot(t){return~r(t)}function st(t,e,n={}){const i={...tt,...n},o=r(t),s=r(e);return et(s,i),o<<s}function at(t,e,n={}){const i={...tt,...n},o=r(t),s=r(e);if(et(s,i),o>=0n)return o>>s;return(o&(1n<<BigInt(i.maxBits))-1n)>>s}const ut={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxSteps:1e3};function ct(t,i,o={}){const a={...ut,...o},u=r(t),c=r(i);if(0n===c)return 1n;if(1n===c)return u;if(0n===u&&c<0n)throw new e("Zero cannot be raised to a negative power");if(0n===u)return 0n;if(1n===u)return 1n;if(-1n===u)return c%2n===0n?1n:-1n;if(c<0n)throw new e("Negative exponents not supported for integer power");a.checkOverflow&&s(u,c);let l=1n,f=u,g=c,p=0;for(;g>0n;){if(p++>a.maxSteps)throw new n("Power operation exceeded maximum computation steps");1n&g&&(l*=f),f*=f,g>>=1n}return a.precision>0?h(l,a.precision,a.roundingMode):l}function ht(t,e={}){const i={...ut,...e},o=r(t);if(a(o),0n===o)return 0n;if(1n===o)return 1n;let s,u=o>>1n,c=0;do{if(c++>i.maxSteps)throw new n("Square root operation exceeded maximum computation steps");s=u,u=u+o/u>>1n}while(u<s);return i.precision>0?h(s,i.precision,i.roundingMode):s}function lt(t,i,o={}){const s={...ut,...o},u=r(t),c=r(i);if(a(u),c<=0n)throw new e("Root index must be positive");if(0n===u)return 0n;if(1n===u)return 1n;if(1n===c)return u;if(2n===c)return ht(u,s);let l,f=u>>1n,g=0;const p=c-1n;do{if(g++>s.maxSteps)throw new n("Nth root operation exceeded maximum computation steps");l=f;f=(p*f+u/ct(f,p,s))/c}while(f<l);return s.precision>0?h(l,s.precision,s.roundingMode):l}function ft(t,e,i={}){const o={...ut,...i},s=r(t),u=r(e);if(a(u),0n===u)return 1n;if(1n===u)return s;if(0n===s)return u%2n===0n?1n:0n;if(1n===s)return 1n;if(2n===s&&u>4n)throw new n("Tetration would overflow for base 2 and height > 4");let c=s,l=0;for(let t=1n;t<u;t++){if(l++>o.maxSteps)throw new n("Tetration operation exceeded maximum computation steps");c=ct(s,c,o)}return o.precision>0?h(c,o.precision,o.roundingMode):c}class gt{constructor(t){this.heap=[],this.compare=t}size(){return this.heap.length}isEmpty(){return 0===this.heap.length}peek(){return this.heap[0]}push(t){this.heap.push(t),this.siftUp(this.heap.length-1)}pop(){if(this.isEmpty())return;const t=this.heap[0],e=this.heap.pop();return this.isEmpty()||(this.heap[0]=e,this.siftDown(0)),t}clear(){this.heap=[]}static heapify(t,e){const n=this instanceof pt?new pt(e):new dt(e);return t.forEach((t=>n.push(t))),n}getParentIndex(t){return Math.floor((t-1)/2)}getLeftChildIndex(t){return 2*t+1}getRightChildIndex(t){return 2*t+2}swap(t,e){const n=this.heap[t];this.heap[t]=this.heap[e],this.heap[e]=n}}class pt extends gt{constructor(t){super(t)}siftUp(t){for(;t>0;){const e=this.getParentIndex(t);if(this.compare(this.heap[t],this.heap[e])>=0)break;this.swap(t,e),t=e}}siftDown(t){const e=this.heap.length;for(;;){let n=t;const r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t);if(r<e&&this.compare(this.heap[r],this.heap[n])<0&&(n=r),i<e&&void 0!==this.heap[i]&&this.compare(this.heap[i],this.heap[n])<0&&(n=i),n===t)break;this.swap(t,n),t=n}}}class dt extends gt{constructor(t){super(t)}siftUp(t){for(;t>0;){const e=this.getParentIndex(t);if(this.compare(this.heap[t],this.heap[e])<=0)break;this.swap(t,e),t=e}}siftDown(t){const e=this.heap.length;for(;;){let n=t;const r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t);if(r<e&&void 0!==this.heap[r]&&this.compare(this.heap[r],this.heap[n])>0&&(n=r),i<e&&void 0!==this.heap[i]&&this.compare(this.heap[i],this.heap[n])>0&&(n=i),n===t)break;this.swap(t,n),t=n}}}class mt{constructor(){this.nodes=new Map,this.maxComputedM=-1,this.maxComputedN=-1,this.heap=new dt(((t,e)=>t>e?1:t<e?-1:0))}static getNodeKey(t,e){return`${t},${e}`}computeAckermann(t,e){if(t<0||e<0)throw new Error("Ackermann function undefined for negative numbers");const n=mt.getNodeKey(t,e),r=this.nodes.get(n);if(r)return r.value;let i;try{if(0===t)i=BigInt(e+1);else if(0===e)i=this.computeAckermann(t-1,1);else{const n=this.computeAckermann(t,e-1),r=n<=BigInt(Number.MAX_SAFE_INTEGER)?Number(n):Number.MAX_SAFE_INTEGER;i=this.computeAckermann(t-1,r)}}catch(t){if(t instanceof RangeError)return BigInt(Number.MAX_SAFE_INTEGER);throw t}return i}addNode(t,e){const n=mt.getNodeKey(t,e);if(this.nodes.has(n))return this.nodes.get(n);const r=this.computeAckermann(t,e),i={m:t,n:e,value:r};this.nodes.set(n,i);const o=mt.getNodeKey(t-1,e),s=mt.getNodeKey(t,e-1);if(this.nodes.has(o)){const t=this.nodes.get(o);i.prevM=t,t.nextM=i}if(this.nodes.has(s)){const t=this.nodes.get(s);i.prevN=t,t.nextN=i}return this.maxComputedM=Math.max(this.maxComputedM,t),this.maxComputedN=Math.max(this.maxComputedN,e),this.heap.push(r),i}buildRange(t,e){for(let n=0;n<=t;n++)for(let t=0;t<=e;t++)this.addNode(n,t)}getComputationPath(t,e){const n=[],r=mt.getNodeKey(t,e);let i=this.nodes.get(r);for(;i&&(n.push({m:i.m,n:i.n,value:i.value}),0!==i.m);)if(0===i.n)i=this.nodes.get(mt.getNodeKey(i.m-1,1));else{const t=this.nodes.get(mt.getNodeKey(i.m,i.n-1));t&&n.push({m:t.m,n:t.n,value:t.value});const e=t?.value??BigInt(0),r=e<=BigInt(Number.MAX_SAFE_INTEGER)?Number(e):Number.MAX_SAFE_INTEGER;i=this.nodes.get(mt.getNodeKey(i.m-1,r))}return n.reverse()}analyzeGrowthRate(t){const e=new Map;let n=BigInt(1);for(let r=0;r<=this.maxComputedN;r++){const i=mt.getNodeKey(t,r),o=this.nodes.get(i);if(!o||o.value>=BigInt(Number.MAX_SAFE_INTEGER))break;e.set(r,{value:o.value,increase:o.value-n,multiplier:n===BigInt(0)?BigInt(0):o.value/n}),n=o.value}return e}getLargestValue(){return this.heap.peek()??BigInt(0)}getValue(t,e){return this.nodes.get(mt.getNodeKey(t,e))?.value}}class wt{constructor(t){this.value="bigint"==typeof t?t:BigInt(t),this.left=null,this.right=null,this.parent=null,this.height=1,this.size=1,this.sum=this.value}updateStats(){this.height=1+Math.max(this.left?.height??0,this.right?.height??0),this.size=1+(this.left?.size??0)+(this.right?.size??0),this.sum=this.value+(this.left?.sum??BigInt(0))+(this.right?.sum??BigInt(0))}getBalance(){return(this.left?.height??0)-(this.right?.height??0)}getStats(){return{height:this.height,size:this.size,sum:this.sum,min:this.findMin().value,max:this.findMax().value}}findMin(){let t=this;for(;t.left;)t=t.left;return t}findMax(){let t=this;for(;t.right;)t=t.right;return t}}class It{constructor(t){this.root=null,this.comparator=t??((t,e)=>t<e?-1:t>e?1:0)}getRoot(){return this.root}insert(t){const e="bigint"==typeof t?t:BigInt(t);return this.root=this.insertNode(this.root,e),this.find(e)}insertNode(t,e){if(!t)return new wt(e);const n=this.comparator(e,t.value);if(n<0)t.left=this.insertNode(t.left,e),t.left.parent=t;else{if(!(n>0))return t;t.right=this.insertNode(t.right,e),t.right.parent=t}return t.updateStats(),this.balance(t)}balance(t){const e=t.getBalance();return e>1?(t.left&&t.left.getBalance()<0&&(t.left=this.rotateLeft(t.left)),this.rotateRight(t)):e<-1?(t.right&&t.right.getBalance()>0&&(t.right=this.rotateRight(t.right)),this.rotateLeft(t)):t}rotateLeft(t){const e=t.right,n=e.left;return e.left=t,t.right=n,n&&(n.parent=t),e.parent=t.parent,t.parent=e,t.updateStats(),e.updateStats(),e}rotateRight(t){const e=t.left,n=e.right;return e.right=t,t.left=n,n&&(n.parent=t),e.parent=t.parent,t.parent=e,t.updateStats(),e.updateStats(),e}remove(t){const e="bigint"==typeof t?t:BigInt(t);return!!this.find(e)&&(this.root=this.removeNode(this.root,e),!0)}removeNode(t,e){if(!t)return null;const n=this.comparator(e,t.value);if(n<0)t.left=this.removeNode(t.left,e),t.left&&(t.left.parent=t);else if(n>0)t.right=this.removeNode(t.right,e),t.right&&(t.right.parent=t);else{if(!t.left)return t.right;if(!t.right)return t.left;const e=t.right.findMin();t.value=e.value,t.right=this.removeNode(t.right,e.value),t.right&&(t.right.parent=t)}return t.updateStats(),this.balance(t)}find(t){const e="bigint"==typeof t?t:BigInt(t);let n=this.root;for(;n;){const t=this.comparator(e,n.value);if(0===t)return n;n=t<0?n.left:n.right}return null}traverse(t="inOrder",e={}){const n=[],r=(i,o=0)=>{!i||void 0!==e.maxDepth&&o>=e.maxDepth||("preOrder"===t&&n.push(i.value),e.skipSubtrees||r(i.left,o+1),"inOrder"===t&&n.push(i.value),e.skipSubtrees||r(i.right,o+1),"postOrder"===t&&n.push(i.value))};return r(this.root),n}getTreeStats(){return this.root?.getStats()??null}getNthValue(t){if(!this.root||t<1||t>this.root.size)return null;const e=(t,n)=>{if(!t)return null;const r=t.left?.size??0;return n===r+1?t.value:n<=r?e(t.left,n):e(t.right,n-r-1)};return e(this.root,t)}getRange(t,e){const n="bigint"==typeof t?t:BigInt(t),r="bigint"==typeof e?e:BigInt(e),i=[],o=t=>{t&&(this.comparator(t.value,n)>=0&&this.comparator(t.value,r)<=0?(o(t.left),i.push(t.value),o(t.right)):this.comparator(t.value,n)>0?o(t.left):o(t.right))};return o(this.root),i}}class Et{constructor(t={}){const{initialCapacity:e=16,growthFactor:n=2,comparator:r=(t,e)=>t<e?-1:t>e?1:0}=t;this.capacity=e,this.growthFactor=n,this.comparator=r,this.size=0,this.data=new Array(this.capacity),this.segmentTree=new Array(4*this.capacity).fill(null)}getSize(){return this.size}getCapacity(){return this.capacity}resize(t){const e=new Array(t);for(let t=0;t<this.size;t++)e[t]=this.data[t];this.data=e,this.capacity=t,this.rebuildSegmentTree()}push(t){try{return this.size>=this.capacity&&this.resize(this.capacity*this.growthFactor),this.data[this.size]=t,this.updateSegmentTree(0,this.size,t),this.size++,{success:!0,value:this.size-1}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error during push"}}}pop(){if(0===this.size)return{success:!1,error:"Array is empty"};const t=this.data[this.size-1];return this.size--,this.size<this.capacity/(2*this.growthFactor)&&this.resize(Math.max(16,Math.floor(this.capacity/this.growthFactor))),{success:!0,value:t}}get(t){return t<0||t>=this.size?{success:!1,error:"Index out of bounds"}:{success:!0,value:this.data[t]}}set(t,e){if(t<0||t>=this.size)return{success:!1,error:"Index out of bounds"};const n=this.data[t];return this.data[t]=e,this.updateSegmentTree(0,t,e),{success:!0,value:n}}rebuildSegmentTree(){this.segmentTree=new Array(4*this.capacity).fill(null),this.size>0&&this.buildSegmentTree(0,0,this.size-1)}buildSegmentTree(t,e,n){if(e===n)return void(this.segmentTree[t]={value:this.data[e],start:e,end:n});const r=Math.floor((e+n)/2);this.buildSegmentTree(2*t+1,e,r),this.buildSegmentTree(2*t+2,r+1,n);const i=this.segmentTree[2*t+1],o=this.segmentTree[2*t+2];i&&o&&(this.segmentTree[t]={value:this.comparator(i.value,o.value)>=0?i.value:o.value,start:e,end:n})}updateSegmentTree(t,e,n){if(!this.segmentTree[t])return;const r=this.segmentTree[t];if(r.start===r.end)return void(r.value=n);e<=Math.floor((r.start+r.end)/2)?this.updateSegmentTree(2*t+1,e,n):this.updateSegmentTree(2*t+2,e,n);const i=this.segmentTree[2*t+1],o=this.segmentTree[2*t+2];i&&o&&(r.value=this.comparator(i.value,o.value)>=0?i.value:o.value)}queryRange(t,e){if(t<0||e>=this.size||t>e)return{success:!1,error:"Invalid range"};const n=this.querySegmentTree(0,t,e);return n?{success:!0,value:n}:{success:!1,error:"Range query failed"}}querySegmentTree(t,e,n){const r=this.segmentTree[t];if(!r)return null;if(e<=r.start&&n>=r.end)return r.value;if(n<r.start||e>r.end)return null;const i=this.querySegmentTree(2*t+1,e,n),o=this.querySegmentTree(2*t+2,e,n);return null===i?o:null===o||this.comparator(i,o)>=0?i:o}toHeap(t=!0){const e=t?new pt(this.comparator):new dt(this.comparator);for(let t=0;t<this.size;t++)void 0!==this.data[t]&&void 0!==this.data[t]&&e.push(this.data[t]);return e}sort(t=!0){const e=this.toHeap(!t);for(let t=this.size-1;t>=0;t--){const n=e.pop();void 0!==n&&(this.data[t]=n)}this.rebuildSegmentTree()}toArray(){return this.data.slice(0,this.size)}}const vt={maxHeight:100,maxValue:BigInt(Number.MAX_SAFE_INTEGER),checkOverflow:!0,precision:0};class xt{constructor(t={}){this.options={...vt,...t},this.head=null,this.tail=null,this.size=0}createNode(t,e){return{value:t,height:e,evaluated:!1,previous:null,next:null}}validateHeight(t){if(t<0)throw new e("Height cannot be negative");if(t>this.options.maxHeight)throw new e(`Height exceeds maximum of ${this.options.maxHeight}`)}validateValue(t){if(a(t),this.options.checkOverflow&&t>this.options.maxValue)throw new n(`Value exceeds maximum of ${this.options.maxValue}`)}computePower(t,e){if(e===BigInt(0))return BigInt(1);if(e===BigInt(1))return t;let r=t;for(let i=BigInt(1);i<e;i++)if(this.options.checkOverflow){const e=r*t;if(e>this.options.maxValue)throw new n("Power computation would overflow");r=e}else r*=t;return r}build(t,e){this.validateHeight(e);const n="bigint"==typeof t?t:BigInt(t);this.validateValue(n),this.clear();for(let t=0;t<e;t++){const e=this.createNode(n,t+1);this.head?(e.previous=this.tail,this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),this.size++}}evaluate(t){if(!this.head)return BigInt(1);const e=t??this.size;this.validateHeight(e);let r=this.head,i=r.value,o=1;try{for(;r.next&&o<e;)i=this.computePower(r.next.value,i),r.evaluated=!0,r=r.next,o++;return r.evaluated=!0,i}catch(t){if(t instanceof n){let e=this.head;for(;e!==r;)e.evaluated=!0,e=e.next;throw t}throw t}}getHeight(){return this.size}isComputable(t){try{const e=t??this.size;this.validateHeight(e);let n=this.head,r=0;for(;n&&r<e;){if(n.value>BigInt(4)&&r>3)return!1;n=n.next,r++}const i={...this.options,maxValue:this.options.maxValue>>BigInt(1)},o=new xt(i);return o.build(this.head.value,e),o.evaluate(),!0}catch{return!1}}getState(){const t=[];let e=this.head;for(;e;)t.push({height:e.height,value:e.value,evaluated:e.evaluated}),e=e.next;return t}clear(){this.head=null,this.tail=null,this.size=0}static getMaxFeasibleHeight(t){const e="bigint"==typeof t?t:BigInt(t);return a(e),e===BigInt(0)?0:e===BigInt(1)?1/0:e===BigInt(2)?4:e===BigInt(3)?3:e===BigInt(4)?2:1}toString(){if(!this.head)return"Empty Tower";let t=this.head.value.toString(),e=this.head;for(;e.next;)t=`${e.next.value}^(${t})`,e=e.next;return t}}const Bt={notation:"standard",precision:0,grouping:!0,groupSize:3,decimalSeparator:".",groupSeparator:","},bt=(t,e={})=>{const n={...Bt,...e},r=t<BigInt(0),i=r?-t:t;let o;switch(n.notation){case"scientific":o=Nt(i,n).coefficient+"e"+Nt(i,n).exponent;break;case"engineering":o=At(i,n);break;case"compact":o=Mt(i,n);break;default:o=St(i,n)}return r?"-"+o:o},St=(t,e)=>{let n=t.toString();if(!e.grouping)return n;const r=[];let i=n.length;for(;i>0;){const t=Math.max(0,i-e.groupSize);r.unshift(n.slice(t,i)),i=t}return r.join(e.groupSeparator)},Nt=(t,e)=>{if(t===BigInt(0))return{coefficient:"0",exponent:0};const n=t.toString(),r=n.length-1;let i=n[0]||"";return i+=e.decimalSeparator+n.slice(1,e.precision+1),{coefficient:i,exponent:r}},At=(t,e)=>{if(t===BigInt(0))return"0";const n=t.toString(),r=n.length,i=3*Math.floor((r-1)/3);let o="";const s=r-i;for(let t=0;t<Math.min(r,s+e.precision);t++)t===s&&t<r&&(o+=e.decimalSeparator),o+=n[t];return`${o}e${i}`},Mt=(t,e)=>{const n=["","K","M","B","T","Q"],r=t.toString().length;if(r<=3)return St(t,e);const i=Math.min(Math.floor((r-1)/3),n.length-1),o=n[i],s=BigInt(10)**BigInt(3*i);let a=(t/s).toString();if(e.precision>0){const n=t%s;if(n>BigInt(0)){const t=n.toString().padStart(3,"0").slice(0,e.precision);a+=e.decimalSeparator+t}}return a+o};class yt{constructor(t={}){if(this.config={precision:t.precision??C.precision,roundingMode:t.roundingMode??C.roundingMode,checkOverflow:t.checkOverflow??C.checkOverflow,maxSteps:t.maxSteps??C.maxSteps,debug:t.debug??T.DEBUG_MODE},this.config.precision<0||this.config.precision>100)throw new L("Precision must be between 0 and 100");if(this.config.maxSteps<1||this.config.maxSteps>x)throw new L("Max steps must be between 1 and 1000");this.structures={arrays:new Map,trees:new Map,heaps:new Map}}add(t,e){return j(t,e,this.config)}subtract(t,e){return W(t,e,this.config)}multiply(t,e){return Z(t,e,this.config)}divide(t,e){return q(t,e,this.config)}mod(t,e){return Y(t,e,this.config)}power(t,e){return ct(t,e,this.config)}sqrt(t){return ht(t,this.config)}nthRoot(t,e){return lt(t,e,this.config)}and(t,e){return nt(t,e)}or(t,e){return rt(t,e)}xor(t,e){return it(t,e)}not(t){return ot(t)}createArray(t){if(this.structures.arrays.has(t))throw new L(`Array with id '${t}' already exists`);const e=new Et;return this.structures.arrays.set(t,e),e}getArray(t){const e=this.structures.arrays.get(t);if(!e)throw new L(`Array with id '${t}' not found`);return e}createTree(t){if(this.structures.trees.has(t))throw new L(`Tree with id '${t}' already exists`);const e=new It;return this.structures.trees.set(t,e),e}getTree(t){const e=this.structures.trees.get(t);if(!e)throw new L(`Tree with id '${t}' not found`);return e}createHeap(t,e=!0){if(this.structures.heaps.has(t))throw new L(`Heap with id '${t}' already exists`);const n=e?new pt(this.compareValues):new dt(this.compareValues);return this.structures.heaps.set(t,n),n}getHeap(t){const e=this.structures.heaps.get(t);if(!e)throw new L(`Heap with id '${t}' not found`);return e}createAckermannStructure(){return new mt}format(t,e){const n=r(t);return bt(n,e)}validate(t){try{return r(t),!0}catch{return!1}}updateConfig(t){Object.assign(this.config,t)}getConfig(){return{...this.config}}compareValues(t,e){return t<e?-1:t>e?1:0}dispose(){this.structures.arrays.clear(),this.structures.trees.clear(),this.structures.heaps.clear()}}const Ot={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,tolerance:0};function _t(t,e,n={}){const i={...Ot,...n},o=r(t),s=r(e);if(0===i.precision&&0===i.tolerance)return o<s?-1:o>s?1:0;const[a,u]=l(o,s,i.precision,i.precision);if(i.tolerance>0){const t=a-u,e=BigInt(10)**BigInt(i.tolerance);return t<-e?-1:t>e?1:0}return a<u?-1:a>u?1:0}function Rt(t,e,n={}){return 0===_t(t,e,n)}function Tt(t,e,n={}){return-1===_t(t,e,n)}function Ct(t,e,n={}){const r=_t(t,e,n);return-1===r||0===r}function Pt(t,e,n={}){return 1===_t(t,e,n)}function Lt(t,e,n={}){const r=_t(t,e,n);return 1===r||0===r}const Ft={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,uppercase:!1,prefix:!1,minDigits:1};const Dt={maxValue:1e3,checkOverflow:!0,useCache:!0},Vt=new Map;function Ht(t,e={}){const i={...Dt,...e},o=r(t);if(a(o),i.checkOverflow&&o>BigInt(i.maxValue))throw new n(`Factorial input too large: maximum allowed is ${i.maxValue}`);if(o<=1n)return 1n;if(i.useCache&&Vt.has(o))return Vt.get(o);let s=1n;for(let t=2n;t<=o;t++)s*=t;return i.useCache&&Vt.set(o,s),s}function kt(t){const e=I(t||{});w(e);const n={precision:"arithmetic"in e?e.arithmetic.defaultPrecision:e.precision,roundingMode:"arithmetic"in e?e.arithmetic.defaultRoundingMode:e.roundingMode,checkOverflow:"arithmetic"in e?e.arithmetic.checkOverflow:e.checkOverflow,maxSteps:"arithmetic"in e?e.arithmetic.maxComputationSteps:e.maxSteps,debug:"object"==typeof e.debug?e.debug.verbose:!!e.debug};return new yt(n)}const zt=kt();t.AckermannStructure=mt,t.BigArray=Et,t.ComputationLimitError=H,t.DEFAULT_ARRAY_GROWTH_FACTOR=2,t.DEFAULT_BASIC_CONFIG=g,t.DEFAULT_CACHE_SIZE=1e3,t.DEFAULT_DECIMAL_SEPARATOR=".",t.DEFAULT_FULL_CONFIG=p,t.DEFAULT_GROUP_SEPARATOR=",",t.DEFAULT_GROUP_SIZE=3,t.DEFAULT_HEAP_INITIAL_CAPACITY=16,t.DEFAULT_OPTIONS=C,t.DEFAULT_TREE_MAX_DEPTH=1e3,t.DataStructureError=k,t.DivisionByZeroError=D,t.ERROR_MESSAGES=R,t.FEATURES=T,t.FormatError=G,t.HeapPropertyError=z,t.Hypernum=yt,t.HypernumError=P,t.IndexError=$,t.MAX_ACKERMANN_M=4,t.MAX_ACKERMANN_N=1e3,t.MAX_BITS=1024,t.MAX_CACHE_SIZE=1e4,t.MAX_COMPUTATION_STEPS=x,t.MAX_FACTORIAL_INPUT=_,t.MAX_GROUP_SIZE=10,t.MAX_POWER_BASE=M,t.MAX_POWER_EXPONENT=y,t.MAX_PRECISION=100,t.MAX_ROMAN_VALUE=3999,t.MAX_SAFE_INTEGER=E,t.MAX_TETRATION_HEIGHT=O,t.MIN_ARRAY_CAPACITY=16,t.MIN_ROMAN_VALUE=1,t.MIN_SAFE_INTEGER=v,t.MaxHeap=dt,t.MinHeap=pt,t.NEGATIVE_ONE=A,t.NUMBER_UNITS=[{value:1n,symbol:""},{value:1000n,symbol:"K"},{value:1000000n,symbol:"M"},{value:1000000000n,symbol:"B"},{value:1000000000000n,symbol:"T"},{value:1000000000000000n,symbol:"Q"}],t.NumberTree=It,t.ONE=b,t.PERFORMANCE={WARN_THRESHOLD_MS:100,ERROR_THRESHOLD_MS:1e3,MAX_ARRAY_SIZE:1e6,MAX_TREE_SIZE:1e6},t.PowerTower=xt,t.PrecisionError=V,t.RomanNumeralError=X,t.TEN=N,t.TWO=S,t.TreeError=U,t.UnderflowError=F,t.VERSION="0.1.0",t.ZERO=B,t.abs=Q,t.add=j,t.allEqual=function(t,e={}){if(t.length<=1)return!0;const n=r(t[0]);return t.every((t=>Rt(t,n,e)))},t.and=nt,t.between=function(t,e,n,r={}){return Lt(t,e,r)&&Ct(t,n,r)},t.binomial=function t(n,i,o={}){const s={...Dt,...o},u=r(n),c=r(i);if(a(u),a(c),c>u)throw new e("K cannot be greater than N in binomial coefficient");if(c>u/2n)return t(u,u-c,s);let h=1n;for(let t=0n;t<c;t++)h=h*(u-t)/(t+1n);return h},t.checkAdditionOverflow=i,t.checkMultiplicationOverflow=o,t.checkPowerOverflow=s,t.clamp=function(t,n,i,o={}){const s=r(t),a=r(n),u=r(i);if(Tt(u,a,o))throw new e("Maximum bound must be greater than or equal to minimum bound");return Tt(s,a,o)?a:Pt(s,u,o)?u:s},t.clearBit=function(t,n,i={}){const o={...tt,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return s&~(1n<<u)},t.compare=_t,t.convertToBasicConfig=function(t){return m(t)?t:{precision:t.arithmetic.defaultPrecision,roundingMode:t.arithmetic.defaultRoundingMode,checkOverflow:t.arithmetic.checkOverflow,maxSteps:t.arithmetic.maxComputationSteps,debug:t.debug.verbose}},t.createComparator=function(t={}){return(e,n)=>_t(e,n,t)},t.createHypernum=kt,t.default=yt,t.defaultHypernum=zt,t.divide=q,t.equals=Rt,t.factorial=Ht,t.fallingFactorial=function(t,e,i={}){const o={...Dt,...i},s=r(t),u=r(e);if(a(u),o.checkOverflow&&u>BigInt(o.maxValue))throw new n(`Falling factorial input too large: maximum allowed is ${o.maxValue}`);let c=1n;for(let t=0n;t<u;t++)c*=s-t;return c},t.formatBigInt=bt,t.fromBase=function(t,n){if(n<2||n>36)throw new e("Base must be between 2 and 36");const r=t.toLowerCase().replace(/^0x/,"").replace(/^0b/,"").replace(/^0o/,"");try{return BigInt(`${n}n${r}`)}catch(r){throw new e(`Invalid number format for base ${n}: ${t}`)}},t.fromFraction=function(t,n,i={}){const o={...Ft,...i},s=r(t),a=r(n);if(0n===a)throw new e("Denominator cannot be zero");const u=s/a,c=s%a;return 0n===c||0===o.precision?u.toString():`${u}.${(c*10n**BigInt(o.precision)/a).toString().padStart(o.precision,"0")}`},t.fromRoman=function(t){const n=new Map([["I",1],["V",5],["X",10],["L",50],["C",100],["D",500],["M",1e3]]);let r=0,i=0;for(let o=t.length-1;o>=0;o--){const s=t[o]?.toUpperCase()??"",a=n.get(s);if(void 0===a)throw new e(`Invalid Roman numeral character: ${s}`);a>=i?r+=a:r-=a,i=a}return BigInt(r)},t.fromScientific=function(t){const n=t.match(/^(-?\d+\.?\d*)[eE]([+-]?\d+)$/);if(!n)throw new e("Invalid scientific notation format");const[,r,i]=n,o=parseInt(i||"0",10);if(o>=0){if(void 0===r)throw new e("Invalid scientific notation format");return(BigInt(r.replace(".",""))*10n**BigInt(o)).toString()}{const t=Math.abs(o);if(void 0===r)throw new e("Invalid scientific notation format");return(BigInt(r.replace(".",""))/10n**BigInt(t)).toString()}},t.gcd=J,t.getBit=function(t,n,i={}){const o={...tt,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return 0n!==(s&1n<<u)},t.greaterThan=Pt,t.greaterThanOrEqual=Lt,t.isAscending=function(t,e={}){if(t.length<=1)return!0;for(let n=1;n<t.length;n++)if(void 0===t[n]||void 0===t[n-1]||!Lt(t[n],t[n-1],e))return!1;return!0},t.isBasicConfig=m,t.isDescending=function(t,e={}){if(t.length<=1)return!0;for(let n=1;n<t.length;n++)if(void 0===t[n]||void 0===t[n-1]||!Ct(t[n],t[n-1],e))return!1;return!0},t.isFullConfig=d,t.lcm=function(t,e){const n=Q(r(t)),i=Q(r(e));return n===BigInt(0)||i===BigInt(0)?BigInt(0):Q(n*i)/J(n,i)},t.leadingZeros=function(t,e={}){const n={...tt,...e};let i=r(t);if(0n===i)return BigInt(n.maxBits);let o=0n;const s=1n<<BigInt(n.maxBits-1);for(;0n===(i&s)&&o<BigInt(n.maxBits);)o++,i=st(i,1n,n);return o},t.leftShift=st,t.lessThan=Tt,t.lessThanOrEqual=Ct,t.max=function(t,n={}){if(0===t.length)throw new e("Cannot find maximum of empty array");return t.reduce(((t,e)=>{const i=r(t),o=r(e);return Pt(o,i,n)?o:i}),r(t[0]))},t.mergeConfig=I,t.min=function(t,n={}){if(0===t.length)throw new e("Cannot find minimum of empty array");return t.reduce(((t,e)=>{const i=r(t),o=r(e);return Tt(o,i,n)?o:i}),r(t[0]))},t.multiFactorial=function(t,i=2n,o={}){const s={...Dt,...o},u=r(t),c=r(i);if(a(u),c<=0n)throw new e("K must be positive in multifactorial");if(s.checkOverflow&&u>BigInt(s.maxValue))throw new n(`Multifactorial input too large: maximum allowed is ${s.maxValue}`);let h=1n,l=u;for(;l>0n;)h*=l,l-=c;return h},t.multiply=Z,t.normalizeNumberString=t=>{if((t=t.replace(/[\s,]/g,"")).toLowerCase().includes("e")){const[e,n]=t.toLowerCase().split("e"),r=parseInt(n||"0");return(parseFloat(e||"0")*Math.pow(10,r)).toString()}return t},t.normalizePrecision=l,t.not=ot,t.nthRoot=lt,t.or=rt,t.parseBigIntString=(t,e={})=>{const n={...Bt,...e};let r=t.replace(new RegExp(`\\${n.groupSeparator}`,"g"),"");if(r.toLowerCase().includes("e")){const[t,e]=r.toLowerCase().split("e"),n=BigInt(10),i=BigInt(e||"0");return BigInt(Math.floor(Number(t)))*n**i}const i=new Map([["k",BigInt(1e3)],["m",BigInt(1e6)],["b",BigInt(1e9)],["t",BigInt(1e12)],["q",BigInt(1e15)]]),o=r.slice(-1).toLowerCase(),s=i.get(o);if(s){r=r.slice(0,-1);return BigInt(Math.floor(Number(r)))*s}return BigInt(r)},t.popCount=function(t,e={}){const n={...tt,...e};let i=r(t),o=0n;for(;0n!==i;)o+=1n&i,i=at(i,1n,n);return o},t.power=ct,t.primorial=function(t,e={}){const i={...Dt,...e},o=r(t);if(a(o),i.checkOverflow&&o>BigInt(i.maxValue))throw new n(`Primorial input too large: maximum allowed is ${i.maxValue}`);if(o<=1n)return 1n;const s=Number(o),u=new Array(s+1).fill(!0);u[0]=u[1]=!1;for(let t=2;t*t<=s;t++)if(u[t])for(let e=t*t;e<=s;e+=t)u[e]=!1;let c=1n;for(let t=2;t<=s;t++)u[t]&&(c*=BigInt(t));return c},t.remainder=Y,t.rightShift=function(t,e,n={}){const i={...tt,...n},o=r(t),s=r(e);return et(s,i),o>>s},t.risingFactorial=function(t,e,i={}){const o={...Dt,...i},s=r(t),u=r(e);if(a(u),o.checkOverflow&&u>BigInt(o.maxValue))throw new n(`Rising factorial input too large: maximum allowed is ${o.maxValue}`);let c=1n;for(let t=0n;t<u;t++)c*=s+t;return c},t.rotateLeft=function(t,e,n={}){const i={...tt,...n},o=r(t);let s=r(e);return a(s),s>=BigInt(i.maxBits)&&(s%=BigInt(i.maxBits)),0n===s?o:st(o,s,i)|at(o,BigInt(i.maxBits)-s,i)},t.rotateRight=function(t,e,n={}){const i={...tt,...n},o=r(t);let s=r(e);if(a(s),s>=BigInt(i.maxBits)&&(s%=BigInt(i.maxBits)),0n===s)return o;const u=at(o,s,i);return st(o,BigInt(i.maxBits)-s,i)|u},t.round=h,t.scaleByPowerOfTen=c,t.scaledDivision=f,t.setBit=function(t,n,i={}){const o={...tt,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return s|1n<<u},t.sign=function(t){const e=r(t);return e<BigInt(0)?BigInt(-1):e>BigInt(0)?BigInt(1):BigInt(0)},t.sqrt=ht,t.subfactorial=function(t,e={}){const i={...Dt,...e},o=r(t);if(a(o),i.checkOverflow&&o>BigInt(i.maxValue))throw new n(`Subfactorial input too large: maximum allowed is ${i.maxValue}`);if(0n===o)return 1n;if(1n===o)return 0n;let s=0n;const u=Ht(o,i);for(let t=0n;t<=o;t++){s+=Ht(o-t,i)*(t%2n===0n?1n:-1n)}return u-s},t.subtract=W,t.superRoot=function(t,i,o={}){const s={...ut,...o},u=r(t),c=r(i);if(a(c),0n===c)throw new e("Height cannot be zero for super-root");if(u<1n)throw new e("Value must be at least 1 for super-root");if(1n===u)return 1n;if(1n===c)return u;let l=1n,f=u,g=0;for(;l<=f;){if(g++>s.maxSteps)throw new n("Super-root operation exceeded maximum computation steps");const t=l+f>>1n;try{const e=ft(t,c,s);if(e===u)return t;e<u?l=t+1n:f=t-1n}catch(e){f=t-1n}}return s.precision>0?h(f,s.precision,s.roundingMode):f},t.tetration=ft,t.toBase=function(t,n,i={}){if(n<2||n>36)throw new e("Base must be between 2 and 36");const o={...Ft,...i};let s=r(t).toString(n);for(o.uppercase&&(s=s.toUpperCase());s.length<o.minDigits;)s="0"+s;return s},t.toBigInt=r,t.toBinary=function(t,e={}){const n={...Ft,...e};let i=r(t).toString(2);for(;i.length<n.minDigits;)i="0"+i;return n.prefix?"0b"+i:i},t.toFraction=function(t){const[e,n=""]=t.split(".");if(!n)return[r(e),1n];const i=r(e+n),o=10n**BigInt(n.length),s=function(t,e){t=t<0n?-t:t,e=e<0n?-e:e;for(;0n!==e;){const n=e;e=t%e,t=n}return t}(i,o);return[i/s,o/s]},t.toHexadecimal=function(t,e={}){const n={...Ft,...e};let i=r(t).toString(16);for(n.uppercase&&(i=i.toUpperCase());i.length<n.minDigits;)i="0"+i;return n.prefix?"0x"+i:i},t.toOctal=function(t,e={}){const n={...Ft,...e};let i=r(t).toString(8);for(;i.length<n.minDigits;)i="0"+i;return n.prefix?"0o"+i:i},t.toRoman=function(t,n={}){const i={...Ft,...n},o=Number(r(t));if(o<=0||o>3999)throw new e("Number must be between 1 and 3999 for Roman numerals");const s=[["I","V"],["X","L"],["C","D"],["M"]];let a="",u=0,c=o;for(;c>0;){const t=c%10,e=s[u];if(!e)break;const n=e[0],r=e[1]??"",i=u<3?s[u+1]?.[0]??"":"";let o="";o=9===t&&i?n+i:t>=5&&r?r+n.repeat(t-5):4===t&&r?n+r:n.repeat(t),a=o+a,c=Math.floor(c/10),u++}return i.uppercase?a:a.toLowerCase()},t.toScientific=function(t,e={}){const n={...Ft,...e},i=r(t);if(0n===i)return"0e0";const o=i.toString(),s="-"===o[0]?o[1]:o[0],a=o.length-("-"===o[0]?2:1);let u=s;if(o.length>1){const t=o.slice("-"===o[0]?2:1);n.precision>0&&(u+="."+t.slice(0,n.precision))}return"-"===o[0]&&(u="-"+u),`${u}e${a}`},t.toggleBit=function(t,n,i={}){const o={...tt,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return s^1n<<u},t.trailingZeros=function(t,e={}){const n={...tt,...e};let i=r(t);if(0n===i)return BigInt(n.maxBits);let o=0n;for(;0n===(1n&i);)o++,i=at(i,1n,n);return o},t.unsignedRightShift=at,t.validateConfig=w,t.validateNonNegative=a,t.validatePositive=t=>{if(t<=BigInt(0))throw new e("Value must be positive")},t.xor=it,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
