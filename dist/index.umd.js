/**
 * @obinexuscomputing/hypernum v0.1.0
 * A JavaScript/TypeScript library for large number operations with BigInt compatibility
 * @license ISC
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Hypernum={})}(this,(function(t){"use strict";let e=class extends Error{constructor(t){super(t),this.name="ValidationError"}},n=class extends Error{constructor(t){super(t),this.name="OverflowError"}};const r=t=>{if((t=>"bigint"==typeof t)(t))return t;if("string"==typeof t){if(!(t=>/^-?\d+$/.test(t))(t))throw new e(`Invalid number string: ${t}`);return BigInt(t)}if((t=>"number"==typeof t&&!isNaN(t)&&isFinite(t))(t)){if(!Number.isInteger(t))throw new e("Cannot convert non-integer number to BigInt");return BigInt(t)}throw new e(`Cannot convert ${typeof t} to BigInt`)},i=(t,e)=>{if(e>0&&t>BigInt(Number.MAX_SAFE_INTEGER)-e)throw new n("Addition would overflow");if(e<0&&t<BigInt(Number.MIN_SAFE_INTEGER)-e)throw new n("Addition would underflow")},o=(t,e)=>{if(t!==BigInt(0)&&e!==BigInt(0)){const r=BigInt(Number.MAX_SAFE_INTEGER),i=BigInt(Number.MIN_SAFE_INTEGER);if(t>r/e||t<i/e)throw new n("Multiplication would overflow")}},s=(t,r)=>{if(r<BigInt(0))throw new e("Negative exponents not supported for integers");if(t===BigInt(0)&&r===BigInt(0))throw new e("Zero raised to zero is undefined");if(r>BigInt(1e3))throw new n("Exponent too large, computation would overflow")},a=t=>{if(t<BigInt(0))throw new e("Value must be non-negative")};var u;t.RoundingMode=void 0,(u=t.RoundingMode||(t.RoundingMode={})).FLOOR="FLOOR",u.CEIL="CEIL",u.DOWN="DOWN",u.UP="UP",u.HALF_EVEN="HALF_EVEN",u.HALF_UP="HALF_UP",u.HALF_DOWN="HALF_DOWN";const c=(t,e)=>0===e?t:e>0?t*BigInt(10)**BigInt(e):t/BigInt(10)**BigInt(-e),h=(n,r=0,i=t.RoundingMode.HALF_EVEN)=>{if(r<0)throw new e("Precision must be non-negative");if(0===r)return n;const o=BigInt(10)**BigInt(r),s=n/o,a=n%o;switch(i){case t.RoundingMode.FLOOR:return s*o;case t.RoundingMode.CEIL:return a>0n?(s+1n)*o:s*o;case t.RoundingMode.DOWN:return n>=0n?s*o:(s-1n)*o;case t.RoundingMode.UP:return n>=0n?(s+1n)*o:s*o;case t.RoundingMode.HALF_UP:return a>=o/2n?(s+1n)*o:s*o;case t.RoundingMode.HALF_DOWN:return a>o/2n?(s+1n)*o:s*o;case t.RoundingMode.HALF_EVEN:return a===o/2n?s%2n===0n?s*o:(s+1n)*o:a>o/2n?(s+1n)*o:s*o;default:throw new e("Invalid rounding mode")}},l=(t,e,n,r)=>{const i=Math.max(n,r);return[c(t,i-n),c(e,i-r)]},p=(n,r,i,o=t.RoundingMode.HALF_EVEN)=>{if(0n===r)throw new e("Division by zero");if(i<0)throw new e("Precision must be non-negative");const s=c(n,i);return h(s/r,0,o)},g={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxSteps:1e3,debug:!1},f={arithmetic:{defaultPrecision:0,defaultRoundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxComputationSteps:1e3,autoPrecision:{enabled:!0,maxPrecision:100,minPrecision:0},constants:{precision:50,cache:!0,algorithm:"series"}},dataStructures:{array:{initialCapacity:16,growthFactor:2,maxSize:1e6},tree:{maxDepth:1e3,autoBalance:!0,nodeLimit:1e6},heap:{initialCapacity:16,growthPolicy:"double",validatePropertyOnOperation:!0},cache:{enabled:!0,maxSize:1e3,ttl:36e5,evictionPolicy:"LRU",persistToDisk:!1,compressionEnabled:!1}},formatting:{notation:"standard",precision:0,grouping:!0,groupSize:3,decimalSeparator:".",groupSeparator:",",uppercase:!1,scientific:{minExponent:6,maxSignificantDigits:6,exponentSeparator:"e"},engineering:{useSIPrefixes:!0},localization:{locale:"en-US",useLocaleGrouping:!1}},performance:{enableTracking:!1,samplingRate:.1,thresholds:{warnThresholdMs:100,errorThresholdMs:1e3,maxMemoryBytes:1073741824},metrics:{timing:!0,memory:!0,cache:!0}},debug:{verbose:!1,trackPerformance:!1,logLevel:"error"},features:{experimentalFeatures:!1,useWasm:!1,workerThreads:!1,sharedArrayBuffer:!1,bigIntTypedArrays:!0}};function d(t){return"arithmetic"in t&&"dataStructures"in t}function m(t){d(t)?function(t){if(t.arithmetic.defaultPrecision<0)throw new Error("Default precision cannot be negative");if(t.arithmetic.maxComputationSteps<=0)throw new Error("Max computation steps must be positive");if(t.dataStructures.array.initialCapacity<=0)throw new Error("Initial capacity must be positive");if(t.dataStructures.array.growthFactor<=1)throw new Error("Growth factor must be greater than 1");if(t.performance.samplingRate<0||t.performance.samplingRate>1)throw new Error("Sampling rate must be between 0 and 1")}(t):function(t){if(void 0!==t.precision&&t.precision<0)throw new Error("Precision cannot be negative");if(void 0!==t.maxSteps&&t.maxSteps<=0)throw new Error("Maximum steps must be positive");if(void 0!==t.debug&&"boolean"!=typeof t.debug)throw new Error("Debug flag must be a boolean")}(t)}const I=BigInt(Number.MAX_SAFE_INTEGER),E=BigInt(Number.MIN_SAFE_INTEGER),w=BigInt(0),v=BigInt(1),B=BigInt(2),x=BigInt(10),N=BigInt(-1),A=BigInt(2)**BigInt(53),b=BigInt(1e3),S=BigInt(4),M=BigInt(1e3),_={OVERFLOW:"Operation would result in overflow",UNDERFLOW:"Operation would result in underflow",NEGATIVE_ROOT:"Cannot compute root of negative number",NEGATIVE_EXPONENT:"Negative exponents not supported for integers",DIVISION_BY_ZERO:"Division by zero",INVALID_PRECISION:"Precision must be non-negative and not exceed MAX_PRECISION",INVALID_BASE:"Base must be a positive integer",INVALID_ROMAN:"Invalid Roman numeral",COMPUTATION_LIMIT:"Computation exceeded maximum allowed steps",NEGATIVE_INDEX:"Array index cannot be negative",TREE_DEPTH_EXCEEDED:"Maximum tree depth exceeded",INVALID_HEAP_PROPERTY:"Heap property violation detected"},y={precision:0,roundingMode:"HALF_EVEN",checkOverflow:!0,maxSteps:1e3,grouping:!0,uppercase:!1,cache:!0};class O extends Error{constructor(t){super(t),this.name="HypernumError",Object.setPrototypeOf(this,O.prototype)}}class R extends O{constructor(t){super(t),this.name="ValidationError",Object.setPrototypeOf(this,R.prototype)}}class T extends O{constructor(t=_.OVERFLOW){super(t),this.name="OverflowError",Object.setPrototypeOf(this,T.prototype)}}class P extends O{constructor(t=_.UNDERFLOW){super(t),this.name="UnderflowError",Object.setPrototypeOf(this,P.prototype)}}class L extends O{constructor(t=_.DIVISION_BY_ZERO){super(t),this.name="DivisionByZeroError",Object.setPrototypeOf(this,L.prototype)}}class F extends O{constructor(t=_.INVALID_PRECISION){super(t),this.name="PrecisionError",Object.setPrototypeOf(this,F.prototype)}}class C extends O{constructor(t=_.COMPUTATION_LIMIT){super(t),this.name="ComputationLimitError",Object.setPrototypeOf(this,C.prototype)}}class H extends O{constructor(t){super(t),this.name="DataStructureError",Object.setPrototypeOf(this,H.prototype)}}class D extends H{constructor(t=_.INVALID_HEAP_PROPERTY){super(t),this.name="HeapPropertyError",Object.setPrototypeOf(this,D.prototype)}}class z extends H{constructor(t=_.TREE_DEPTH_EXCEEDED){super(t),this.name="TreeError",Object.setPrototypeOf(this,z.prototype)}}class V extends H{constructor(t=_.NEGATIVE_INDEX){super(t),this.name="IndexError",Object.setPrototypeOf(this,V.prototype)}}class k extends O{constructor(t){super(t),this.name="FormatError",Object.setPrototypeOf(this,k.prototype)}}class U extends k{constructor(t=_.INVALID_ROMAN){super(t),this.name="RomanNumeralError",Object.setPrototypeOf(this,U.prototype)}}function X(t){return t instanceof O}const G={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0};function $(t,e,n={}){const i={...G,...n},u=r(t),c=r(e);if(i.checkOverflow&&s(u,c),a(c),c===BigInt(0))return BigInt(1);if(c===BigInt(1))return u;let l=u,p=c-BigInt(1);for(;p>BigInt(0);)i.checkOverflow&&o(l,u),l*=u,p--;return i.precision>0?h(l,i.precision,i.roundingMode):l}function W(t){const e=r(t);return e<BigInt(0)?-e:e}function j(t,e){let n=W(r(t)),i=W(r(e));for(;i!==BigInt(0);){const t=i;i=n%i,n=t}return n}var K={add:function(t,e,n={}){const o={...G,...n},s=r(t),a=r(e);if(o.checkOverflow&&i(s,a),0===o.precision)return s+a;const[u,c]=l(s,a,o.precision,o.precision);return h(u+c,o.precision,o.roundingMode)},subtract:function(t,e,n={}){const o={...G,...n},s=r(t),a=r(e);if(o.checkOverflow&&i(s,-a),0===o.precision)return s-a;const[u,c]=l(s,a,o.precision,o.precision);return h(u-c,o.precision,o.roundingMode)},multiply:function(t,e,n={}){const i={...G,...n},s=r(t),a=r(e);i.checkOverflow&&o(s,a);const u=s*a;return 0===i.precision?u:h(u,i.precision,i.roundingMode)},divide:function(t,n,i={}){const o={...G,...i},s=r(t),a=r(n);if(a===BigInt(0))throw new e("Division by zero");return p(s,a,o.precision,o.roundingMode)},remainder:function(t,n,i={}){const o={...G,...i},s=r(t),a=r(n);if(a===BigInt(0))throw new e("Division by zero in remainder operation");if(0===o.precision)return s%a;const[u,c]=l(s,a,o.precision,o.precision);return h(u%c,o.precision,o.roundingMode)},power:$,sqrt:function(t,e={}){const n={...G,...e},i=r(t);if(a(i),i===BigInt(0))return BigInt(0);const o=i*BigInt(10)**BigInt(2*n.precision);let s=o,u=s+o/s>>BigInt(1);for(;u<s;)s=u,u=s+o/s>>BigInt(1);return h(s,n.precision,n.roundingMode)},abs:W,sign:function(t){const e=r(t);return e<BigInt(0)?BigInt(-1):e>BigInt(0)?BigInt(1):BigInt(0)},gcd:j,lcm:function(t,e){const n=W(r(t)),i=W(r(e));return n===BigInt(0)||i===BigInt(0)?BigInt(0):W(n*i)/j(n,i)}};const Z={maxBits:1024,strict:!0};function q(t,n){if(t<0n)throw new e("Shift amount cannot be negative");if(n.strict&&t>=BigInt(n.maxBits))throw new e(`Shift amount exceeds maximum of ${n.maxBits} bits`)}function Y(t,e,n={}){const i={...Z,...n},o=r(t),s=r(e);return q(s,i),o<<s}function Q(t,e,n={}){const i={...Z,...n},o=r(t),s=r(e);if(q(s,i),o>=0n)return o>>s;return(o&(1n<<BigInt(i.maxBits))-1n)>>s}var J={and:function(t,e){return r(t)&r(e)},or:function(t,e){return r(t)|r(e)},xor:function(t,e){return r(t)^r(e)},not:function(t){return~r(t)},leftShift:Y,rightShift:function(t,e,n={}){const i={...Z,...n},o=r(t),s=r(e);return q(s,i),o>>s},unsignedRightShift:Q,rotateLeft:function(t,e,n={}){const i={...Z,...n},o=r(t);let s=r(e);return a(s),s>=BigInt(i.maxBits)&&(s%=BigInt(i.maxBits)),0n===s?o:Y(o,s,i)|Q(o,BigInt(i.maxBits)-s,i)},rotateRight:function(t,e,n={}){const i={...Z,...n},o=r(t);let s=r(e);if(a(s),s>=BigInt(i.maxBits)&&(s%=BigInt(i.maxBits)),0n===s)return o;const u=Q(o,s,i);return Y(o,BigInt(i.maxBits)-s,i)|u},popCount:function(t,e={}){const n={...Z,...e};let i=r(t),o=0n;for(;0n!==i;)o+=1n&i,i=Q(i,1n,n);return o},trailingZeros:function(t,e={}){const n={...Z,...e};let i=r(t);if(0n===i)return BigInt(n.maxBits);let o=0n;for(;0n===(1n&i);)o++,i=Q(i,1n,n);return o},leadingZeros:function(t,e={}){const n={...Z,...e};let i=r(t);if(0n===i)return BigInt(n.maxBits);let o=0n;const s=1n<<BigInt(n.maxBits-1);for(;0n===(i&s)&&o<BigInt(n.maxBits);)o++,i=Y(i,1n,n);return o},getBit:function(t,n,i={}){const o={...Z,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return 0n!==(s&1n<<u)},setBit:function(t,n,i={}){const o={...Z,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return s|1n<<u},clearBit:function(t,n,i={}){const o={...Z,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return s&~(1n<<u)},toggleBit:function(t,n,i={}){const o={...Z,...i},s=r(t),u=r(n);if(a(u),o.strict&&u>=BigInt(o.maxBits))throw new e(`Bit position exceeds maximum of ${o.maxBits} bits`);return s^1n<<u}};const tt={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxSteps:1e3};function et(t,i,o={}){const a={...tt,...o},u=r(t),c=r(i);if(0n===c)return 1n;if(1n===c)return u;if(0n===u&&c<0n)throw new e("Zero cannot be raised to a negative power");if(0n===u)return 0n;if(1n===u)return 1n;if(-1n===u)return c%2n===0n?1n:-1n;if(c<0n)throw new e("Negative exponents not supported for integer power");a.checkOverflow&&s(u,c);let l=1n,p=u,g=c,f=0;for(;g>0n;){if(f++>a.maxSteps)throw new n("Power operation exceeded maximum computation steps");1n&g&&(l*=p),p*=p,g>>=1n}return a.precision>0?h(l,a.precision,a.roundingMode):l}function nt(t,e={}){const i={...tt,...e},o=r(t);if(a(o),0n===o)return 0n;if(1n===o)return 1n;let s,u=o>>1n,c=0;do{if(c++>i.maxSteps)throw new n("Square root operation exceeded maximum computation steps");s=u,u=u+o/u>>1n}while(u<s);return i.precision>0?h(s,i.precision,i.roundingMode):s}function rt(t,e,i={}){const o={...tt,...i},s=r(t),u=r(e);if(a(u),0n===u)return 1n;if(1n===u)return s;if(0n===s)return u%2n===0n?1n:0n;if(1n===s)return 1n;if(2n===s&&u>4n)throw new n("Tetration would overflow for base 2 and height > 4");let c=s,l=0;for(let t=1n;t<u;t++){if(l++>o.maxSteps)throw new n("Tetration operation exceeded maximum computation steps");c=et(s,c,o)}return o.precision>0?h(c,o.precision,o.roundingMode):c}var it={power:et,sqrt:nt,nthRoot:function(t,i,o={}){const s={...tt,...o},u=r(t),c=r(i);if(a(u),c<=0n)throw new e("Root index must be positive");if(0n===u)return 0n;if(1n===u)return 1n;if(1n===c)return u;if(2n===c)return nt(u,s);let l,p=u>>1n,g=0;const f=c-1n;do{if(g++>s.maxSteps)throw new n("Nth root operation exceeded maximum computation steps");l=p;p=(f*p+u/et(p,f,s))/c}while(p<l);return s.precision>0?h(l,s.precision,s.roundingMode):l},tetration:rt,superRoot:function(t,i,o={}){const s={...tt,...o},u=r(t),c=r(i);if(a(c),0n===c)throw new e("Height cannot be zero for super-root");if(u<1n)throw new e("Value must be at least 1 for super-root");if(1n===u)return 1n;if(1n===c)return u;let l=1n,p=u,g=0;for(;l<=p;){if(g++>s.maxSteps)throw new n("Super-root operation exceeded maximum computation steps");const t=l+p>>1n;try{const e=rt(t,c,s);if(e===u)return t;e<u?l=t+1n:p=t-1n}catch(e){p=t-1n}}return s.precision>0?h(p,s.precision,s.roundingMode):p}};class ot{constructor(t){this.heap=[],this.compare=t}size(){return this.heap.length}isEmpty(){return 0===this.heap.length}peek(){return this.heap[0]}push(t){this.heap.push(t),this.siftUp(this.heap.length-1)}pop(){if(this.isEmpty())return;const t=this.heap[0],e=this.heap.pop();return this.isEmpty()||(this.heap[0]=e,this.siftDown(0)),t}clear(){this.heap=[]}static heapify(t,e){const n=this instanceof st?new st(e):new at(e);return t.forEach((t=>n.push(t))),n}getParentIndex(t){return Math.floor((t-1)/2)}getLeftChildIndex(t){return 2*t+1}getRightChildIndex(t){return 2*t+2}swap(t,e){const n=this.heap[t];this.heap[t]=this.heap[e],this.heap[e]=n}}class st extends ot{constructor(t){super(t)}siftUp(t){for(;t>0;){const e=this.getParentIndex(t);if(this.compare(this.heap[t],this.heap[e])>=0)break;this.swap(t,e),t=e}}siftDown(t){const e=this.heap.length;for(;;){let n=t;const r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t);if(r<e&&this.compare(this.heap[r],this.heap[n])<0&&(n=r),i<e&&void 0!==this.heap[i]&&this.compare(this.heap[i],this.heap[n])<0&&(n=i),n===t)break;this.swap(t,n),t=n}}}class at extends ot{constructor(t){super(t)}siftUp(t){for(;t>0;){const e=this.getParentIndex(t);if(this.compare(this.heap[t],this.heap[e])<=0)break;this.swap(t,e),t=e}}siftDown(t){const e=this.heap.length;for(;;){let n=t;const r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t);if(r<e&&void 0!==this.heap[r]&&this.compare(this.heap[r],this.heap[n])>0&&(n=r),i<e&&void 0!==this.heap[i]&&this.compare(this.heap[i],this.heap[n])>0&&(n=i),n===t)break;this.swap(t,n),t=n}}}class ut{constructor(){this.nodes=new Map,this.maxComputedM=-1,this.maxComputedN=-1,this.heap=new at(((t,e)=>t>e?1:t<e?-1:0))}static getNodeKey(t,e){return`${t},${e}`}computeAckermann(t,e){if(t<0||e<0)throw new Error("Ackermann function undefined for negative numbers");const n=ut.getNodeKey(t,e),r=this.nodes.get(n);if(r)return r.value;let i;try{if(0===t)i=BigInt(e+1);else if(0===e)i=this.computeAckermann(t-1,1);else{const n=this.computeAckermann(t,e-1),r=n<=BigInt(Number.MAX_SAFE_INTEGER)?Number(n):Number.MAX_SAFE_INTEGER;i=this.computeAckermann(t-1,r)}}catch(t){if(t instanceof RangeError)return BigInt(Number.MAX_SAFE_INTEGER);throw t}return i}addNode(t,e){const n=ut.getNodeKey(t,e);if(this.nodes.has(n))return this.nodes.get(n);const r=this.computeAckermann(t,e),i={m:t,n:e,value:r};this.nodes.set(n,i);const o=ut.getNodeKey(t-1,e),s=ut.getNodeKey(t,e-1);if(this.nodes.has(o)){const t=this.nodes.get(o);i.prevM=t,t.nextM=i}if(this.nodes.has(s)){const t=this.nodes.get(s);i.prevN=t,t.nextN=i}return this.maxComputedM=Math.max(this.maxComputedM,t),this.maxComputedN=Math.max(this.maxComputedN,e),this.heap.push(r),i}buildRange(t,e){for(let n=0;n<=t;n++)for(let t=0;t<=e;t++)this.addNode(n,t)}getComputationPath(t,e){const n=[],r=ut.getNodeKey(t,e);let i=this.nodes.get(r);for(;i&&(n.push({m:i.m,n:i.n,value:i.value}),0!==i.m);)if(0===i.n)i=this.nodes.get(ut.getNodeKey(i.m-1,1));else{const t=this.nodes.get(ut.getNodeKey(i.m,i.n-1));t&&n.push({m:t.m,n:t.n,value:t.value});const e=t?.value??BigInt(0),r=e<=BigInt(Number.MAX_SAFE_INTEGER)?Number(e):Number.MAX_SAFE_INTEGER;i=this.nodes.get(ut.getNodeKey(i.m-1,r))}return n.reverse()}analyzeGrowthRate(t){const e=new Map;let n=BigInt(1);for(let r=0;r<=this.maxComputedN;r++){const i=ut.getNodeKey(t,r),o=this.nodes.get(i);if(!o||o.value>=BigInt(Number.MAX_SAFE_INTEGER))break;e.set(r,{value:o.value,increase:o.value-n,multiplier:n===BigInt(0)?BigInt(0):o.value/n}),n=o.value}return e}getLargestValue(){return this.heap.peek()??BigInt(0)}getValue(t,e){return this.nodes.get(ut.getNodeKey(t,e))?.value}}class ct{constructor(t){this.value="bigint"==typeof t?t:BigInt(t),this.left=null,this.right=null,this.parent=null,this.height=1,this.size=1,this.sum=this.value}updateStats(){this.height=1+Math.max(this.left?.height??0,this.right?.height??0),this.size=1+(this.left?.size??0)+(this.right?.size??0),this.sum=this.value+(this.left?.sum??BigInt(0))+(this.right?.sum??BigInt(0))}getBalance(){return(this.left?.height??0)-(this.right?.height??0)}getStats(){return{height:this.height,size:this.size,sum:this.sum,min:this.findMin().value,max:this.findMax().value}}findMin(){let t=this;for(;t.left;)t=t.left;return t}findMax(){let t=this;for(;t.right;)t=t.right;return t}}class ht{constructor(t){this.root=null,this.comparator=t??((t,e)=>t<e?-1:t>e?1:0)}getRoot(){return this.root}insert(t){const e="bigint"==typeof t?t:BigInt(t);return this.root=this.insertNode(this.root,e),this.find(e)}insertNode(t,e){if(!t)return new ct(e);const n=this.comparator(e,t.value);if(n<0)t.left=this.insertNode(t.left,e),t.left.parent=t;else{if(!(n>0))return t;t.right=this.insertNode(t.right,e),t.right.parent=t}return t.updateStats(),this.balance(t)}balance(t){const e=t.getBalance();return e>1?(t.left&&t.left.getBalance()<0&&(t.left=this.rotateLeft(t.left)),this.rotateRight(t)):e<-1?(t.right&&t.right.getBalance()>0&&(t.right=this.rotateRight(t.right)),this.rotateLeft(t)):t}rotateLeft(t){const e=t.right,n=e.left;return e.left=t,t.right=n,n&&(n.parent=t),e.parent=t.parent,t.parent=e,t.updateStats(),e.updateStats(),e}rotateRight(t){const e=t.left,n=e.right;return e.right=t,t.left=n,n&&(n.parent=t),e.parent=t.parent,t.parent=e,t.updateStats(),e.updateStats(),e}remove(t){const e="bigint"==typeof t?t:BigInt(t);return!!this.find(e)&&(this.root=this.removeNode(this.root,e),!0)}removeNode(t,e){if(!t)return null;const n=this.comparator(e,t.value);if(n<0)t.left=this.removeNode(t.left,e),t.left&&(t.left.parent=t);else if(n>0)t.right=this.removeNode(t.right,e),t.right&&(t.right.parent=t);else{if(!t.left)return t.right;if(!t.right)return t.left;const e=t.right.findMin();t.value=e.value,t.right=this.removeNode(t.right,e.value),t.right&&(t.right.parent=t)}return t.updateStats(),this.balance(t)}find(t){const e="bigint"==typeof t?t:BigInt(t);let n=this.root;for(;n;){const t=this.comparator(e,n.value);if(0===t)return n;n=t<0?n.left:n.right}return null}traverse(t="inOrder",e={}){const n=[],r=(i,o=0)=>{!i||void 0!==e.maxDepth&&o>=e.maxDepth||("preOrder"===t&&n.push(i.value),e.skipSubtrees||r(i.left,o+1),"inOrder"===t&&n.push(i.value),e.skipSubtrees||r(i.right,o+1),"postOrder"===t&&n.push(i.value))};return r(this.root),n}getTreeStats(){return this.root?.getStats()??null}getNthValue(t){if(!this.root||t<1||t>this.root.size)return null;const e=(t,n)=>{if(!t)return null;const r=t.left?.size??0;return n===r+1?t.value:n<=r?e(t.left,n):e(t.right,n-r-1)};return e(this.root,t)}getRange(t,e){const n="bigint"==typeof t?t:BigInt(t),r="bigint"==typeof e?e:BigInt(e),i=[],o=t=>{t&&(this.comparator(t.value,n)>=0&&this.comparator(t.value,r)<=0?(o(t.left),i.push(t.value),o(t.right)):this.comparator(t.value,n)>0?o(t.left):o(t.right))};return o(this.root),i}}class lt{constructor(t={}){const{initialCapacity:e=16,growthFactor:n=2,comparator:r=(t,e)=>t<e?-1:t>e?1:0}=t;this.capacity=e,this.growthFactor=n,this.comparator=r,this.size=0,this.data=new Array(this.capacity),this.segmentTree=new Array(4*this.capacity).fill(null)}getSize(){return this.size}getCapacity(){return this.capacity}resize(t){const e=new Array(t);for(let t=0;t<this.size;t++)e[t]=this.data[t];this.data=e,this.capacity=t,this.rebuildSegmentTree()}push(t){try{return this.size>=this.capacity&&this.resize(this.capacity*this.growthFactor),this.data[this.size]=t,this.updateSegmentTree(0,this.size,t),this.size++,{success:!0,value:this.size-1}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error during push"}}}pop(){if(0===this.size)return{success:!1,error:"Array is empty"};const t=this.data[this.size-1];return this.size--,this.size<this.capacity/(2*this.growthFactor)&&this.resize(Math.max(16,Math.floor(this.capacity/this.growthFactor))),{success:!0,value:t}}get(t){return t<0||t>=this.size?{success:!1,error:"Index out of bounds"}:{success:!0,value:this.data[t]}}set(t,e){if(t<0||t>=this.size)return{success:!1,error:"Index out of bounds"};const n=this.data[t];return this.data[t]=e,this.updateSegmentTree(0,t,e),{success:!0,value:n}}rebuildSegmentTree(){this.segmentTree=new Array(4*this.capacity).fill(null),this.size>0&&this.buildSegmentTree(0,0,this.size-1)}buildSegmentTree(t,e,n){if(e===n)return void(this.segmentTree[t]={value:this.data[e],start:e,end:n});const r=Math.floor((e+n)/2);this.buildSegmentTree(2*t+1,e,r),this.buildSegmentTree(2*t+2,r+1,n);const i=this.segmentTree[2*t+1],o=this.segmentTree[2*t+2];i&&o&&(this.segmentTree[t]={value:this.comparator(i.value,o.value)>=0?i.value:o.value,start:e,end:n})}updateSegmentTree(t,e,n){if(!this.segmentTree[t])return;const r=this.segmentTree[t];if(r.start===r.end)return void(r.value=n);e<=Math.floor((r.start+r.end)/2)?this.updateSegmentTree(2*t+1,e,n):this.updateSegmentTree(2*t+2,e,n);const i=this.segmentTree[2*t+1],o=this.segmentTree[2*t+2];i&&o&&(r.value=this.comparator(i.value,o.value)>=0?i.value:o.value)}queryRange(t,e){if(t<0||e>=this.size||t>e)return{success:!1,error:"Invalid range"};const n=this.querySegmentTree(0,t,e);return n?{success:!0,value:n}:{success:!1,error:"Range query failed"}}querySegmentTree(t,e,n){const r=this.segmentTree[t];if(!r)return null;if(e<=r.start&&n>=r.end)return r.value;if(n<r.start||e>r.end)return null;const i=this.querySegmentTree(2*t+1,e,n),o=this.querySegmentTree(2*t+2,e,n);return null===i?o:null===o||this.comparator(i,o)>=0?i:o}toHeap(t=!0){const e=t?new st(this.comparator):new at(this.comparator);for(let t=0;t<this.size;t++)void 0!==this.data[t]&&void 0!==this.data[t]&&e.push(this.data[t]);return e}sort(t=!0){const e=this.toHeap(!t);for(let t=this.size-1;t>=0;t--){const n=e.pop();void 0!==n&&(this.data[t]=n)}this.rebuildSegmentTree()}toArray(){return this.data.slice(0,this.size)}}const pt={maxHeight:100,maxValue:BigInt(Number.MAX_SAFE_INTEGER),checkOverflow:!0,precision:0};class gt{constructor(t={}){this.options={...pt,...t},this.head=null,this.tail=null,this.size=0}createNode(t,e){return{value:t,height:e,evaluated:!1,previous:null,next:null}}validateHeight(t){if(t<0)throw new e("Height cannot be negative");if(t>this.options.maxHeight)throw new e(`Height exceeds maximum of ${this.options.maxHeight}`)}validateValue(t){if(a(t),this.options.checkOverflow&&t>this.options.maxValue)throw new n(`Value exceeds maximum of ${this.options.maxValue}`)}computePower(t,e){if(e===BigInt(0))return BigInt(1);if(e===BigInt(1))return t;let r=t;for(let i=BigInt(1);i<e;i++)if(this.options.checkOverflow){const e=r*t;if(e>this.options.maxValue)throw new n("Power computation would overflow");r=e}else r*=t;return r}build(t,e){this.validateHeight(e);const n="bigint"==typeof t?t:BigInt(t);this.validateValue(n),this.clear();for(let t=0;t<e;t++){const e=this.createNode(n,t+1);this.head?(e.previous=this.tail,this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),this.size++}}evaluate(t){if(!this.head)return BigInt(1);const e=t??this.size;this.validateHeight(e);let r=this.head,i=r.value,o=1;try{for(;r.next&&o<e;)i=this.computePower(r.next.value,i),r.evaluated=!0,r=r.next,o++;return r.evaluated=!0,i}catch(t){if(t instanceof n){let e=this.head;for(;e!==r;)e.evaluated=!0,e=e.next;throw t}throw t}}getHeight(){return this.size}isComputable(t){try{const e=t??this.size;this.validateHeight(e);let n=this.head,r=0;for(;n&&r<e;){if(n.value>BigInt(4)&&r>3)return!1;n=n.next,r++}const i={...this.options,maxValue:this.options.maxValue>>BigInt(1)},o=new gt(i);return o.build(this.head.value,e),o.evaluate(),!0}catch{return!1}}getState(){const t=[];let e=this.head;for(;e;)t.push({height:e.height,value:e.value,evaluated:e.evaluated}),e=e.next;return t}clear(){this.head=null,this.tail=null,this.size=0}static getMaxFeasibleHeight(t){const e="bigint"==typeof t?t:BigInt(t);return a(e),e===BigInt(0)?0:e===BigInt(1)?1/0:e===BigInt(2)?4:e===BigInt(3)?3:e===BigInt(4)?2:1}toString(){if(!this.head)return"Empty Tower";let t=this.head.value.toString(),e=this.head;for(;e.next;)t=`${e.next.value}^(${t})`,e=e.next;return t}}const ft={notation:"standard",precision:0,grouping:!0,groupSize:3,decimalSeparator:".",groupSeparator:","},dt=(t,e={})=>{const n={...ft,...e},r=t<BigInt(0),i=r?-t:t;let o;switch(n.notation){case"scientific":o=It(i,n).coefficient+"e"+It(i,n).exponent;break;case"engineering":o=Et(i,n);break;case"compact":o=wt(i,n);break;default:o=mt(i,n)}return r?"-"+o:o},mt=(t,e)=>{let n=t.toString();if(!e.grouping)return n;const r=[];let i=n.length;for(;i>0;){const t=Math.max(0,i-e.groupSize);r.unshift(n.slice(t,i)),i=t}return r.join(e.groupSeparator)},It=(t,e)=>{if(t===BigInt(0))return{coefficient:"0",exponent:0};const n=t.toString(),r=n.length-1;let i=n[0]||"";return i+=e.decimalSeparator+n.slice(1,e.precision+1),{coefficient:i,exponent:r}},Et=(t,e)=>{if(t===BigInt(0))return"0";const n=t.toString(),r=n.length,i=3*Math.floor((r-1)/3);let o="";const s=r-i;for(let t=0;t<Math.min(r,s+e.precision);t++)t===s&&t<r&&(o+=e.decimalSeparator),o+=n[t];return`${o}e${i}`},wt=(t,e)=>{const n=["","K","M","B","T","Q"],r=t.toString().length;if(r<=3)return mt(t,e);const i=Math.min(Math.floor((r-1)/3),n.length-1),o=n[i],s=BigInt(10)**BigInt(3*i);let a=(t/s).toString();if(e.precision>0){const n=t%s;if(n>BigInt(0)){const t=n.toString().padStart(3,"0").slice(0,e.precision);a+=e.decimalSeparator+t}}return a+o};t.RoundingMode.HALF_EVEN,t.RoundingMode.HALF_EVEN;function vt(t){const e=function(t={}){if(d(t)){const e=t;return{...f,...e,arithmetic:{...f.arithmetic,...e.arithmetic},dataStructures:{...f.dataStructures,...e.dataStructures},formatting:{...f.formatting,...e.formatting},performance:{...f.performance,...e.performance},debug:{...f.debug,...e.debug},features:{...f.features,...e.features}}}return{precision:t.precision??g.precision,roundingMode:t.roundingMode??g.roundingMode,checkOverflow:t.checkOverflow??g.checkOverflow,maxSteps:t.maxSteps??g.maxSteps,debug:t.debug??g.debug}}(t||{});return m(e),{config:e,arithmetic:K,bitwise:J,power:$,AckermannStructure:ut,BigArray:lt,NumberTree:ht,MinHeap:st,MaxHeap:at,PowerTower:gt}}var Bt=vt();t.AckermannStructure=ut,t.BigArray=lt,t.ComputationLimitError=C,t.DEFAULT_ARRAY_GROWTH_FACTOR=2,t.DEFAULT_CACHE_SIZE=1e3,t.DEFAULT_DECIMAL_SEPARATOR=".",t.DEFAULT_GROUP_SEPARATOR=",",t.DEFAULT_GROUP_SIZE=3,t.DEFAULT_HEAP_INITIAL_CAPACITY=16,t.DEFAULT_OPTIONS=y,t.DEFAULT_TREE_MAX_DEPTH=1e3,t.DataStructureError=H,t.DivisionByZeroError=L,t.ERROR_MESSAGES=_,t.FEATURES={OVERFLOW_CHECKING:!0,AUTOMATIC_PRECISION:!0,MEMOIZATION:!0,TREE_BALANCING:!0,DEBUG_MODE:!1},t.FormatError=k,t.HeapPropertyError=D,t.HypernumError=O,t.IndexError=V,t.MAX_ACKERMANN_M=4,t.MAX_ACKERMANN_N=1e3,t.MAX_BITS=1024,t.MAX_CACHE_SIZE=1e4,t.MAX_COMPUTATION_STEPS=1e3,t.MAX_FACTORIAL_INPUT=M,t.MAX_GROUP_SIZE=10,t.MAX_POWER_BASE=A,t.MAX_POWER_EXPONENT=b,t.MAX_PRECISION=100,t.MAX_ROMAN_VALUE=3999,t.MAX_SAFE_INTEGER=I,t.MAX_TETRATION_HEIGHT=S,t.MIN_ARRAY_CAPACITY=16,t.MIN_ROMAN_VALUE=1,t.MIN_SAFE_INTEGER=E,t.MaxHeap=at,t.MinHeap=st,t.NEGATIVE_ONE=N,t.NUMBER_UNITS=[{value:1n,symbol:""},{value:1000n,symbol:"K"},{value:1000000n,symbol:"M"},{value:1000000000n,symbol:"B"},{value:1000000000000n,symbol:"T"},{value:1000000000000000n,symbol:"Q"}],t.NumberTree=ht,t.ONE=v,t.OverflowError=n,t.PERFORMANCE={WARN_THRESHOLD_MS:100,ERROR_THRESHOLD_MS:1e3,MAX_ARRAY_SIZE:1e6,MAX_TREE_SIZE:1e6},t.PowerTower=gt,t.PrecisionError=F,t.RomanNumeralError=U,t.TEN=x,t.TWO=B,t.TreeError=z,t.UnderflowError=P,t.VERSION="0.1.0",t.ValidationError=e,t.ZERO=w,t.arithmetic=K,t.bitwise=J,t.calculateRequiredPrecision=t=>{if(0n===t)return 0;const e=t.toString().split("").reverse().findIndex((t=>"0"!==t));return-1===e?0:e},t.checkAdditionOverflow=i,t.checkMultiplicationOverflow=o,t.checkPowerOverflow=s,t.createError=function(t,e){switch(e){case"validation":return new R(t);case"overflow":return new T(t);case"underflow":return new P(t);case"division":return new L(t);case"precision":return new F(t);case"computation":return new C(t);case"heap":return new D(t);case"tree":return new z(t);case"index":return new V(t);case"format":return new k(t);case"roman":return new U(t);default:return new O(t)}},t.createHypernum=vt,t.default=Bt,t.equalWithinPrecision=(t,e,n)=>{const r=t-e,i=BigInt(10)**BigInt(n);return r.toString().length<=i.toString().length},t.formatBigInt=dt,t.formatPercentage=(t,n,r=2)=>{if(n===BigInt(0))throw new e("Cannot calculate percentage with zero total");return`${(100*Number(t)/Number(n)).toFixed(r)}%`},t.formatRange=(t,e,n={})=>`[${dt(t,n)} ... ${dt(e,n)}]`,t.formatTreeValue=(t,e=0)=>`${"  ".repeat(e)}${dt(t,{notation:"compact"})}`,t.isHypernumError=X,t.normalizeNumberString=t=>{if((t=t.replace(/[\s,]/g,"")).toLowerCase().includes("e")){const[e,n]=t.toLowerCase().split("e"),r=parseInt(n||"0");return(parseFloat(e||"0")*Math.pow(10,r)).toString()}return t},t.normalizePrecision=l,t.parseBigIntString=(t,e={})=>{const n={...ft,...e};let r=t.replace(new RegExp(`\\${n.groupSeparator}`,"g"),"");if(r.toLowerCase().includes("e")){const[t,e]=r.toLowerCase().split("e"),n=BigInt(10),i=BigInt(e||"0");return BigInt(Math.floor(Number(t)))*n**i}const i=new Map([["k",BigInt(1e3)],["m",BigInt(1e6)],["b",BigInt(1e9)],["t",BigInt(1e12)],["q",BigInt(1e15)]]),o=r.slice(-1).toLowerCase(),s=i.get(o);if(s){r=r.slice(0,-1);return BigInt(Math.floor(Number(r)))*s}return BigInt(r)},t.power=it,t.round=h,t.scaleByPowerOfTen=c,t.scaledDivision=p,t.toBigInt=r,t.validateNonNegative=a,t.validatePositive=t=>{if(t<=BigInt(0))throw new e("Value must be positive")},t.wrapError=function(t){return X(t)?t:t instanceof Error?new O(t.message):new O("An unknown error occurred")},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
